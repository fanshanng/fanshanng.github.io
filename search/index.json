[{"content":"安卓逆向入门四 关键词：apk签名、apk校验及对抗方法、PM代理、io重定向\n学习链接：https://www.52pojie.cn/thread-1731181-1-1.html\n0x00 APK签名 校验是开发者在数据传送时采用的一种校正数据的一种方式 常见的校验有:签名校验(最常见)、dexcrc校验、apk完整性校验、路径文件校验等\n什么是APK签名? 我建议直接去看 Android 官方文档 中关于 APK签名 的安全特性介绍。\nAPK签名是开发者使用私钥对安卓应用进行数字签名的过程，确保应用的完整性和来源，防止被篡改。只有经过签名的应用才能在安卓设备上安装和运行，签名还帮助系统识别应用的开发者，并确保应用在独立的沙盒环境中安全运行。 Android 目前支持以下四种应用签名方案： v1 方案：基于 JAR 签名。 v2 方案：APK 签名方案 v2（在 Android 7.0 中引入） v3 方案：APK 签名方案 v3（在 Android 9 中引入） v4 方案：APK 签名方案 v4（在 Android 11 中引入） 签名方案 推出版本 校验范围 安全优势 局限性 适用场景 v1（JAR 签名） Android 1.0 仅校验 APK 内单个文件（META-INF 下签名文件） 兼容所有安卓版本 可篡改未签名文件（如新增文件） 需兼容 Android 6.0 及以下设备 v2 Android 7.0 校验整个 APK（通过 “签名块” 校验 APK 完整性） 更高效（无需解压）、防篡改新增文件 不兼容 Android 6.0 及以下 目标设备为 Android 7.0+ v3 Android 9.0 在 v2 基础上支持 “签名轮换”（更换签名无需卸载旧版） 支持签名更新（如企业应用换证书） 依赖 Android 9.0+ 需要签名更新的应用（如企业级 APP） v4 Android 11.0 生成单独的签名文件（.apksig），支持增量更新校验 优化大文件安装效率（仅校验变更部分） 依赖 Android 11.0+ 大型应用（如游戏）的增量更新 v4签名生成的.apksig文件必须配合adb install --incremental使用，常规APK安装不会触发此校验。逆向中较少遇到，主要用于Google Play增量更新。 一次让你搞懂Android应用签名 这篇文章讲了签名步骤和原理相关知识，值得一看 APP 的签名检验 系统更多的只是对 APK 做完整性校验，身份校验很容易通过卸载方式来解决，因此许多 APP 为了防止自身被修改和破解，会对自身进行额外的校验，确保没有被修改。\n我们一般称此类检查自身是否被修改的保护技术为签名校验，其校验原理几乎也都是基于文件完整性检验与签名身份信息验证。\n1 2 3 4 5 kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因. system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。 finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理 普通获取签名校验代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private boolean SignCheck() { String trueSignMD5 = \u0026#34;d0add9987c7c84aeb7198c3ff26ca152\u0026#34;; String nowSignMD5 = \u0026#34;\u0026#34;; try { // 得到签名的MD5 PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES); Signature[] signs = packageInfo.signatures; String signBase64 = Base64Util.encodeToString(signs[0].toByteArray()); nowSignMD5 = MD5Utils.MD5(signBase64); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return trueSignMD5.equals(nowSignMD5); } 系统将应用的签名信息封装在PackageInfo中，调用 PackageManager 的getPackageInfo(String packageName, int flags)即可获取指定包名的签名信息.\n0x01 签名校验对抗 方法一:核心破解插件，不签名安装应用 方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能 方法三:具体分析签名校验逻辑(手撕签名校验) 方法四:io重定向\u0026ndash;VA\u0026amp;SVC：ptrace+seccomp SVC的TraceHook沙箱的实现\u0026amp;无痕Hook实现思路 方法五:去作者家严刑拷打拿到.jks文件和密码\n0x02 手动实现PM代{过}{滤}理 1.什么是PMS 思路源自：Android中Hook 应用签名方法\nPackageManagerService（简称PMS），是Android系统核心服务之一，处理包管理相关的工作，常见的比如安装、卸载应用等。\n核心原理\n安卓应用获取签名的流程：应用调用PackageManager.getPackageInfo() → 系统通过PMS（PackageManagerService）查询签名信息并返回； PM 代理的本质：通过 Hook 替换PMS的返回结果 —— 当应用查询签名时，返回原始合法签名（而非修改后 APK 的签名），从而绕过校验。 使用条件与限制\n环境要求：需要 root 权限（修改系统服务）或通过 Xposed/LSPosed 框架（无需 root，但需模块支持）； 局限性：仅对通过PackageManager获取签名的校验有效，若应用直接读取 APK 文件计算签名（如读取/data/app/xxx.apk的签名），则 PM 代理无效（需结合IO重定向，将应用访问的APK路径（如/data/app/包名/base.apk）重定向到保留原始签名的伪造APK文件（仅包含签名所需文件，如META-INF/）。 2.实现方法以及原理解析 HOOK PMS代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.zj.hookpms; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import android.content.Context; import android.content.pm.PackageManager; import android.util.Log; public class ServiceManagerWraper { public final static String ZJ = \u0026#34;ZJ595\u0026#34;; public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) { try { // 获取全局的ActivityThread对象 Class\u0026lt;?\u0026gt; activityThreadClass = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 获取ActivityThread里面原始的sPackageManager Field sPackageManagerField = activityThreadClass.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); // 准备好代{过}{滤}理对象, 用来替换原始的对象 Class\u0026lt;?\u0026gt; iPackageManagerInterface = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{iPackageManagerInterface}, new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0)); // 1. 替换掉ActivityThread里面的 sPackageManager 字段 sPackageManagerField.set(currentActivityThread, proxy); // 2. 替换 ApplicationPackageManager里面的 mPM对象 PackageManager pm = context.getPackageManager(); Field mPmField = pm.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPmField.setAccessible(true); mPmField.set(pm, proxy); } catch (Exception e) { Log.d(ZJ, \u0026#34;hook pms error:\u0026#34; + Log.getStackTraceString(e)); } } public static void hookPMS(Context context) { String Sign = \u0026#34;原包的签名信息\u0026#34;; hookPMS(context, Sign, \u0026#34;com.zj.hookpms\u0026#34;, 0); } } ActivityThread的静态变量sPackageManager ApplicationPackageManager对象里面的mPM变量\n0x03 IO重定向 什么是IO重定向？\nI/O重定向是指改变程序的标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）的默认设备，将其与其他设备或文件进行关联。通过I/O重定向，我们可以将程序的输入从键盘转向文件或其他设备，将程序的输出和错误信息输出到文件或其他设备而不是屏幕上。\n例：在读A文件的时候指向B文件\n平头哥的核心代码 Virtual Engine for Android(Support 12.0 in business version)\nIO重定向可以干嘛？\n1，可以让文件只读，不可写\n2，禁止访问文件\n3，路径替换\n具体实现： 过签名检测(读取原包) 风控对抗(例:一个文件记录App启动的次数) 过Root检测，Xposed检测(文件不可取)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 using namespace std; string packname; string origpath; string fakepath; int (*orig_open)(const char *pathname, int flags, ...); int (*orig_openat)(int,const char *pathname, int flags, ...); FILE *(*orig_fopen)(const char *filename, const char *mode); static long (*orig_syscall)(long number, ...); int (*orig__NR_openat)(int,const char *pathname, int flags, ...); void* (*orig_dlopen_CI)(const char *filename, int flag); void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo); void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr); static inline bool needs_mode(int flags) { return ((flags \u0026amp; O_CREAT) == O_CREAT) || ((flags \u0026amp; O_TMPFILE) == O_TMPFILE); } bool startsWith(string str, string sub){ return str.find(sub)==0; } bool endsWith(string s,string sub){ return s.rfind(sub)==(s.length()-sub.length()); } bool isOrigAPK(string path){ if(path==origpath){ return true; } return false; } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_open 函数有三个参数： //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 int fake_open(const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } //LOGI(\u0026#34;open, path: %s, flags: %d, mode: %d\u0026#34;,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_open, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_open(\u0026#34;/data/user/0/com.zj.wuaipojie/files/base.apk\u0026#34;, flags, mode); } return orig_open(pathname, flags, mode); } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_openat 函数有四个参数： //fd：一个整数，表示要打开的文件的文件描述符。 //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 //openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。 //例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。 // int fake_openat(int fd, const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } LOGI(\u0026#34;openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,fd ,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_openat(fd,fakepath.data(), flags, mode); } return orig_openat(fd,pathname, flags, mode); } FILE *fake_fopen(const char *filename, const char *mode) { string cpp_path= filename; if(isOrigAPK(cpp_path)){ return orig_fopen(fakepath.data(), mode); } return orig_fopen(filename, mode); } //该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。 //syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。 // static long fake_syscall(long number, ...) { void *arg[7]; va_list list; va_start(list, number); for (int i = 0; i \u0026lt; 7; ++i) { arg[i] = va_arg(list, void *); } va_end(list); if (number == __NR_openat){ const char *cpp_path = static_cast\u0026lt;const char *\u0026gt;(arg[1]); LOGI(\u0026#34;syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,arg[0] ,arg[1], arg[2], arg[3]); if (isOrigAPK(cpp_path)){ LOGI(\u0026#34;syscall __NR_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,arg[1], fakepath.data()); return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]); } } return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]); } //函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中 //函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中 //接着，函数使用 fakepath 全局变量保存了 /data/user/0/\u0026lt;packname\u0026gt;/files/base.apk 这样的路径，其中 \u0026lt;packname\u0026gt; 是当前应用的包名。 //然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。 //它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。 //最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) { jclass conext_class = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack = env-\u0026gt;GetMethodID(conext_class, \u0026#34;getPackageName\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;); auto packname_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;CallObjectMethod(context, methodId_pack)); const char *pn = env-\u0026gt;GetStringUTFChars(packname_js, 0); packname = string(pn); env-\u0026gt;ReleaseStringUTFChars(packname_js, pn); //LOGI(\u0026#34;packname: %s\u0026#34;, packname.data()); fakepath= \u0026#34;/data/user/0/\u0026#34;+ packname +\u0026#34;/files/base.apk\u0026#34;; jclass conext_class2 = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack2 = env-\u0026gt;GetMethodID(conext_class2,\u0026#34;getApplicationInfo\u0026#34;,\u0026#34;()Landroid/content/pm/ApplicationInfo;\u0026#34;); jobject application_info = env-\u0026gt;CallObjectMethod(context,methodId_pack2); jclass pm_clazz = env-\u0026gt;GetObjectClass(application_info); jfieldID package_info_id = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;sourceDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto sourceDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id)); const char *sourceDir = env-\u0026gt;GetStringUTFChars(sourceDir_js, 0); origpath = string(sourceDir); LOGI(\u0026#34;sourceDir: %s\u0026#34;, sourceDir); jfieldID package_info_id2 = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;nativeLibraryDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto nativeLibraryDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id2)); const char *nativeLibraryDir = env-\u0026gt;GetStringUTFChars(nativeLibraryDir_js, 0); LOGI(\u0026#34;nativeLibraryDir: %s\u0026#34;, nativeLibraryDir); //LOGI(\u0026#34;%s\u0026#34;, \u0026#34;Start Hook\u0026#34;); //启动hook void *handle = dlopen(\u0026#34;libc.so\u0026#34;,RTLD_NOW); auto pagesize = sysconf(_SC_PAGE_SIZE); auto addr = ((uintptr_t)dlsym(handle,\u0026#34;open\u0026#34;) \u0026amp; (-pagesize)); auto addr2 = ((uintptr_t)dlsym(handle,\u0026#34;openat\u0026#34;) \u0026amp; (-pagesize)); auto addr3 = ((uintptr_t)fopen) \u0026amp; (-pagesize); auto addr4 = ((uintptr_t)syscall) \u0026amp; (-pagesize); //解除部分机型open被保护 mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); DobbyHook((void *)dlsym(handle,\u0026#34;open\u0026#34;), (void *)fake_open, (void **)\u0026amp;orig_open); DobbyHook((void *)dlsym(handle,\u0026#34;openat\u0026#34;), (void *)fake_openat, (void **)\u0026amp;orig_openat); DobbyHook((void *)fopen, (void *)fake_fopen, (void**)\u0026amp;orig_fopen); DobbyHook((void *)syscall, (void *)fake_syscall, (void **)\u0026amp;orig_syscall); } 1 2 3 4 5 6 7 sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils; invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;getContext()Landroid/content/Context; move-result-object p10 invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;-\u0026gt;hook(Landroid/content/Context;)V 0x04 其他常见校验 root检测：\n反制手段 1.算法助手、对话框取消等插件一键hook 2.分析具体的检测代码 3.利用IO重定向使文件不可读 4.修改Andoird源码，去除常见指纹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fun isDeviceRooted(): Boolean { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3() } fun checkRootMethod1(): Boolean { val buildTags = android.os.Build.TAGS return buildTags != null \u0026amp;\u0026amp; buildTags.contains(\u0026#34;test-keys\u0026#34;) } fun checkRootMethod2(): Boolean { val paths = arrayOf(\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;, \u0026#34;/su/bin/su\u0026#34;) for (path in paths) { if (File(path).exists()) return true } return false } fun checkRootMethod3(): Boolean { var process: Process? = null return try { process = Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;)) val bufferedReader = BufferedReader(InputStreamReader(process.inputStream)) bufferedReader.readLine() != null } catch (t: Throwable) { false } finally { process?.destroy() } } 定义了一个 isDeviceRooted() 函数，该函数调用了三个检测 root 的方法：checkRootMethod1()、checkRootMethod2() 和 checkRootMethod3()。\ncheckRootMethod1() 方法检查设备的 build tags 是否包含 test-keys。这通常是用于测试的设备，因此如果检测到这个标记，则可以认为设备已被 root。\ncheckRootMethod2() 方法检查设备是否存在一些特定的文件，这些文件通常被用于执行 root 操作。如果检测到这些文件，则可以认为设备已被 root。\ncheckRootMethod3() 方法使用 Runtime.exec() 方法来执行 which su 命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被 root。\n模拟器检测\n1 2 3 fun isEmulator(): Boolean { return Build.FINGERPRINT.startsWith(\u0026#34;generic\u0026#34;) || Build.FINGERPRINT.startsWith(\u0026#34;unknown\u0026#34;) || Build.MODEL.contains(\u0026#34;google_sdk\u0026#34;) Build.MODEL.contains(\u0026#34;Emulator\u0026#34;) || Build.MODEL.contains(\u0026#34;Android SDK built for x86\u0026#34;) || Build.MANUFACTURER.contains(\u0026#34;Genymotion\u0026#34;) || Build.HOST.startsWith(\u0026#34;Build\u0026#34;) || Build.PRODUCT == \u0026#34;google_sdk\u0026#34; } 通过检测系统的 Build 对象来判断当前设备是否为模拟器。具体方法是检测 Build.FINGERPRINT 属性是否包含字符串 \u0026quot;generic\u0026quot;。\n模拟器检测对抗\n反调试检测\n安卓系统自带调试检测函数 1 2 3 4 5 6 fun checkForDebugger() { if (Debug.isDebuggerConnected()) { // 如果调试器已连接，则终止应用程序 System.exit(0) } } debuggable属性 1 2 3 4 5 6 public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this { boolean isDebug = context.getApplicationInfo() != null \u0026amp;\u0026amp; (context.getApplicationInfo().flags \u0026amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; return isDebug; } ptrace检测 1 2 3 4 int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote { return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试 } 每个进程同时刻只能被1个调试进程ptrace ，主动ptrace本进程可以使得其他调试器无法调试\n调试进程名检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int SearchObjProcess() { FILE* pfile=NULL; char buf[0x1000]={0}; pfile=popen(\u0026#34;ps\u0026#34;,\u0026#34;r\u0026#34;); if(NULL==pfile) { //LOGA(\u0026#34;SearchObjProcess popen打开命令失败!\\n\u0026#34;); return -1; } // 获取结果 //LOGA(\u0026#34;popen方案:\\n\u0026#34;); while(fgets(buf,sizeof(buf),pfile)) { char* strA=NULL; char* strB=NULL; char* strC=NULL; char* strD=NULL; strA=strstr(buf,\u0026#34;android_server\u0026#34;);//通过查找匹配子串判断 strB=strstr(buf,\u0026#34;gdbserver\u0026#34;); strC=strstr(buf,\u0026#34;gdb\u0026#34;); strD=strstr(buf,\u0026#34;fuwu\u0026#34;); if(strA || strB ||strC || strD) { return 1; // 执行到这里，判定为调试状态 } } pclose(pfile); return 0; } [原创]对安卓反调试和校验检测的一些实践与结论\nfrida检测 一些Frida检测手段\n0x05 smali语法\u0026mdash;\u0026ndash;赋值 1.Int型赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 .method private static final onCreate$lambda-0(Lcom/zj/wuaipojie/ui/SmaliLearn;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/view/View;)V .registers 9 .line 21 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;isVip()I move-result p4 //判断vip的值分别对应不用的会员的等级 if-eqz p4, :cond_35 const/4 v0, 0x1 if-eq p4, v0, :cond_2d const/4 v0, 0x4 if-eq p4, v0, :cond_25 const/16 v0, 0x10 if-eq p4, v0, :cond_1d const/16 v0, 0x63 if-eq p4, v0, :cond_15 goto :goto_3c :cond_15 const-string p4, \u0026#34;至尊会员\u0026#34; .line 26 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_1d const-string p4, \u0026#34;超级会员\u0026#34; .line 25 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_25 const-string p4, \u0026#34;大会员\u0026#34; .line 24 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_2d const-string p4, \u0026#34;会员\u0026#34; .line 23 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_35 const-string p4, \u0026#34;非会员\u0026#34; .line 22 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 28 //判断vipEndTime的时间戳是否小于系统时间 :goto_3c new-instance p1, Ljava/util/Date; invoke-direct {p1}, Ljava/util/Date;-\u0026gt;\u0026lt;init\u0026gt;()V invoke-virtual {p1}, Ljava/util/Date;-\u0026gt;getTime()J move-result-wide v0 .line 29 new-instance p1, Ljava/text/SimpleDateFormat; const-string p4, \u0026#34;yyyy-MM-dd\u0026#34; invoke-direct {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;)V .line 30 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v2 cmp-long p4, v2, v0 if-gez p4, :cond_5c const-string p1, \u0026#34;已过期\u0026#34; .line 31 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_6d .line 33 :cond_5c invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v0 invoke-static {v0, v1}, Ljava/lang/Long;-\u0026gt;valueOf(J)Ljava/lang/Long; move-result-object p4 invoke-virtual {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;format(Ljava/lang/Object;)Ljava/lang/String; move-result-object p1 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 35 :goto_6d iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V :cond_74 return-void .end method const/4和const/16的区别？\nconst/4 最大只允许存放4个二进制位(4bit)，\nconst/16 最大值允许存放16个二进制位(16bit)， 第一位(即最高位)默认为符号位。单位换算 1byte=8bit 举例说明下寄存器的取值范围: # 以下数据定义高位默认为符号位\nconst/4 v0,0x2 # 最大只允许存放半字节数据 取值范围为 -8 and 7\nconst/16 v0 , 0xABCD # 定义一个寄存器变量，最大只允许存放16位数据 比如short类型数据 取值范围为-32768~32767\nconst v0 , 0xA# 定义一个寄存器， 最大只允许存放32位数据,比如int类型数据 将数字10赋值给v0 取值范围-2147483647~2147483647\nconst/high16 #定义一个寄存器， 最大只允许存放高16位数值 比如0xFFFF0000末四位补0 存入高四位0XFFFF\n2.Long型赋值 const-wide vx, lit32 表示将一个 32 位的常量存储到 vx 与 vx+1 两个寄存器中 —— 即一个 long 类型的数据\n1 2 3 4 5 6 7 .method public final vipEndTime()J .registers 3 const-wide v0, 0x1854460ef29L return-wide v0 .end method -会员到期时间就是2022年12月24日。那么1854460ef29L 怎么来的呢？也就是（2022年12月24日-1970年1月1日）×365天×24小时×60分钟×60秒×1000毫秒，转换成16进制就大概是那个数了\n在线时间戳转换\n3.变量赋值(正则) 1 2 3 4 5 6 7 8 9 10 11 12 iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V *. ** 这个表示任意寄存器，什么寄存器都能匹配，所以你正则查找的时候只需把寄存器替换成这个就可以了 (.*) 这里多了个英文小括号，框哪个就是对哪个寄存器赋值。 参考文章：\nAPK 签名：v1 v2 v3 v4 如何把签名校验做到极致 Android PMS HOOK [实战破解]白描-动态代{过}{滤}理Hook签名校验 [原创]对安卓反调试和校验检测的一些实践与结论 新版MT去签及对抗 【小白教程】正则匹配的写法 多行匹配 批量赋值 smali逆向 简单实用\n逆向之Smali入门学习\n","date":"2025-07-20T12:02:51+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124723.png","permalink":"https://fanshanng.github.io/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%9B%9B/","title":"安卓逆向入门四"},{"content":"安卓逆向入门三 学习关键词: Jeb、动态调试、Log插桩\n学习链接：《安卓逆向这档事》五、1000-7=？\u0026amp;动态调试\u0026amp;Log插桩\nJEB学习 环境配置\nJava环境配置，我这里不细讲。没有配置过java环境的我建议去看看 多个 JDK 版本（Java 8、Java 17、Java 21）下载和切换 这篇文章，我的建议是一开始就做好java多版本共存的准备 下载JEB\nJEB (Java Editor for Android) 是一款用于安卓应用逆向工程的工具，它可以帮助开发者分析和修改安卓应用的字节码。\njeb推荐jdk-11或jdk-17（我用的是jdk-11）\n下载教程可以看这篇文章：JEB动态调试Smali-真机/模拟器（详细，新手必看）\n本次学习下载正己提供的jeb安装包，下载好就可以使用，如果需要激活就去看上面的文章\n动态调试 熟悉IDA的逆向人应该知道动态调试是什么，这里指的是Android动态调试，\n修改方法：\n修改debug权限 **方法一:**在AndroidManifest.xml里添加可调试权限\n1 android:debuggable=\u0026#34;true\u0026#34; **方法二：**XappDebug模块hook对应的app\n**方法三：**Magisk命令(重启失效)\n1 2 3 4 5 6 7 1. adb shell #adb进入命令行模式 2. su #切换至超级用户 3. magisk resetprop ro.debuggable 1 4. stop;start; #一定要通过该方式重启 **方法四:**刷入MagiskHide Props Config模块\n一般来说，在4选项中如果有ro.debuggable那就直接修改\n没有的话就选5\n端口转发以及开启adb权限 版本号点击七次开启开发者模式并开启adb调试权限 有时候重新进入模拟器的时候usb调试会取消，需要手动开启 下断点 ctrl+b下断点\ndebug模式启动 1 adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity adb shell am start -D -n adb shell am start -D -n 包名/类名 am start -n 表示启动一个activity am start -D 表示将应用设置为可调试模式\nJeb附加调试进程 常用快捷键： F6 进入方法 F6 跳过方法 F7 从方法中跳出来 R 运行到光标处\n运行到断点 步进 得到参数值：5qKA5q61DAUM\nLog插桩 定义：Log 插桩是在反编译 APK 后的 Smali 代码中插入日志输出语句，通过Log.v()等方法将关键变量、函数调用过程打印到系统日志，适用于无法动态调试或需要追踪后台逻辑的场景。\n1 invoke-static {对应寄存器}, Lcom/mtools/LogUtils;-\u0026gt;v(Ljava/lang/Object;)V 在应用里随机输入字符串，然后查看日志 ","date":"2025-06-26T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124652.png","permalink":"https://fanshanng.github.io/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B8%89/","title":"安卓逆向入门三"},{"content":"0x00 smali及其语法 smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 Smali是Dalvik虚拟机和ART运行时的寄存器指令语言，相当于Android平台的汇编语言。当APK被反编译时，DEX文件会转换为Smali代码（.smali文件），它是逆向分析的核心载体。\n关键字\n名称 注释 .class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应\nsmali类型 java类型 注释 V void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx/xxx/xxx object 对象类型，返回对象 常用指令\n关键字 注释 const 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a=b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!=b)，ab内容不相同则跳 if-eqz 全称equal zero(a=0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!=0)，a不等于0则跳 if-ge 全称greater equal(a\u0026gt;=b)，a大于或等于则跳 if-le 全称little equal(a\u0026lt;=b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 “vip终结者” 定位方法：\n搜索弹窗关键字（用jd-gui搜索字符串）、抓取按钮id（本质与前一个方法一样）\n（字符串有时候是用unicode显示，搜关键文字搜不到的话可以试试搜对应的unicode）\n（此处演示的是抓取按钮id）\n修改方法：\n修改判断、强制跳转、修改寄存器的值 (这里与反调试中修改标志位或者修改跳转指令类似)\ndemo代码例子（注释为正己所写）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //一个私有、静态、不可变的方法 方法名 .method private static final onCreate$lambda-2(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z //(这里面是方法的参数)这里是方法返回值类型，表示布尔值类型，返回假或真 .registers 7 //寄存器数量 .line 33 //代码所在的行数 iget p0, p0, Lkotlin/jvm/internal/Ref$IntRef;-\u0026gt;element:I //读取p0(第一个参数，参考寄存器知识)中element的值赋值给p0 const/4 p5, 0x1 //p5赋值1 const/16 v0, 0xa //v0赋值10，在16进制里a表示10 if-ge p0, v0, :cond_15 //判断p0的值是否大于或等于v0的值(即p0的值是否大于或等于10)，如果大于或等于则跳转到:cond_15 .line 34 //以下是常见的Toast弹窗代码 check-cast p1, Landroid/content/Context; //检查Context对象引用 const-string p0, \u0026#34;请先获取10个硬币哦\u0026#34; //弹窗文本信息，把\u0026#34;\u0026#34;里的字符串数据赋值给p0 check-cast p0, Ljava/lang/CharSequence; //检查CharSequence对象引用 invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; //将弹窗文本、显示时间等信息传给p1 move-result-object p0 //结果传递给p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V //当看到这个Toast;-\u0026gt;show你就应该反应过来这里是弹窗代码 goto :goto_31 //跳转到:goto_31 :cond_15 //跳转的一个地址 invoke-virtual {p1}, Lcom/zj/wuaipojie/ui/ChallengeSecond;-\u0026gt;isvip()Z //判断isvip方法的返回值是否为真(即结果是否为1) move-result p0 //结果赋值给p0 if-eqz p0, :cond_43 //如果结果为0则跳转cond_43地址 const p0, 0x7f0d0018 //在arsc中的id索引，这个值可以进行查询 .line 37 invoke-virtual {p2, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V //设置图片资源 const p0, 0x7f0d0008 .line 38 invoke-virtual {p3, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V const p0, 0x7f0d000a .line 39 invoke-virtual {p4, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V .line 40 sget-object p0, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/SPUtils; check-cast p1, Landroid/content/Context; const/4 p2, 0x2 //p2赋值2 const-string p3, \u0026#34;level\u0026#34; //sp的索引 invoke-virtual {p0, p1, p3, p2}, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;saveInt(Landroid/content/Context;Ljava/lang/String;I)V //写入数据 goto :goto_50 //跳转地址 :cond_43 check-cast p1, Landroid/content/Context; const-string p0, \u0026#34;\\u8bf7\\u5148\\u5145\\u503c\\u5927\\u4f1a\\u5458\\u54e6\\uff01\u0026#34; //请先充值大会员哦！ check-cast p0, Ljava/lang/CharSequence; invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V :goto_50 return p5 //返回p5的值 .end method //方法结束 //判断是否是大会员的方法 .method public final isvip()Z .registers 2 const/4 v0, 0x0 //v0赋值0 return v0 //返回v0的值 .end method 寄存器机制 命名规则：v0-vN 本地寄存器，p0-pN 参数寄存器 关键特性： 非静态方法中 p0 固定表示this指针 静态方法中 p0 对应第一个参数 64位类型(long/double)占用两个连续寄存器（如v0-v1） 这里可以切换成Smali语言（但是java代码更好看一点）\n0x02 activity的切换 组件 描述 Activity(活动) 在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。 Service(服务) Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。 Broadcast Receiver(广播接收器) 一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。 Content Provider(内容提供者) 作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等） 广告拦截实战 启动广告流程： 启动Activity-\u0026gt;广告Activity-\u0026gt;主页Activity\n修改方法：\n1.修改加载时间\n此小节中用到了mt管理器的Activity管理器，可以用于记录广告用到的AdActivity类 然后通过类名搜索可以定位到代码位置\n转换成java 阅读java代码，然后可以知道有一个3000毫秒广告显示时间，退回到smali代码中修改为零即可。\n2.Acitivity切换定位，修改Intent的Activity类名（直接在AndroidManifest.xml文件中修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 \u0026lt;activity\u0026gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----\u0026gt; \u0026lt;activity android:label=\u0026#34;@string/app_name\u0026#34; android:name=\u0026#34;com.zj.wuaipojie.ui.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动--\u0026gt; \u0026lt;!---指明这个activity可以以什么样的意图(intent)启动---\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFirst\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFifth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFourth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeThird\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeSecond\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.AdActivity\u0026#34; /\u0026gt; ​\n3.在classes.dex文件中查找并修改\n图一为之前的查找内容，图二是类的一个smali路径代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 switch (position) { case 0: Intent intent = new Intent(); intent.setClass(it.getContext(), ChallengeFirst.class); it.getContext().startActivity(intent); return; case 1: Intent intent2 = new Intent(); intent2.setClass(it.getContext(), ChallengeSecond.class); it.getContext().startActivity(intent2); return; case 2: Intent intent3 = new Intent(); //new一个Intent， intent3.setClass(it.getContext(), AdActivity.class); //传入要切换的Acitivity的类名 it.getContext().startActivity(intent3); //启动对应的Activity return; case 3: Intent intent4 = new Intent(); intent4.setClass(it.getContext(), ChallengeFourth.class); it.getContext().startActivity(intent4); return; default: return; } 0x03 Activity生命周期 函数名称 描述 onCreate() 一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。 onStart() 当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。 onResume() 这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。 onPause() 这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。 onStop() 这个方法是在Activity完全不可见的时候调用的。 onDestroy() 这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。 onRestart() 当Activity从停止stop状态恢进入start状态时调用状态。 0x04 弹窗定位\u0026amp;堆栈分析 修改方法： 1.修改xml中的versioncode 2.Hook弹窗(推荐算法助手开启弹窗定位) 这里demo中的广告返回键被劫持，只能跟着广告走，就需要hook\n3.修改dex弹窗代码 在算法助手里找到最新的日志，找到对应打方法名，然后搜索查找对应-\u0026gt;show()代码，删掉或者注释掉就行\n4.抓包修改响应体(也可以路由器拦截) 0x05 布局优化 1.开发者助手抓布局 2.MT管理器xml搜索定位 3.修改xml代码 用的软件：开发助手（可以识别到图片信息），通过搜索Veiw id（hex），可以查找到对应的xml文件，注意这里是xml文件不是之前的dex文件里搜索。 此处既可以修改图片显示的长宽，也可以通过加入下面这段代码隐藏（布局隐藏，文字图片都可以隐藏）。\n1 android:visibility=\u0026#34;gone\u0026#34; ","date":"2025-06-01T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250601010933131.png","permalink":"https://fanshanng.github.io/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%BA%8C/","title":"安卓逆向入门二"},{"content":"热身题 re1 flag{1c98572d-7f7b-4fbf-8750-4a2986c695ce}\n注意到如下代码是关键：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 v29 = *(_WORD *)v16; v30 = sub_7FF7D5E81800(v4, 1i64); if ( !v30 ) sub_7FF7D5E9AFA0(1i64, v4); v31 = (_BYTE *)v30; for ( i = 0i64; i != v4; ++i ) { HIWORD(v33) = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1); LOWORD(v33) = v29; v29 = v33 \u0026gt;\u0026gt; 1; v34 = __ROL1__(v33, 4); v35 = (4 * (v34 \u0026amp; 0x33)) | (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33; v31[i] = *(_BYTE *)(v16 + i) ^ (i + ((2 * (v35 \u0026amp; 0x55)) | (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)); } if ( v4 == 42 \u0026amp;\u0026amp; !memcmp(v31, \u0026amp;unk_7FF7D5E9C458, 42ui64) ) { sub_7FF7D5E817E0(v31, 42i64, 1i64); v39 = \u0026amp;off_7FF7D5E9C4A0; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } else { sub_7FF7D5E817E0(v31, v4, 1i64); v39 = (void **)\u0026amp;off_7FF7D5E9C488; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } 其实就是对输入做了xor，用的序列也是由输入的前两个字节+下标生成，那么z3就是一个很自然的想法。偷懒用AI写的代码。注意需要限制开头字符是flag才能解出唯一解，或者用cfbb的这个办法获取所有解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from z3 import * def rol1_byte(value: int, shift: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Rotate left 1 byte (8 bits) with carry-over\u0026#34;\u0026#34;\u0026#34; shift %= 8 return ((value \u0026lt;\u0026lt; shift) | (value \u0026gt;\u0026gt; (8 - shift))) \u0026amp; 0xFF def transform_data(input_data: bytes) -\u0026gt; bytearray: \u0026#34;\u0026#34;\u0026#34; Replicates the transformation logic from the original code: - Processes each byte with a custom bit manipulation algorithm - Uses a rolling state (v29) that affects subsequent bytes - Applies XOR with transformed index values \u0026#34;\u0026#34;\u0026#34; n = len(input_data) output = bytearray(n) v29 = (input_data[1] \u0026lt;\u0026lt; 8) | input_data[0] for i in range(n): # HIWORD/LOWORD simulation (assuming v33 is 32-bit) hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = (hiword \u0026lt;\u0026lt; 16) | (loword \u0026amp; 0xFFFF) v29 = v33 \u0026gt;\u0026gt; 1 # Bit manipulation steps v34 = rol1_byte(v33 \u0026amp; 0xFF, 4) # __ROL1__(v33, 4) v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # Final XOR operation transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) output[i] = input_data[i] ^ (transformed_index \u0026amp; 0xFF) return output # 目标密文 Buf2 = bytes([ 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B ]) # 创建 Z3 求解器 solver = Solver() # 定义输入变量（每个字节是一个 8 位无符号整数） input_bytes = [BitVec(f\u0026#39;byte_{i}\u0026#39;, 8) for i in range(len(Buf2))] # 初始化状态变量 v29 (32-bit) #v29 = BitVecVal(0, 32) v29 = Concat(input_bytes[1], input_bytes[0]) for i in range(len(Buf2)): # HIWORD/LOWORD 计算 hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = Concat(Extract(15, 0, hiword), Extract(15, 0, loword)) # 更新 v29 v29 = v33 \u0026gt;\u0026gt; 1 # ROL1(v33, 4) - 取最低字节并循环左移4位 v34_lowbyte = Extract(7, 0, v33) v34 = RotateLeft(v34_lowbyte, 4) # v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # 修正后的计算方式： part1 = (v34 \u0026amp; 0x33) \u0026lt;\u0026lt; 2 part2 = (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33 v35 = part1 | part2 # transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) part_a = (v35 \u0026amp; 0x55) \u0026lt;\u0026lt; 1 part_b = (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55 transformed_index = i + (part_a | part_b) # 添加约束：input_byte ^ (transformed_index的低8位) == cipher_byte solver.add(input_bytes[i] ^ Extract(7, 0, transformed_index) == Buf2[i]) # 检查是否有解 solver.add(input_bytes[0] == ord(\u0026#39;f\u0026#39;)) solver.add(input_bytes[1] == ord(\u0026#39;l\u0026#39;)) solver.add(input_bytes[2] == ord(\u0026#39;a\u0026#39;)) solver.add(input_bytes[3] == ord(\u0026#39;g\u0026#39;)) def get_models(s, count = 1): result = [] while len(result) \u0026lt; count and s.check() == sat: m = s.model() sol = bytes([m[input_bytes[i]].as_long() for i in range(len(Buf2))]) result.append(sol) # Create a new constraint the blocks the current model block = [] for d in m: # d is a declaration if d.arity() \u0026gt; 0: raise Z3Exception(\u0026#34;uninterpreted functions are not supported\u0026#34;) # create a constant from declaration c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception(\u0026#34;arrays and uninterpreted sorts are not supported\u0026#34;) block.append(c != m[d]) s.add(Or(block)) return result m = get_models(solver, 1000) print(m) 补一个c语言脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { unsigned char output[42] = { 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B }; unsigned char input[42] = { 0 }; input[0] = \u0026#39;f\u0026#39;; input[1] = \u0026#39;l\u0026#39;; uint16_t v29 = (input[1] \u0026lt;\u0026lt; 8) | input[0]; for (int i = 0; i \u0026lt; 42; ++i) { uint32_t v33= (((v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1)) \u0026lt;\u0026lt; 16) | v29; v29 = (v33 \u0026gt;\u0026gt; 1) \u0026amp; 0xFFFF; uint8_t v34 = ((v33 \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | ((v33 \u0026amp; 0xFF) \u0026gt;\u0026gt; 4); // 循环左移4位 uint8_t v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33); uint8_t combined = (2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55); uint8_t index = (i + combined) \u0026amp; 0xFF; input[i] = output[i] ^ index; } for (int i = 0; i \u0026lt; 42; ++i) { printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } re2 flag{cdb0444318e24beb8f374e9181599072}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { uint8_t v8[16] = { 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 }; uint8_t v9[16] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10 }; const char* target = \u0026#34;cge87k?9\u0026lt;\u0026gt;?@=pss393=\u0026gt;;8@:Cp@DAuH\u0026#34;; uint8_t enc[32]; memcpy(enc, target, 32); uint8_t flag[33]; for (int i = 0; i \u0026lt; 32; i += 16) { // 先减去v9[j] for (int j = 0; j \u0026lt; 16; j++) { flag[i + j] = enc[i + j] - v9[j]; } // 反转块以实现逆置换 for (int j = 0; j \u0026lt; 8; j++) { int pos1 = i + j; int pos2 = i + 15 - j; uint8_t temp = flag[pos1]; flag[pos1] = flag[pos2]; flag[pos2] = temp; } } flag[32] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;flag{%s}\\n\u0026#34;, flag); return 0; } //flag{cdb0444318e24beb8f374e9181599072} 很简单的一道题，唯一就是涉及到一定的sse语句\n","date":"2025-05-30T23:34:46+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/a0457db2a018c2ee683618e3e5a3b90e_720.jpg","permalink":"https://fanshanng.github.io/p/%E4%BA%AC%E9%BA%92ctf-2025%E5%A4%8D%E7%9B%98%E4%B8%AD/","title":"京麒ctf 2025（复盘中）"},{"content":"hook随记 此文目前为摘录他人\nhook（钩子）是一种编程机制，在操作系统、编程里也会用到。\nhook的作用是让程序能够在特定事件发生时插入自定义代码，或者对系统行为进行拦截和修改。它是一种软件设计模式，借助预留接口，实现对系统或框架原有流程的扩展与增强。\nJava中有一种机制，叫做动态代理（Dynamic Proxy），它可以被视为一种特殊的运行时钩子（Runtime Hook），因为它允许你在不修改原有代码的情况下，拦截并增强对象方法的调用。\n在编程中，Hook（钩子）的本质是一种 “程序拦截机制”，它允许你在不修改原始代码的前提下，介入并改变程序的执行流程。这种机制通过注入自定义逻辑到现有系统的特定点来实现增强或修改功能的目的。\n以JavaScript为例， 源代码\n1 2 3 4 5 6 function add(a,b){ return a + b } res = add(1,3) console.log(\u0026#34;结果: \u0026#34; + res) 结果显而易见，是4.\n但是，我们想在不改变调用的情况下，在执行add方法时，在其前面打印”add方法执行“，结束时打印”add方法结束“，并让返回的结果+1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function add(a, b) { return a + b; } const hook = { originalAdd: add // 立即保存引用 }; // 重新定义add函数 add = function(a, b) { console.log(\u0026#34;add方法调用前\u0026#34;); let res = hook.originalAdd(a, b); console.log(\u0026#34;add方法调用后\u0026#34;); return res + 1; }; let res = add(1, 3); console.log(\u0026#34;结果: \u0026#34; + res); // 输出5 结果如图：\n调用的代码并未变化，但是结果发声改变了。 上述的案例就是一个hook的过程。 它先将原函数对象的引用（即内存地址）保存起来，然后在新函数中调用原add函数，最后令add指向一个新函数。\n","date":"2025-05-30T10:26:28+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/1.jpg","permalink":"https://fanshanng.github.io/p/hook/","title":"Hook"},{"content":"安卓逆向入门一 0x01 前置 下载migisk\nMagisk（俗称面具），是一个ROOT工具。\n它提供了多种功能，包括但不限于： 1 2 3 4 MagiskSU: 提供应用程序的 root 访问权限。 Magisk 模块: 通过安装模块来修改只读分区。 MagiskBoot: 用于解包和重新打包 Android 启动镜像的最完整工具。 Zygisk: 在每个 Android 应用程序的进程中运行代码。 不要去Magisk中文网,这里用的是正己提供的安装包\n这里如果下载失败的话，可以去设置里修改下图选项\n0x02 apk的文件结构 Apk结构 apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。\n文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidManifest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 demo实例中另外出现的kotlin代表这个apk文件大概是有kotlin语言编写，OkHttp 是一个流行的开源 HTTP 客户端库，用于发送和接收网络请求。 Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。\nKotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\n在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。\n0x03 双开及原理 指手机同时运行两个或多个相同的应用\n【VirtualAPP 双开系列08】如何实现多开 - UID\n通过在宿主容器上面新建一个进程供插件 APK 寄宿，然后通过 hook 一些系统接口欺骗应用—让虚拟化后应用以为自己是正常运行的独立 APP，欺骗系统—让系统认为此虚拟化应用是一个已正常安装在系统的应用。\n原理 解释 修改包名 让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 修改Framework 对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 通过虚拟化技术实现 虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 以插件机制运行 利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 0x04 汉化APK 1.Arsc汉化\n2.xml汉化\n3.Dex汉化 (教程里的汉化插件需要vip，我这里是手动改的，知道原理就行)\n教程中用到的主要就是在mt管理器或者np管理器中对文件进行字符串搜索（管理器中设置了自动签名），如果手动的话，可以反编译改源码等 apk安装包快速反编译，多种反编译及失败的解决方案\n这是汉化前⬇\n这是汉化（手改）后⬇\n0x05 初识AndroidManifest.xml AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。\n注：这里文件名不能修改\nAndroidManifest.xml 最全详解 AndroidManifest.xml文件主要包含以下几个元素：\n元素 功能描述 action 添加一个action到intent filter activity 声明 activity组件 activity-alias 声明activity别名 application 声明应用程序 category 添加一个category名称到intent filter compatible-screens 定义应用所兼容的每种屏幕配置 data 添加数据定义到intent filter grant-uri-permission 定义应用数据的子集以供父内容提供者有权限可以访问 instrumentation 声明Instrumentation工具类并是您可以监控应用程序的交互系统 intent-filter 定义activity、service或者是broadcast receiver可以响应的意图（intent）类型， manifest AndroidManifest.xml文件中的根元素 meta-data 一条额外添加的名称-值对，可以给父组件提供任意的数据。 path-permission 在content provider内定义所需路径和权限特定子集数据 permission 声明一个安全权限，可以用来限制访问特定应用的组件或功能 permission-group 声明一个相关权限的逻辑组名称 permission-tree 声明权限树的基础名称 provider 声明一个内容提供者(content provider)组件 receiver 声明一个广播接收器(broadcast receiver)组件 service 声明一个服务(service)组件 supports-gl-texture 声明一种应用单一支持的GL纹理(texture)压缩格式 supports-screens 声明应用所支持的屏幕尺寸大小以及在启用兼容模式下系统屏幕超出应用所支持的尺寸 uses-configuration 声明应用程序的软硬件需求 uses-feature 声明应用程序需要用到的软、硬件特性。 uses-library 指定应用程序必须引用的共享库 uses-permission 指定了让应用程序正常运行，用户必须授予的系统权限。 uses-permission-sdk-23 指定了应用程序在Android 6.0以上所需的特定权限 uses-sdk 通过API整数值来声明应用程序所兼容的Android平台版 MT管理器使用手册\nAndroid逆向0基础入门-APK全面解析,动调与脱壳\n","date":"2025-05-25T16:15:22+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/preview.jpg","permalink":"https://fanshanng.github.io/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"安卓逆向学习一"},{"content":"并非是wp，而是做题过程中的一些记录\nluck_guy 主函数 ①.Case2 和 case3 只是一个打印函数。 ②.strcat 是连接字符串函数，所以 case4 是对 s 赋值并将 s 与 f2 进行拼接。 ③.case5 是对 f2 进行处理：j 为奇数，f2 减 2；j 为偶数，f2 减 1。 ④.Case1 是要得到 flag，首先memset函数先对 s 进行初始化，s 变成了一个空数组，所以之后的 strcat 函数相当于直接把 f1 复制到了 s 里，再之后的 strcat 函数将 s 与 f2 连接相当于 f1 与 f2 连接，最终打印出来的 flag 就是 f1 加上 f2。 s=0x7F666F6067756369LL，按r键将它转换为字符就是“\\x7Ffo`guci”，这里要注意是小端序存储！所以要把字符顺序反过来，就是“icug`of\\x7F” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char f2[] = \u0026#34;icug`of\\x7F\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j) { if ( j % 2 == 1 ) f2[j]-=2; else f2[j]--; } printf(\u0026#34;%s\u0026#34;,f2); return 0; } 刮开有奖 加密逻辑其实挺清晰的一道题，快速排序+base64编码，快速排序这里不懂的话可以去问ai，不过还是要自己判断，也可以把代码复制下来在vscode中运行一遍看看结果 但是第一次疑惑的地方是加密排序那个数组a1只初始化了两个数，但是它的结束索引却是十。这里学到的知识是：\n根据这段初始化，知道这段的地址是连续的。所以实际上是一个长度为11的数组，别问我为什么不动调，F9点开后调不了一点 然后就是\n对比判断的时候这里用的是地址处的值也就是说是排序后的值\n然后要提一嘴的是\n具体可以去看这里 WinMain函数 （winbase.h） WinMain 函数（Windows图形应用程序入口点）\n1 2 3 4 5 6 int __clrcall WinMain( [in] HINSTANCE hInstance, [in, optional] HINSTANCE hPrevInstance, [in] LPSTR lpCmdLine, [in] int nShowCmd ); 参数： hInstance：当前应用程序实例的句柄。 hPrevInstance：上一个实例的句柄（在现代Windows中始终为NULL）。 lpCmdLine：命令行参数，不包括程序名称。 nShowCmd：控制窗口显示方式的标志。 返回值：程序的退出状态码，通常返回 WM_QUIT 消息的 wParam 参数值。\neasyre 脱壳后的主函数 分析比较语句，大致猜到v5就是输入的函数，这里的意思是输入字符的ascii值+1后作为索引进行判断\npython中的find()函数是找到对应的下标值 1 2 3 4 5 6 7 8 9 10 11 12 U U9 U9X U9X_ U9X_1 U9X_1S U9X_1S_ U9X_1S_W U9X_1S_W6 U9X_1S_W6@ U9X_1S_W6@T U9X_1S_W6@T? [GUET-CTF2019]re 考z3处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from z3 import * solver = Solver() # 使用Int类型而非BitVec，并添加字符范围约束 a1 = [Int(f\u0026#39;a1_{i}\u0026#39;) for i in range(32)] # 添加所有等式约束 solver.add(1629056 * a1[0] == 166163712) solver.add(6771600 * a1[1] == 731332800) solver.add(3682944 * a1[2] == 357245568) solver.add(10431000 * a1[3] == 1074393000) solver.add(3977328 * a1[4] == 489211344) solver.add(5138336 * a1[5] == 518971936) solver.add(7532250 * a1[7] == 406741500) solver.add(5551632 * a1[8] == 294236496) solver.add(3409728 * a1[9] == 177305856) solver.add(13013670 * a1[10] == 650683500) solver.add(6088797 * a1[11] == 298351053) solver.add(7884663 * a1[12] == 386348487) solver.add(8944053 * a1[13] == 438258597) solver.add(5198490 * a1[14] == 249527520) solver.add(4544518 * a1[15] == 445362764) solver.add(3645600 * a1[17] == 174988800) solver.add(10115280 * a1[16] == 981182160) solver.add(9667504 * a1[18] == 493042704) solver.add(5364450 * a1[19] == 257493600) solver.add(13464540 * a1[20] == 767478780) solver.add(5488432 * a1[21] == 312840624) solver.add(14479500 * a1[22] == 1404511500) solver.add(6451830 * a1[23] == 316139670) solver.add(6252576 * a1[24] == 619005024) solver.add(7763364 * a1[25] == 372641472) solver.add(7327320 * a1[26] == 373693320) solver.add(8741520 * a1[27] == 498266640) solver.add(8871876 * a1[28] == 452465676) solver.add(4086720 * a1[29] == 208422720) solver.add(9374400 * a1[30] == 515592000) solver.add(5759124 * a1[31] == 719890500) # 确保每个字符在0-255范围内（ASCII） for c in a1: solver.add(c \u0026gt;= 0, c \u0026lt;= 255) if solver.check() == sat: model = solver.model() flag = \u0026#39;\u0026#39;.join([chr(model[c].as_long()) for c in a1]) # type: ignore print(\u0026#34;\u0026#34;, flag) else: print(\u0026#34;无解\u0026#34;) # flag{e65421110ba03099a1c039337} 但是疑惑的是少了一位，最后看别人题解都是爆破出来的（，a1[6]=\u0026lsquo;1\u0026rsquo;, 所以正确的应该是flag{e165421110ba03099a1c039337}\nCrackRTF 这道题的考点是rtf文件,主要的逻辑是先输入六个数字拼接@DBApp然后判断hash-sha1编码，这里爆破出的结果是123321，然后是长度为6的字符串，拼接在一起进行MD5编码，由于MD5编码不可逆，我尝试过爆破，生成所有 6 位组合，总数为 95^6 ≈ 735 亿次，遂放弃。\nRTF是Rich Text Format的缩写，意即多文本格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 char __cdecl sub_4014D0(LPCSTR Destination) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026#34;AAA\u0026#34;);// FindResourceA 函数用于查找程序资源中的一个资源。 // 第一个参数为 NULL，表示查找当前进程的资源。 // 第二个参数为资源标识符，这里是 0x65。 // 第三个参数为资源类型，这里是 \u0026#34;AAA\u0026#34;。 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo);// SizeofResource 函数用于获取资源的大小。 // 如果资源大小为 0，表示资源无效。 hResData = LoadResource(0, hResInfo); // LoadResource 函数用于加载资源。 if ( !hResData ) return 0; lpBuffer = LockResource(hResData); // LockResource 函数用于锁定资源，并返回资源的指针。 sub_401005(Destination, (int)lpBuffer, nNumberOfBytesToWrite);// 异或 hFile = CreateFileA(\u0026#34;dbapp.rtf\u0026#34;, GENERIC_ALL, 0, 0, CREATE_ALWAYS, FILE_READ_ATTRIBUTES, 0);// CreateFileA 函数用于创建或打开一个文件。 // 文件名为 \u0026#34;dbapp.rtf\u0026#34;。 // 打开模式为 CREATE_ALWAYS，表示如果文件不存在则创建，如果存在则覆盖。 // 文件访问权限为 GENERIC_ALL，表示完全访问权限。 if ( hFile == (HANDLE)-1 ) // 如果文件创建失败，返回 0。 return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); // 关闭文件句柄。 return 1; } 这里就是我们输入的东西拼接后与“AAA”文件中的读取的前几位异或\n从网上找到rtf的示例文件下下来对比发现前几位都是一样的\n把前几位截下来，然后进行异或处理就能得到前六位~!3a@0123321,很明显**~!3a@0**为所求。于是在ida中动调，生成rtf文件，打开后得到flag ","date":"2025-05-22T21:08:17+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/2.jpg","permalink":"https://fanshanng.github.io/p/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Buuctf刷题记录"},{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-19T00:15:39+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/3.png","permalink":"https://fanshanng.github.io/p/frida/","title":"Frida"}]