[{"content":"re1 | Done | Working: sandtea, fanshang flag{1c98572d-7f7b-4fbf-8750-4a2986c695ce}\n注意到如下代码是关键：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 v29 = *(_WORD *)v16; v30 = sub_7FF7D5E81800(v4, 1i64); if ( !v30 ) sub_7FF7D5E9AFA0(1i64, v4); v31 = (_BYTE *)v30; for ( i = 0i64; i != v4; ++i ) { HIWORD(v33) = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1); LOWORD(v33) = v29; v29 = v33 \u0026gt;\u0026gt; 1; v34 = __ROL1__(v33, 4); v35 = (4 * (v34 \u0026amp; 0x33)) | (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33; v31[i] = *(_BYTE *)(v16 + i) ^ (i + ((2 * (v35 \u0026amp; 0x55)) | (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)); } if ( v4 == 42 \u0026amp;\u0026amp; !memcmp(v31, \u0026amp;unk_7FF7D5E9C458, 42ui64) ) { sub_7FF7D5E817E0(v31, 42i64, 1i64); v39 = \u0026amp;off_7FF7D5E9C4A0; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } else { sub_7FF7D5E817E0(v31, v4, 1i64); v39 = (void **)\u0026amp;off_7FF7D5E9C488; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } 其实就是对输入做了xor，用的序列也是由输入的前两个字节+下标生成，那么z3就是一个很自然的想法。偷懒用AI写的代码。注意需要限制开头字符是flag才能解出唯一解，或者用cfbb的这个办法获取所有解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from z3 import * def rol1_byte(value: int, shift: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Rotate left 1 byte (8 bits) with carry-over\u0026#34;\u0026#34;\u0026#34; shift %= 8 return ((value \u0026lt;\u0026lt; shift) | (value \u0026gt;\u0026gt; (8 - shift))) \u0026amp; 0xFF def transform_data(input_data: bytes) -\u0026gt; bytearray: \u0026#34;\u0026#34;\u0026#34; Replicates the transformation logic from the original code: - Processes each byte with a custom bit manipulation algorithm - Uses a rolling state (v29) that affects subsequent bytes - Applies XOR with transformed index values \u0026#34;\u0026#34;\u0026#34; n = len(input_data) output = bytearray(n) v29 = (input_data[1] \u0026lt;\u0026lt; 8) | input_data[0] for i in range(n): # HIWORD/LOWORD simulation (assuming v33 is 32-bit) hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = (hiword \u0026lt;\u0026lt; 16) | (loword \u0026amp; 0xFFFF) v29 = v33 \u0026gt;\u0026gt; 1 # Bit manipulation steps v34 = rol1_byte(v33 \u0026amp; 0xFF, 4) # __ROL1__(v33, 4) v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # Final XOR operation transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) output[i] = input_data[i] ^ (transformed_index \u0026amp; 0xFF) return output # 目标密文 Buf2 = bytes([ 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B ]) # 创建 Z3 求解器 solver = Solver() # 定义输入变量（每个字节是一个 8 位无符号整数） input_bytes = [BitVec(f\u0026#39;byte_{i}\u0026#39;, 8) for i in range(len(Buf2))] # 初始化状态变量 v29 (32-bit) #v29 = BitVecVal(0, 32) v29 = Concat(input_bytes[1], input_bytes[0]) for i in range(len(Buf2)): # HIWORD/LOWORD 计算 hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = Concat(Extract(15, 0, hiword), Extract(15, 0, loword)) # 更新 v29 v29 = v33 \u0026gt;\u0026gt; 1 # ROL1(v33, 4) - 取最低字节并循环左移4位 v34_lowbyte = Extract(7, 0, v33) v34 = RotateLeft(v34_lowbyte, 4) # v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # 修正后的计算方式： part1 = (v34 \u0026amp; 0x33) \u0026lt;\u0026lt; 2 part2 = (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33 v35 = part1 | part2 # transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) part_a = (v35 \u0026amp; 0x55) \u0026lt;\u0026lt; 1 part_b = (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55 transformed_index = i + (part_a | part_b) # 添加约束：input_byte ^ (transformed_index的低8位) == cipher_byte solver.add(input_bytes[i] ^ Extract(7, 0, transformed_index) == Buf2[i]) # 检查是否有解 solver.add(input_bytes[0] == ord(\u0026#39;f\u0026#39;)) solver.add(input_bytes[1] == ord(\u0026#39;l\u0026#39;)) solver.add(input_bytes[2] == ord(\u0026#39;a\u0026#39;)) solver.add(input_bytes[3] == ord(\u0026#39;g\u0026#39;)) def get_models(s, count = 1): result = [] while len(result) \u0026lt; count and s.check() == sat: m = s.model() sol = bytes([m[input_bytes[i]].as_long() for i in range(len(Buf2))]) result.append(sol) # Create a new constraint the blocks the current model block = [] for d in m: # d is a declaration if d.arity() \u0026gt; 0: raise Z3Exception(\u0026#34;uninterpreted functions are not supported\u0026#34;) # create a constant from declaration c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception(\u0026#34;arrays and uninterpreted sorts are not supported\u0026#34;) block.append(c != m[d]) s.add(Or(block)) return result m = get_models(solver, 1000) print(m) 补一个c语言脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { unsigned char output[42] = { 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B }; unsigned char input[42] = { 0 }; input[0] = \u0026#39;f\u0026#39;; input[1] = \u0026#39;l\u0026#39;; uint16_t v29 = (input[1] \u0026lt;\u0026lt; 8) | input[0]; for (int i = 0; i \u0026lt; 42; ++i) { uint32_t v33= (((v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1)) \u0026lt;\u0026lt; 16) | v29; v29 = (v33 \u0026gt;\u0026gt; 1) \u0026amp; 0xFFFF; uint8_t v34 = ((v33 \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | ((v33 \u0026amp; 0xFF) \u0026gt;\u0026gt; 4); // 循环左移4位 uint8_t v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33); uint8_t combined = (2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55); uint8_t index = (i + combined) \u0026amp; 0xFF; input[i] = output[i] ^ index; } for (int i = 0; i \u0026lt; 42; ++i) { printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } re2 | Done | Working: fanshang flag{cdb0444318e24beb8f374e9181599072}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { uint8_t v8[16] = { 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 }; uint8_t v9[16] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10 }; const char* target = \u0026#34;cge87k?9\u0026lt;\u0026gt;?@=pss393=\u0026gt;;8@:Cp@DAuH\u0026#34;; uint8_t enc[32]; memcpy(enc, target, 32); uint8_t flag[33]; for (int i = 0; i \u0026lt; 32; i += 16) { // 先减去v9[j] for (int j = 0; j \u0026lt; 16; j++) { flag[i + j] = enc[i + j] - v9[j]; } // 反转块以实现逆置换 for (int j = 0; j \u0026lt; 8; j++) { int pos1 = i + j; int pos2 = i + 15 - j; uint8_t temp = flag[pos1]; flag[pos1] = flag[pos2]; flag[pos2] = temp; } } flag[32] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;flag{%s}\\n\u0026#34;, flag); return 0; } //flag{cdb0444318e24beb8f374e9181599072} 很简单的一道题，唯一就是涉及到一定的sse语句\n","date":"2025-05-30T23:34:46+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/a0457db2a018c2ee683618e3e5a3b90e_720.jpg","permalink":"https://fanshanng.github.io/p/%E4%BA%AC%E9%BA%92ctf-2025/","title":"京麒ctf 2025"},{"content":"hook随记 此文目前为摘录他人\nhook（钩子）是一种编程机制，在操作系统、编程里也会用到。\nhook的作用是让程序能够在特定事件发生时插入自定义代码，或者对系统行为进行拦截和修改。它是一种软件设计模式，借助预留接口，实现对系统或框架原有流程的扩展与增强。\nJava中有一种机制，叫做动态代理（Dynamic Proxy），它可以被视为一种特殊的运行时钩子（Runtime Hook），因为它允许你在不修改原有代码的情况下，拦截并增强对象方法的调用。\n在编程中，Hook（钩子）的本质是一种 “程序拦截机制”，它允许你在不修改原始代码的前提下，介入并改变程序的执行流程。这种机制通过注入自定义逻辑到现有系统的特定点来实现增强或修改功能的目的。\n以JavaScript为例， 源代码\n1 2 3 4 5 6 function add(a,b){ return a + b } res = add(1,3) console.log(\u0026#34;结果: \u0026#34; + res) 结果显而易见，是4.\n但是，我们想在不改变调用的情况下，在执行add方法时，在其前面打印”add方法执行“，结束时打印”add方法结束“，并让返回的结果+1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function add(a, b) { return a + b; } const hook = { originalAdd: add // 立即保存引用 }; // 重新定义add函数 add = function(a, b) { console.log(\u0026#34;add方法调用前\u0026#34;); let res = hook.originalAdd(a, b); console.log(\u0026#34;add方法调用后\u0026#34;); return res + 1; }; let res = add(1, 3); console.log(\u0026#34;结果: \u0026#34; + res); // 输出5 结果如图：\n调用的代码并未变化，但是结果发声改变了。 上述的案例就是一个hook的过程。 它先将原函数对象的引用（即内存地址）保存起来，然后在新函数中调用原add函数，最后令add指向一个新函数。\n","date":"2025-05-30T10:26:28+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/1.jpg","permalink":"https://fanshanng.github.io/p/hook/","title":"Hook"},{"content":"安卓逆向入门一 0x01 前置 下载migisk\nMagisk（俗称面具），是一个ROOT工具。\n它提供了多种功能，包括但不限于： 1 2 3 4 MagiskSU: 提供应用程序的 root 访问权限。 Magisk 模块: 通过安装模块来修改只读分区。 MagiskBoot: 用于解包和重新打包 Android 启动镜像的最完整工具。 Zygisk: 在每个 Android 应用程序的进程中运行代码。 不要去Magisk中文网,这里用的是正己提供的安装包\n这里如果下载失败的话，可以去设置里修改下图选项\n0x02 apk的文件结构 Apk结构 apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。\n文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidManifest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 demo实例中另外出现的kotlin代表这个apk文件大概是有kotlin语言编写，OkHttp 是一个流行的开源 HTTP 客户端库，用于发送和接收网络请求。 Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。\nKotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\n在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。\n0x03 双开及原理 指手机同时运行两个或多个相同的应用\n【VirtualAPP 双开系列08】如何实现多开 - UID\n通过在宿主容器上面新建一个进程供插件 APK 寄宿，然后通过 hook 一些系统接口欺骗应用—让虚拟化后应用以为自己是正常运行的独立 APP，欺骗系统—让系统认为此虚拟化应用是一个已正常安装在系统的应用。\n原理 解释 修改包名 让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 修改Framework 对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 通过虚拟化技术实现 虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 以插件机制运行 利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 0x04 汉化APK 1.Arsc汉化\n2.xml汉化\n3.Dex汉化 (教程里的汉化插件需要vip，我这里是手动改的，知道原理就行)\n教程中用到的主要就是在mt管理器或者np管理器中对文件进行字符串搜索（管理器中设置了自动签名），如果手动的话，可以反编译改源码等 apk安装包快速反编译，多种反编译及失败的解决方案\n这是汉化前⬇\n这是汉化（手改）后⬇\n0x05 初识AndroidManifest.xml AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。\n注：这里文件名不能修改\nAndroidManifest.xml 最全详解 AndroidManifest.xml文件主要包含以下几个元素：\n元素 功能描述 action 添加一个action到intent filter activity 声明 activity组件 activity-alias 声明activity别名 application 声明应用程序 category 添加一个category名称到intent filter compatible-screens 定义应用所兼容的每种屏幕配置 data 添加数据定义到intent filter grant-uri-permission 定义应用数据的子集以供父内容提供者有权限可以访问 instrumentation 声明Instrumentation工具类并是您可以监控应用程序的交互系统 intent-filter 定义activity、service或者是broadcast receiver可以响应的意图（intent）类型， manifest AndroidManifest.xml文件中的根元素 meta-data 一条额外添加的名称-值对，可以给父组件提供任意的数据。 path-permission 在content provider内定义所需路径和权限特定子集数据 permission 声明一个安全权限，可以用来限制访问特定应用的组件或功能 permission-group 声明一个相关权限的逻辑组名称 permission-tree 声明权限树的基础名称 provider 声明一个内容提供者(content provider)组件 receiver 声明一个广播接收器(broadcast receiver)组件 service 声明一个服务(service)组件 supports-gl-texture 声明一种应用单一支持的GL纹理(texture)压缩格式 supports-screens 声明应用所支持的屏幕尺寸大小以及在启用兼容模式下系统屏幕超出应用所支持的尺寸 uses-configuration 声明应用程序的软硬件需求 uses-feature 声明应用程序需要用到的软、硬件特性。 uses-library 指定应用程序必须引用的共享库 uses-permission 指定了让应用程序正常运行，用户必须授予的系统权限。 uses-permission-sdk-23 指定了应用程序在Android 6.0以上所需的特定权限 uses-sdk 通过API整数值来声明应用程序所兼容的Android平台版 MT管理器使用手册\nAndroid逆向0基础入门-APK全面解析,动调与脱壳\n","date":"2025-05-25T16:15:22+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/preview.jpg","permalink":"https://fanshanng.github.io/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"安卓逆向学习一"},{"content":"并非是wp，而是做题过程中的一些记录\nluck_guy 主函数 ①.Case2 和 case3 只是一个打印函数。 ②.strcat 是连接字符串函数，所以 case4 是对 s 赋值并将 s 与 f2 进行拼接。 ③.case5 是对 f2 进行处理：j 为奇数，f2 减 2；j 为偶数，f2 减 1。 ④.Case1 是要得到 flag，首先memset函数先对 s 进行初始化，s 变成了一个空数组，所以之后的 strcat 函数相当于直接把 f1 复制到了 s 里，再之后的 strcat 函数将 s 与 f2 连接相当于 f1 与 f2 连接，最终打印出来的 flag 就是 f1 加上 f2。 s=0x7F666F6067756369LL，按r键将它转换为字符就是“\\x7Ffo`guci”，这里要注意是小端序存储！所以要把字符顺序反过来，就是“icug`of\\x7F” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char f2[] = \u0026#34;icug`of\\x7F\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j) { if ( j % 2 == 1 ) f2[j]-=2; else f2[j]--; } printf(\u0026#34;%s\u0026#34;,f2); return 0; } 刮开有奖 加密逻辑其实挺清晰的一道题，快速排序+base64编码，快速排序这里不懂的话可以去问ai，不过还是要自己判断，也可以把代码复制下来在vscode中运行一遍看看结果 但是第一次疑惑的地方是加密排序那个数组a1只初始化了两个数，但是它的结束索引却是十。这里学到的知识是：\n根据这段初始化，知道这段的地址是连续的。所以实际上是一个长度为11的数组，别问我为什么不动调，F9点开后调不了一点 然后就是\n对比判断的时候这里用的是地址处的值也就是说是排序后的值\n然后要提一嘴的是\n具体可以去看这里 WinMain函数 （winbase.h） WinMain 函数（Windows图形应用程序入口点）\n1 2 3 4 5 6 int __clrcall WinMain( [in] HINSTANCE hInstance, [in, optional] HINSTANCE hPrevInstance, [in] LPSTR lpCmdLine, [in] int nShowCmd ); 参数： hInstance：当前应用程序实例的句柄。 hPrevInstance：上一个实例的句柄（在现代Windows中始终为NULL）。 lpCmdLine：命令行参数，不包括程序名称。 nShowCmd：控制窗口显示方式的标志。 返回值：程序的退出状态码，通常返回 WM_QUIT 消息的 wParam 参数值。\neasyre 脱壳后的主函数 分析比较语句，大致猜到v5就是输入的函数，这里的意思是输入字符的ascii值+1后作为索引进行判断\npython中的find()函数是找到对应的下标值 1 2 3 4 5 6 7 8 9 10 11 12 U U9 U9X U9X_ U9X_1 U9X_1S U9X_1S_ U9X_1S_W U9X_1S_W6 U9X_1S_W6@ U9X_1S_W6@T U9X_1S_W6@T? [GUET-CTF2019]re 考z3处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from z3 import * solver = Solver() # 使用Int类型而非BitVec，并添加字符范围约束 a1 = [Int(f\u0026#39;a1_{i}\u0026#39;) for i in range(32)] # 添加所有等式约束 solver.add(1629056 * a1[0] == 166163712) solver.add(6771600 * a1[1] == 731332800) solver.add(3682944 * a1[2] == 357245568) solver.add(10431000 * a1[3] == 1074393000) solver.add(3977328 * a1[4] == 489211344) solver.add(5138336 * a1[5] == 518971936) solver.add(7532250 * a1[7] == 406741500) solver.add(5551632 * a1[8] == 294236496) solver.add(3409728 * a1[9] == 177305856) solver.add(13013670 * a1[10] == 650683500) solver.add(6088797 * a1[11] == 298351053) solver.add(7884663 * a1[12] == 386348487) solver.add(8944053 * a1[13] == 438258597) solver.add(5198490 * a1[14] == 249527520) solver.add(4544518 * a1[15] == 445362764) solver.add(3645600 * a1[17] == 174988800) solver.add(10115280 * a1[16] == 981182160) solver.add(9667504 * a1[18] == 493042704) solver.add(5364450 * a1[19] == 257493600) solver.add(13464540 * a1[20] == 767478780) solver.add(5488432 * a1[21] == 312840624) solver.add(14479500 * a1[22] == 1404511500) solver.add(6451830 * a1[23] == 316139670) solver.add(6252576 * a1[24] == 619005024) solver.add(7763364 * a1[25] == 372641472) solver.add(7327320 * a1[26] == 373693320) solver.add(8741520 * a1[27] == 498266640) solver.add(8871876 * a1[28] == 452465676) solver.add(4086720 * a1[29] == 208422720) solver.add(9374400 * a1[30] == 515592000) solver.add(5759124 * a1[31] == 719890500) # 确保每个字符在0-255范围内（ASCII） for c in a1: solver.add(c \u0026gt;= 0, c \u0026lt;= 255) if solver.check() == sat: model = solver.model() flag = \u0026#39;\u0026#39;.join([chr(model[c].as_long()) for c in a1]) # type: ignore print(\u0026#34;\u0026#34;, flag) else: print(\u0026#34;无解\u0026#34;) # flag{e65421110ba03099a1c039337} 但是疑惑的是少了一位，最后看别人题解都是爆破出来的（，a1[6]=\u0026lsquo;1\u0026rsquo;, 所以正确的应该是flag{e165421110ba03099a1c039337}\nCrackRTF 这道题的考点是rtf文件,主要的逻辑是先输入六个数字拼接@DBApp然后判断hash-sha1编码，这里爆破出的结果是123321，然后是长度为6的字符串，拼接在一起进行MD5编码，由于MD5编码不可逆，我尝试过爆破，生成所有 6 位组合，总数为 95^6 ≈ 735 亿次，遂放弃。\nRTF是Rich Text Format的缩写，意即多文本格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 char __cdecl sub_4014D0(LPCSTR Destination) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026#34;AAA\u0026#34;);// FindResourceA 函数用于查找程序资源中的一个资源。 // 第一个参数为 NULL，表示查找当前进程的资源。 // 第二个参数为资源标识符，这里是 0x65。 // 第三个参数为资源类型，这里是 \u0026#34;AAA\u0026#34;。 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo);// SizeofResource 函数用于获取资源的大小。 // 如果资源大小为 0，表示资源无效。 hResData = LoadResource(0, hResInfo); // LoadResource 函数用于加载资源。 if ( !hResData ) return 0; lpBuffer = LockResource(hResData); // LockResource 函数用于锁定资源，并返回资源的指针。 sub_401005(Destination, (int)lpBuffer, nNumberOfBytesToWrite);// 异或 hFile = CreateFileA(\u0026#34;dbapp.rtf\u0026#34;, GENERIC_ALL, 0, 0, CREATE_ALWAYS, FILE_READ_ATTRIBUTES, 0);// CreateFileA 函数用于创建或打开一个文件。 // 文件名为 \u0026#34;dbapp.rtf\u0026#34;。 // 打开模式为 CREATE_ALWAYS，表示如果文件不存在则创建，如果存在则覆盖。 // 文件访问权限为 GENERIC_ALL，表示完全访问权限。 if ( hFile == (HANDLE)-1 ) // 如果文件创建失败，返回 0。 return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); // 关闭文件句柄。 return 1; } 这里就是我们输入的东西拼接后与“AAA”文件中的读取的前几位异或\n从网上找到rtf的示例文件下下来对比发现前几位都是一样的\n把前几位截下来，然后进行异或处理就能得到前六位~!3a@0123321,很明显**~!3a@0**为所求。于是在ida中动调，生成rtf文件，打开后得到flag ","date":"2025-05-22T21:08:17+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/2.jpg","permalink":"https://fanshanng.github.io/p/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Buuctf刷题记录"},{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-19T00:15:39+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/3.png","permalink":"https://fanshanng.github.io/p/frida/","title":"Frida"}]