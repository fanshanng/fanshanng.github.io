[{"content":"并非是wp，而是做题过程中的一些记录\nluck_guy 主函数 ①.Case2 和 case3 只是一个打印函数。 ②.strcat 是连接字符串函数，所以 case4 是对 s 赋值并将 s 与 f2 进行拼接。 ③.case5 是对 f2 进行处理：j 为奇数，f2 减 2；j 为偶数，f2 减 1。 ④.Case1 是要得到 flag，首先memset函数先对 s 进行初始化，s 变成了一个空数组，所以之后的 strcat 函数相当于直接把 f1 复制到了 s 里，再之后的 strcat 函数将 s 与 f2 连接相当于 f1 与 f2 连接，最终打印出来的 flag 就是 f1 加上 f2。 s=0x7F666F6067756369LL，按r键将它转换为字符就是“\\x7Ffo`guci”，这里要注意是小端序存储！所以要把字符顺序反过来，就是“icug`of\\x7F” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char f2[] = \u0026#34;icug`of\\x7F\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j) { if ( j % 2 == 1 ) f2[j]-=2; else f2[j]--; } printf(\u0026#34;%s\u0026#34;,f2); return 0; } 刮开有奖 加密逻辑其实挺清晰的一道题，快速排序+base64编码，快速排序这里不懂的话可以去问ai，不过还是要自己判断，也可以把代码复制下来在vscode中运行一遍看看结果 但是第一次疑惑的地方是加密排序那个数组a1只初始化了两个数，但是它的结束索引却是十。这里学到的知识是：\n根据这段初始化，知道这段的地址是连续的。所以实际上是一个长度为11的数组，别问我为什么不动调，F9点开后调不了一点 然后就是\n对比判断的时候这里用的是地址处的值也就是说是排序后的值\n然后要提一嘴的是\n具体可以去看这里 WinMain函数 （winbase.h） WinMain 函数（Windows图形应用程序入口点）\n1 2 3 4 5 6 int __clrcall WinMain( [in] HINSTANCE hInstance, [in, optional] HINSTANCE hPrevInstance, [in] LPSTR lpCmdLine, [in] int nShowCmd ); 参数： hInstance：当前应用程序实例的句柄。 hPrevInstance：上一个实例的句柄（在现代Windows中始终为NULL）。 lpCmdLine：命令行参数，不包括程序名称。 nShowCmd：控制窗口显示方式的标志。 返回值：程序的退出状态码，通常返回 WM_QUIT 消息的 wParam 参数值。\neasyre 脱壳后的主函数 分析比较语句，大致猜到v5就是输入的函数，这里的意思是输入字符的ascii值+1后作为索引进行判断\npython中的find()函数是找到对应的下标值 1 2 3 4 5 6 7 8 9 10 11 12 U U9 U9X U9X_ U9X_1 U9X_1S U9X_1S_ U9X_1S_W U9X_1S_W6 U9X_1S_W6@ U9X_1S_W6@T U9X_1S_W6@T? [GUET-CTF2019]re 考z3处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from z3 import * solver = Solver() # 使用Int类型而非BitVec，并添加字符范围约束 a1 = [Int(f\u0026#39;a1_{i}\u0026#39;) for i in range(32)] # 添加所有等式约束 solver.add(1629056 * a1[0] == 166163712) solver.add(6771600 * a1[1] == 731332800) solver.add(3682944 * a1[2] == 357245568) solver.add(10431000 * a1[3] == 1074393000) solver.add(3977328 * a1[4] == 489211344) solver.add(5138336 * a1[5] == 518971936) solver.add(7532250 * a1[7] == 406741500) solver.add(5551632 * a1[8] == 294236496) solver.add(3409728 * a1[9] == 177305856) solver.add(13013670 * a1[10] == 650683500) solver.add(6088797 * a1[11] == 298351053) solver.add(7884663 * a1[12] == 386348487) solver.add(8944053 * a1[13] == 438258597) solver.add(5198490 * a1[14] == 249527520) solver.add(4544518 * a1[15] == 445362764) solver.add(3645600 * a1[17] == 174988800) solver.add(10115280 * a1[16] == 981182160) solver.add(9667504 * a1[18] == 493042704) solver.add(5364450 * a1[19] == 257493600) solver.add(13464540 * a1[20] == 767478780) solver.add(5488432 * a1[21] == 312840624) solver.add(14479500 * a1[22] == 1404511500) solver.add(6451830 * a1[23] == 316139670) solver.add(6252576 * a1[24] == 619005024) solver.add(7763364 * a1[25] == 372641472) solver.add(7327320 * a1[26] == 373693320) solver.add(8741520 * a1[27] == 498266640) solver.add(8871876 * a1[28] == 452465676) solver.add(4086720 * a1[29] == 208422720) solver.add(9374400 * a1[30] == 515592000) solver.add(5759124 * a1[31] == 719890500) # 确保每个字符在0-255范围内（ASCII） for c in a1: solver.add(c \u0026gt;= 0, c \u0026lt;= 255) if solver.check() == sat: model = solver.model() flag = \u0026#39;\u0026#39;.join([chr(model[c].as_long()) for c in a1]) # type: ignore print(\u0026#34;\u0026#34;, flag) else: print(\u0026#34;无解\u0026#34;) # flag{e65421110ba03099a1c039337} 但是疑惑的是少了一位，最后看别人题解都是爆破出来的（，a1[6]=\u0026lsquo;1\u0026rsquo;, 所以正确的应该是flag{e165421110ba03099a1c039337}\nCrackRTF 这道题的考点是rtf文件,主要的逻辑是先输入六个数字拼接@DBApp然后判断hash-sha1编码，这里爆破出的结果是123321，然后是长度为6的字符串，拼接在一起进行MD5编码，由于MD5编码不可逆，我尝试过爆破，生成所有 6 位组合，总数为 95^6 ≈ 735 亿次，遂放弃。\nRTF是Rich Text Format的缩写，意即多文本格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 char __cdecl sub_4014D0(LPCSTR Destination) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026#34;AAA\u0026#34;);// FindResourceA 函数用于查找程序资源中的一个资源。 // 第一个参数为 NULL，表示查找当前进程的资源。 // 第二个参数为资源标识符，这里是 0x65。 // 第三个参数为资源类型，这里是 \u0026#34;AAA\u0026#34;。 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo);// SizeofResource 函数用于获取资源的大小。 // 如果资源大小为 0，表示资源无效。 hResData = LoadResource(0, hResInfo); // LoadResource 函数用于加载资源。 if ( !hResData ) return 0; lpBuffer = LockResource(hResData); // LockResource 函数用于锁定资源，并返回资源的指针。 sub_401005(Destination, (int)lpBuffer, nNumberOfBytesToWrite);// 异或 hFile = CreateFileA(\u0026#34;dbapp.rtf\u0026#34;, GENERIC_ALL, 0, 0, CREATE_ALWAYS, FILE_READ_ATTRIBUTES, 0);// CreateFileA 函数用于创建或打开一个文件。 // 文件名为 \u0026#34;dbapp.rtf\u0026#34;。 // 打开模式为 CREATE_ALWAYS，表示如果文件不存在则创建，如果存在则覆盖。 // 文件访问权限为 GENERIC_ALL，表示完全访问权限。 if ( hFile == (HANDLE)-1 ) // 如果文件创建失败，返回 0。 return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); // 关闭文件句柄。 return 1; } 这里就是我们输入的东西拼接后与“AAA”文件中的读取的前几位异或\n从网上找到rtf的示例文件下下来对比发现前几位都是一样的\n把前几位截下来，然后进行异或处理就能得到前六位~!3a@0123321,很明显**~!3a@0**为所求。于是在ida中动调，生成rtf文件，打开后得到flag ","date":"2025-05-22T21:08:17+08:00","permalink":"https://fanshanng.github.io/p/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Buuctf刷题记录"},{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-19T00:15:39+08:00","permalink":"https://fanshanng.github.io/p/frida/","title":"Frida"}]