[{"content":"0x00 什么是Frida frida官方文档\n它是原生应用的Greasemonkey，或者用更专业的术语来说，它是一个动态代码插桩工具包。它允许你将 JavaScript 代码片段或你自己的库注入到 Windows、macOS、GNU/Linux、iOS、watchOS、tvOS、Android、FreeBSD 和 QNX 上的原生应用中。Frida 还提供了基于 Frida API 构建的一些简单工具。这些工具可以直接使用，也可以根据你的需求进行调整，或者作为 API 使用示例。\n","date":"2025-09-28T22:21:41+08:00","image":"https://img.scwcd.cn/markdown/27lh0p36.jpg","permalink":"https://fanshanng.cn/p/frida/","title":"安卓逆向入门七：Frida入门"},{"content":"一次IDA动态调试安卓apk记录 工具清单：IDA Pro9.1 小米手机（MIUI 15.5.2）吾爱破解的教程demo（解压密码：52pj） ADB环境 在IDA目录下的dbgsrv，选择跟手机架构一致的server 在mt管理器中点开目标app的属性进行手动提权 也可以adb进入提权 重命名android_server为as，可以防止一些反调试\n此处运行编辑好的.bat文件，也可以用命令行替代\n运行成功就会显示如下画面（只需点击IDAdebug1.bat即可） 打开ida pro，设置Hostname为127.0.0.1 使用默认端口号为23946 对check函数下断点\n然后\n附加到对应进程，会出现如下所示窗口，选择same 然后程序会停在如图所示的地方，这时候要点开始调试（蓝色小三角），在手机输入任意字符串后点击验证 等待程序运行到断点\n步进到比较函数处\n点击_wuaipojie0123456就可以看到比较的值，即为flag 在第一次调试过程遇到了反调试，在JNI_OnLoad中 将对应代码patch掉后，右键保存 点击Apply patches覆盖掉原本的so文件，然后将这个so文件替换原本的apk/lib/arm64-v8a中的so文件，重新安装该应用，再次运行上述操作，即可绕过反调试 补充常见寄存器知识 在进行动态调试，以下是一些常用的寄存器介绍：\n寄存器名称 功能介绍 R0-R12 通用寄存器，用于存储临时数据。在函数调用时，R0-R3用于存储前四个参数，其余的参数通过堆栈传递。返回值也通过R0和R1传递。 R13 (SP) 堆栈指针寄存器，指向当前堆栈的顶部。 R14 (LR) 链接寄存器，存储子程序的返回地址。 R15 (PC) 程序计数器，指向下一条要执行的指令。 CPSR 当前程序状态寄存器，保存程序的状态信息，如算术运算的结果标志、中断禁止标志等。 FPSCR 浮点状态和控制寄存器，如果你在调试的代码中涉及到浮点运算，那么这个寄存器会比较重要。 常用快捷键 快捷键 功能 F2 在所在行下断点 F5 可以将ARM指令转化为可读的C代码，同时可以使用Y键，对JNIEnv指针做一个类型转换，从而对JNI里经常使用的JNIEnv方法能够识别 F7 单步进入调试 F8 按照顺序一行一行，单步调试 F9 直接跳到下一个断点处 Shift + F12 快速查看so文件中的字符串信息，分析过程中通过一些关键字符串能够迅速定位到关键函数 Ctrl + s 有两个用途，在IDA View页面中可以查看文件so文件的所有段信息，在调试页面可以查看程序中所有so文件映射到内存的基地址。tips:在进行so调试过程中，很有用的一个小技巧就是IDA双开，一个用于进行静态分析；一个用于动态调试。比如说调试过程中要找到一个函数的加载到内存中的位置 Esc 回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口） g 直接跳到某个地址 y 更改变量的类型 x 对着某个函数、变量按该快捷键，可以查看它的交叉引用 n 更改变量的名称 p 创建函数 可能遇到的问题 1.jdb 不是内部或外部命令，也不是可运行的程序或批处理文件。 ​\thttp://t.csdn.cn/paKAt\n1 2 3 4 5 6 7 8 9 10 11 12 java.io.IOException: handshake failed - connection prematurally closed at com.sun.tools.jdi.SocketTransportService.handshake(SocketTransportService.java:136) at com.sun.tools.jdi.SocketTransportService.attach(SocketTransportService.java:232) at com.sun.tools.jdi.GenericAttachingConnector.attach(GenericAttachingConnector.java:116) at com.sun.tools.jdi.SocketAttachingConnector.attach(SocketAttachingConnector.java:90) at com.sun.tools.example.debug.tty.VMConnection.attachTarget(VMConnection.java:519) at com.sun.tools.example.debug.tty.VMConnection.open(VMConnection.java:328) at com.sun.tools.example.debug.tty.Env.init(Env.java:63) at com.sun.tools.example.debug.tty.TTY.main(TTY.java:1066) 致命错误: 无法附加到目标 VM。 解决方法：有可能是手机问题，建议低版本真机，不要用模拟器！切命令顺序不要乱！另外也有可能软件有反调试！ 3.动态调试中找不到so文件 解决方法：可以尝试手动复制一份对应的so文件放到data/app/包名/lib目录下\n4.device offline 解决方法：重新插拔usb，再不行就重启机子\n5.0.0.0.0:23946: bind: Address already in use 解决方案： adb shell \u0026quot;su -c 'lsof | grep 23946'\u0026quot; //获取pid adb shell \u0026quot;su -c 'kill -9 PID'\u0026quot; //这里的pid要根据上一步获取的填写\n6.常见反调试\n调试端口检测\n检测常见的23946端口，所以在运行时可以加-p指定一个另外的端口来过掉这个检测\n例如，使用./as -p 12345命令启动调试server，将调试端口改为12345，然后在IDA Pro中相应地修改端口号为12345进行连接。\n调试进程名检测\n固定的进程名 android_server gdb_server等等，所以要改个名字，例如as64\nptrace检测\n每个进程同时刻只能被1个调试进程ptrace ，主动ptrace本进程可以使得其他调试器无法调试\n实现代码：\n1 2 3 4 int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote { return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试 } 推荐一个安卓的显示控制软件：QtScrcpy 打开如下按钮后可以实现电脑的模拟点击，非常好用 参考文件：\n《安卓逆向这档事》十二、大佬帮我分析一下\nIDA修改exe并保存运行\n使用IDA进行动态调试与过反调试（上）（三）\n","date":"2025-09-26T23:55:59+08:00","image":"https://s.panlai.com/zb_users/upload/2025/06/20250625120242175082416230890.jpg-arthumbs","permalink":"https://fanshanng.cn/p/%E4%B8%80%E6%AC%A1ida%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%AE%89%E5%8D%93apk%E8%AE%B0%E5%BD%95/","title":"一次IDA动态调试安卓apk记录"},{"content":"关键词：ELF文件入门、so文件分析 、ARM基础知识\n0x00 ELF文件入门 ELF（Executable and Linkable Format）是一种可执行和可链接的文件格式，是linux底下二进制文件，可以理解为windows下的PE文件，在Android中可以比作SO，方便函数的移植，在常用于保护Android软件，增加逆向难度。其核心价值在于支持程序的执行（如二进制程序运行、动态库加载）和链接（编译过程中的模块组合），是跨平台二进制兼容的基础。\nELF文件的主要组成部分包括：\nELF Header：文件头，描述文件的基本信息\nProgram Header Table：程序头表，描述进程映像的布局\nSection Header Table：节区头表，描述文件的各个节区\n程序头表与分段头表引用的数据，比如 .text .data。\nELF Header（文件头） ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，是ELF 文件的 \u0026ldquo;总目录\u0026rdquo;，存储文件的基础元信息，可通过这些信息索引到其他所有结构。32 位 ELF 的文件头结构定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; ELF32_Half e_type; ELF32_Half e_machine; ELF32_Word e_version; ELF32_Addr e_entry; ELF32_Off e_phoff; ELF32_Off e_shoff; ELF32_Word e_flags; ELF32_Half e_ehsize; ELF32_Half e_phentsize; ELF32_Half e_phnum; ELF32_Half e_shentsize; ELF32_Half e_shnum; ELF32_Half e_shstrndx; } Elf32_Ehdr; ELF 头中的 e_shoff 项给出了从文件开头到节头表位置的字节偏移。e_shnum 告诉了我们节头表包含的项数；e_shentsize 给出了每一项的字节大小。\nProgram Header Table（程序头表） Program Header Table 是一个结构体数组，每一个元素的类型是 Elf32_Phdr，描述了一个段或者其它系统在准备程序执行时所需要的信息。\n其中，ELF 头中的 e_phentsize 和 e_phnum 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。程序的头部只有对于可执行文件和共享目标文件有意义。\n可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。\nElf32_Phdr的定义如下\n1 2 3 4 5 6 7 8 9 10 typedef struct { ELF32_Word p_type; ELF32_Off p_offset; ELF32_Addr p_vaddr; ELF32_Addr p_paddr; ELF32_Word p_filesz; ELF32_Word p_memsz; ELF32_Word p_flags; ELF32_Word p_align; } Elf32_Phdr; 字段说明 字段 说明 p_type 该字段为段的类型，或者表明了该结构的相关信息。 p_offset 该字段给出了从文件开始到该段开头的第一个字节的偏移。 p_vaddr 该字段给出了该段第一个字节在内存中的虚拟地址。 p_paddr 该字段仅用于物理地址寻址相关的系统中， 由于 “System V” 忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。 p_filesz 该字段给出了文件镜像中该段的大小，可能为 0。 p_memsz 该字段给出了内存镜像中该段的大小，可能为 0。 p_flags 该字段给出了与段相关的标记。 p_align 可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。 核心意义：操作系统加载 ELF 文件时，根据程序头表将 \u0026ldquo;段\u0026rdquo; 映射到内存，例如：\np_type=PT_LOAD的段会被加载到p_vaddr指定的内存地址。 p_flags=0x5（R+X）通常对应代码段（可执行且只读），p_flags=0x6（R+W）对应数据段。 Section Header Table（节区头表） 该结构用于定位 ELF 文件中的每个节区的具体位置。描述 ELF 文件在编译链接时的结构（即 \u0026ldquo;节区\u0026rdquo; 信息），用于调试、静态分析等场景。每个条目对应一个Elf32_Shdr结构：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { ELF32_Word sh_name; ELF32_Word sh_type; ELF32_Word sh_flags; ELF32_Addr sh_addr; ELF32_Off sh_offset; ELF32_Word sh_size; ELF32_Word sh_link; ELF32_Word sh_info; ELF32_Word sh_addralign; ELF32_Word sh_entsize; } Elf32_Shdr; 成员 说明 取值 说明 sh_name sh_name节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。 0 无名称 sh_type sh_type根据节的内容和语义进行分类，具体的类型下面会介绍。 SHT_NULL 限制 sh_flags sh_flags每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。 0 无标志 sh_addr sh_addr如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 0 无地址 sh_offset sh_offset给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 0 无文件偏移 sh_size sh_size此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 0 无大小 sh_link sh_link此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。 SHN_UNDEF 无链接信息 sh_info sh_info此成员给出附加信息，其解释依赖于节区类型。 0 无辅助信息 sh_addralign sh_addralign某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralign=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 0 无对齐要求 常见节区（Sections） 节区是 ELF 文件的实际数据载体，常见类型及作用如下：\n节区名 描述 .text 代码段，存放程序的指令 .data 数据段，存放已初始化的全局变量和静态变量 .rodata 只读数据段，存放只读数据 .bss 未初始化数据段，存放未初始化的全局变量和静态变量 .symtab 符号表，存放符号信息 .strtab 字符串表，存放字符串数据 .dynsym 动态符号表，存放动态链接需要的符号信息 .dynamic 动态链接信息，存放动态链接器需要的信息 段与节区的关系\n段（Segment）：面向运行时，由一个或多个节区组成（如.text和.rodata可合并为一个 \u0026ldquo;代码段\u0026rdquo;）。 节区（Section）：面向编译时，按功能划分的最小数据单元。 例如：一个PT_LOAD段可能包含.text（代码）和.rodata（只读数据）两个节区，共同映射到内存的只读可执行区域。\n0x01 ARM基础知识 \u0026ldquo;x86、arm、RISC-V\u0026rdquo; 都是 指令集架构 ( CPU架构 )。ARM 是主流的 RISC（精简指令集）架构，广泛用于嵌入式设备（如 Android 手机）。\n指令集特点\n固定指令长度（32 位 ARM 指令，Thumb 模式为 16 位）。\n大部分指令可条件执行（如ADDNE R0, R1, R2：仅当标志位不为 0 时执行加法）。\n寄存器操作优先（算术 / 逻辑运算通常基于寄存器，内存访问需专用指令）。\n核心寄存器\n​\tARM32 架构有 16 个通用寄存器（R0-R15），其中：\nR0-R3：函数调用参数 / 返回值寄存器。 R4-R11：通用寄存器（需手动保存）。 R12（IP）：临时寄存器。 R13（SP）：栈指针寄存器（指向栈顶）。 R14（LR）：链接寄存器（存储函数返回地址）。 R15（PC）：程序计数器（存储下一条执行的指令地址）。 常见寻址方式 寻址方式 描述 立即数寻址 直接使用立即数值作为操作数，例如：MOV R0, #5 寄存器直接寻址 使用寄存器中的值作为操作数，例如：MOV R0, R1 寄存器间接寻址 使用寄存器中的值作为内存地址，访问该地址中的数据，例如：LDR R0, [R1] 寄存器相对寻址 使用寄存器中的值加上一个立即偏移量作为内存地址，例如：LDR R0, [R1, #4] 寄存器变址寻址 使用两个寄存器中的值相加作为内存地址，例如：LDR R0, [R1, R2] 带有变址寄存器的寄存器相对寻址 使用寄存器中的值加上另一个寄存器的值乘以一个比例因子作为内存地址，例如：LDR R0, [R1, R2, LSL #2] 堆栈寻址 使用堆栈指针寄存器（如SP）进行操作，例如：PUSH {R0, R1} 或 POP {R0, R1} 压栈和出栈指令 指令类型 指令示例 描述 压栈 PUSH {R0, R1} 将寄存器R0和R1的内容压入堆栈中 压栈 PUSH {R0-R5} 将寄存器R0到R5的内容压入堆栈中 压栈 STMDB SP!, {R0-R5} 将寄存器R0到R5的内容压入堆栈中（与PUSH等效） 出栈 POP {R0, R1} 从堆栈中弹出数据，恢复到寄存器R0和R1中 出栈 POP {R0-R5} 从堆栈中弹出数据，恢复到寄存器R0到R5中 跳转指令 指令类型 指令示例 描述 无条件跳转 B label 无条件跳转到标签label指向的位置 子程序调用 BL label 调用子程序，将当前指令的下一条指令地址存入链接寄存器（LR），然后跳转到标签label指向的位置 子程序返回 BX LR 返回子程序调用前的位置，跳转到链接寄存器（LR）中存储的地址 寄存器跳转 BX Rn 跳转到寄存器Rn中存储的地址 算术运算指令 汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 所示：\n指令 计算公式 备注 ADD Rd, Rn, Rm Rd = Rn + Rm 加法运算，指令为 ADD ADD Rd, Rn, #immed Rd = Rn + #immed 加法运算，指令为 ADD ADC Rd, Rn, Rm Rd = Rn + Rm + 进位 带进位的加法运算，指令为 ADC ADC Rd, Rn, #immed Rd = Rn + #immed + 进位 带进位的加法运算，指令为 ADC SUB Rd, Rn, Rm Rd = Rn - Rm 减法 SUB Rd, #immed Rd = Rd - #immed 减法 SUB Rd, Rn, #immed Rd = Rn - #immed 减法 SBC Rd, Rn, #immed Rd = Rn - #immed - 借位 带借位的减法 SBC Rd, Rn ,Rm Rd = Rn - Rm - 借位 带借位的减法 MUL Rd, Rn, Rm Rd = Rn * Rm 乘法 (32 位) UDIV Rd, Rn, Rm Rd = Rn / Rm 无符号除法 SDIV Rd, Rn, Rm Rd = Rn / Rm 有符号除法 逻辑运算 汇编语言的时候也可以使用逻辑运算指令，常用的运算指令用法如表 所示： 0x02 Android so文件分析 1.SO 文件概述 SO 文件是 Unix/Linux 系统中的动态库文件，被称为共享目标文件（Shared Object File），后缀名为 .so，它是 ELF 的一种，另外属于 ELF 类型的还有可重定位文件（Relocatable File）以及核心转储文件（Core Dump File）。\nSO 文件通常用于提高开发效率、方便快速移植代码，以及保护 Android 应用的核心逻辑，增加逆向工程的难度。不同的 CPU 架构（如 ARM、x86 等）需要不同版本的 SO 文件来适配其指令集和运行环境。\nELF 文件类型 典型后缀 核心用途 逆向 / 开发场景举例 与 ARM 的关联 可执行文件 无（如/bin/ls） 直接运行的程序 分析 Linux/ARM 嵌入式设备的二进制逻辑 ARM32/64 位设备的可执行文件需对应架构 共享目标文件（SO） .so 供其他程序动态调用的库（代码复用 + 保护） 逆向 Android 的libnative.so（核心逻辑载体） Android SO 分armeabi-v7a（ARM32）、arm64-v8a（ARM64） 目标文件 .o 编译后的中间文件（未链接） 分析编译后的单个模块代码（如 NDK 编译的xxx.o） ARM 编译器（如arm-linux-androideabi-gcc）生成对应.o 核心转储文件 .core 程序崩溃时的内存快照 分析 SO 崩溃原因（如空指针访问导致的 core dump） ARM 设备崩溃时生成的 core 需用 ARM 架构的 gdb 分析 Android 是基于 Linux 内核开发的操作系统，所以 Android 平台上的可执行文件格式和 Unix/Linux 是一致的。\nso文件大体上可分为四部分，一般来说从上往下是ELF头部-\u0026gt;Pargarm头部-\u0026gt;节区(Section)-\u0026gt;节区头，其中，除了ELF头部在文件位置固定不变外，其余三部分的位置都不固定。\n整体结构图参考非虫大佬的图：\n2.SO 文件的加载方法 Android 通过 Java 层的System类加载 SO，核心方法有两种：\n方法 签名 特点 适用场景 loadLibrary System.loadLibrary(String name) 自动拼接文件名（name → libname.so），从默认路径（如/data/app/.../lib）加载。 应用内置 SO 的常规加载。 load System.load(String path) 需传入 SO 的绝对路径（如/sdcard/libtest.so）。 插件化加载、动态下载的 SO。 3.SO 文件的加载流程 loadLibrary 加载流程 调用 System.loadLibrary(String libName) 时，实际上会调用 Runtime.getRuntime().loadLibrary(String libName)。 Runtime.loadLibrary(String libName) 会进一步调用 Runtime.loadLibrary(String libName, ClassLoader loader)，其中 loader 是当前线程的类加载器。 通过类加载器找到对应的 SO 文件路径，然后调用 doLoad(String name, ClassLoader loader) 方法进行加载。 load 加载流程 调用 System.load(String pathName) 时，实际上会调用 Runtime.getRuntime().load(String pathName)。 Runtime.load(String pathName) 会调用 Runtime.load(String pathName, ClassLoader loader)，同样会调用 doLoad(String name, ClassLoader loader) 方法进行加载。 核心加载流程：doLoad 路径处理：doLoad 方法会根据传入的路径和类加载器，确定 SO 文件的实际路径。 动态链接库加载：调用 dlopen 函数加载动态链接库。 JNI_OnLoad 调用：如果 SO 文件中定义了 JNI_OnLoad 函数，则在加载完成后调用该函数进行初始化。 参考文件：\nAndroid so(ELF)文件解析\n《安卓逆向这档事》十、不是我说，有了IDA还要什么女朋友？\nandroid 加载so过程分析\n[ctfwiki]so 介绍 ","date":"2025-09-25T22:07:51+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250925233532.png","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%85%ADsoelf%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8Earm%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"安卓逆向入门六：so(ELF)文件分析与ARM基础知识"},{"content":"一、手机端下载并配置光速虚拟机 3.8.2 1.下载模拟器：在手机应用商店或官方渠道，搜索并下载 “光速虚拟机 3.8.2” 版本，安装完成后打开，此时会指导进行解除安卓进程限制，跟着步骤来即可。\n2.创建安卓 10 实例：进入模拟器主界面，点击 “新建实例”，在系统版本选项中选择 “安卓 10”，等待实例创建完成（过程需耐心等待，避免中途退出)。\n3.开启 root 相关权限：\n进入已创建的安卓 10 实例，在实例浮窗内找到 “设置” 图标，进入后依次开启 “Magisk 支持” 和 “超级用户” 功能。 4.调整网络设置：\n因使用手机自身流量（路由器不支持远程 adb），需关闭网络隔离：进入浮窗内的 “设置 - 网络设置”，找到 “本地网络隔离” 选项，将其关闭（防止流量网络被隔离，影响后续连接）。 二、安装 Magisk25.0 完成 root 下载指定版本 Magisk：在安卓 10 实例内，通过浏览器访问 Magisk 官网旧版本页面，下载 “Magisk25.0” 安装包（高版本不兼容光速虚拟机 3.8.2，需严格选择 25.0 版本，其余低版本未曾尝试，可能也支持）。 安装 Magisk：\n找到下载好的 Magisk25.0 安装包，点击Magisk处的“安装”，弹出安装界面后直接点击 “下一步”，在安装方式中选择 “直接安装（推荐）”，等待安装进度完成。 重启验证 root： 安装完成后，按照提示重启安卓 10 实例；重启后先关闭实例内的 “超级用户” 功能，再重启，此时 root 操作完成（可通过实例内的 Magisk 应用查看 “已安装” 状态，确认 root 成功）。 三、在安卓 10 实例内开启开发者模式与 USB 调试 进入 “关于手机”：在安卓 10 实例内打开 “设置”，滑动至底部找到 “关于手机” 选项，点击进入。\n触发开发者模式：在 “关于手机” 页面中，找到 “版本号” 选项，连续点击 7 次 “版本号”，此时会弹出 “您现在处于开发者模式！” 的提示（若弹出验证密码 / 指纹，按实例内设置完成验证即可）。\n开启 USB 调试：返回 “设置” 主界面，找到 “系统” 选项；点击进入 “开发者选项”，找到 “USB 调试” 选项并开启（部分系统需勾选 “允许 USB 调试” 弹窗，点击 “确定” 即可）。\n四、电脑端通过 adb 远程连接手机 准备工作：确保电脑已提前下载并配置好 adb 环境（adb 工具包路径已添加至系统环境变量，可通过 “cmd 输入 adb \u0026ndash;version” 验证配置）。\n建立网络连接：\n打开手机的 “个人热点”，将电脑连接至该热点（确保手机与电脑处于同一热点网络，替代不支持 adb 的路由器）。 获取手机 IP： 在手机 “设置 - 无线和网络 - 个人热点” 中，查看热点的 “已连接设备” 或 “网络详情”，记录手机当前的 IP 地址（如 10.77.xx.xx）。 执行 adb 连接命令： 打开电脑的命令提示符（CMD），输入命令：adb connect 手机IP:6556（将 “手机 IP” 替换为实际记录的地址，如adb connect 10.77.xx.xx:6556）。\n若一切正常此时手机会弹出提示，点击确认即可。\n若命令行显示 “connected to 手机 IP:6556”，则表示远程 adb 调试连接成功，可开始进行后续调试操作。\n下载用的模拟器以及magisk：\nhttps://pan.baidu.com/s/1ePYYJIPQXNRKJyA9qJclWA?pwd=kdcq 提取码: kdcq\n","date":"2025-09-23T00:37:06+08:00","image":"https://s.panlai.com/upload/bizhihui_com_20231111141953169968359310619.jpg-arthumbs","permalink":"https://fanshanng.cn/p/%E5%85%89%E9%80%9F%E8%99%9A%E6%8B%9F%E6%9C%BA3.8.2-root%E5%8F%8Aadb%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C/","title":"光速虚拟机3.8.2 root及adb远程连接操作"},{"content":"关键词：Xposed原理和常用api、Android Studio安装以及环境配置、hook、借助lspatch实现免root注入、SimpleHook快速hook\n0x00 什么是Xposed Xposed 是一款无需修改 APK 即可影响程序运行的 Hook 框架，基于它可以开发功能强大的插件 APP，实现对目标应用的注入、拦截、修改等操作，且多个功能不冲突的模块可同时运行。\n简单来说，Xposed 的核心是 “在不改变原应用代码的情况下，动态干预其运行逻辑”，这使得它成为安卓逆向、功能扩展的重要工具。\nXposed (维基百科)\n0x01 Xposed原理 Xposed 的核心是劫持 Zygote 进程（安卓系统的进程孵化器，所有应用进程都由它创建），具体过程如下：\n用自定义实现的app_process替换系统原生的app_process； 加载额外的 XposedBridge.jar 包，将程序入口从系统默认的com.android.internal.os.ZygoteInit.main()替换为de.robv.android.xposed.XposedBridge.main()； 改造后的 Zygote 进程创建的所有 Dalvik/ART 虚拟机都会被 Hook，从而实现对所有应用进程的动态干预。 通俗来讲，hook就是狸猫换太子\n0x02 Xposed的发展及免root框架 随着安卓版本迭代，Xposed 衍生出多个分支，下表整理了主流框架的特点：\n名称 地址 支持版本 是否免root xposed https://github.com/rovo89/Xposed 2.3-8.1 否 EDXposed https://github.com/ElderDrivers/EdXposed 8.0-10 否 LSPosed https://github.com/LSPosed/LSPosed 8.1-13 否 VirtualXposed https://github.com/android-hacker/VirtualXposed 5.0-10.0 是 太极 https://www.coolapk.com/apk/me.weishu.exp 5.0-13 是 两仪 https://www.coolapk.com/apk/io.twoyi 8.1-13 是 天鉴 https://github.com/Katana-Official/SPatch-Update 6-10 是 0x03 Xposed可以用来做什么？ 功能增强：修改应用布局（如上帝模式）、去除广告（如知乎去广告模块）；\n数据干预：劫持参数 / 返回值（如微信防撤回、步数修改、一键新机）；\n自动化操作：微信自动抢红包、抖音自动操作等；\n逆向辅助：动态分析应用逻辑、绕过加密 / 验证（如XServer）。\n2022 最好的Xposed模块: GravityBox, Pixelify, XPrivacyLua\n基于Xposed的抖音爬虫，抖音风控后自动一键新机，模拟一个全新的运行环境\n基于xposed的frida持久化方案\nA Xposed Module for Android Penetration Test, with NanoHttpd.\nGravityBox\nXposed-Modules-Repo]\n一个旨在使QQ变得更好用的开源Xposed模块\n杜比大喇叭\n哔哩漫游\n曲境\n自动化创建Xposed模块及钩子，让Xposed模块编写时只需关注钩子实现\n0x04 Xposed环境配置 这里下载的是正己提供的Ubuntu虚拟机 密码:toor\n内置:\nFrida开发环境 动态分析及开发工具：android-studio 动态分析工具：ddms 静态分析工具：jadx1.4.4 动静态分析工具：jeb 动态分析工具：集成HyperPwn 静态分析工具：010 editor 抓包工具：Charles 抓包工具：WireShark 动态分析工具:unidbg 1.Android Studio创建新项目\n2.将下载的xposedBridgeApi.jar包拖进libs文件夹\n3.右击jar包，选择add as library\n4.修改AndroidManifest.xml文件配置\n将如下代码复制到xml文件中，如图\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedmodule\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 模块描述，显示在xposed模块列表那里第二行 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposeddescription\u0026#34; android:value=\u0026#34;这是一个Xposed模块\u0026#34; /\u0026gt; \u0026lt;!-- 最低xposed版本号(lib文件名可知) --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedminversion\u0026#34; android:value=\u0026#34;89\u0026#34; /\u0026gt; 5.修改build.gradle,将此处修改为compileOnly 默认的是implementation\nimplementation 使用该方式依赖的库将会参与编译和打包\ncompileOnly 只在编译时有效，不会参与打包\n6.新建\u0026ndash;\u0026gt;Folder\u0026ndash;\u0026gt;Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类\n7.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑\n1 2 3 4 5 6 7 8 9 import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class Hook implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { } } 继承了IXposedHookLoadPackag便拥有了hook的能力\n0x05 Xposed常用API 1.Hook普通方法 修改返回值\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(999); } }); 修改参数\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); String a = \u0026#34;pt\u0026#34;; param.args[0] = a; } }); 2.Hook复杂\u0026amp;自定义参数 1 2 3 4 5 6 7 8 Class a = loadPackageParam.classLoader.loadClass(\u0026#34;类名\u0026#34;); XposedBridge.hookAllMethods(a, \u0026#34;方法名\u0026#34;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } }); 3.Hook替换函数 使用XC_MethodReplacement直接替换原方法：\n1 2 3 4 5 6 7 Class a = classLoader.loadClass(\u0026#34;类名\u0026#34;) XposedBridge.hookAllMethods(a,\u0026#34;方法名\u0026#34;,new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return \u0026#34;\u0026#34;; } }); 上图中日志这里的 “这是替换函数” 就被替换无了\n4.Hook加固通杀 加固应用会动态加载 dex，需在Application.attach时获取加载后的类加载器：\n1 2 3 4 5 6 7 8 XposedHelpers.findAndHookMethod(Application.class, \u0026#34;attach\u0026#34;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Context context = (Context) param.args[0]; ClassLoader classLoader = context.getClassLoader(); //hook逻辑在这里面写 } }); 5.Hook变量 静态变量与实例变量 静态变量(static)：类被初始化，同步进行初始化 非静态变量：类被实例化(产生一个对象的时候)，进行初始化 6.Hook构造函数 无参构造函数\n1 2 3 4 5 6 7 8 9 10 XposedHelpers.findAndHookConstructor(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, classLoader, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 有参构造函数\n1 2 3 4 5 6 7 8 9 10 XposedHelpers.findAndHookConstructor(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, classLoader, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 7.Hook multiDex方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 XposedHelpers.findAndHookMethod(Application.class, \u0026#34;attach\u0026#34;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { ClassLoader cl= ((Context)param.args[0]).getClassLoader(); Class\u0026lt;?\u0026gt; hookclass=null; try { hookclass=cl.loadClass(\u0026#34;类名\u0026#34;); }catch (Exception e){ Log.e(\u0026#34;zj2595\u0026#34;,\u0026#34;未找到类\u0026#34;,e); return; } XposedHelpers.findAndHookMethod(hookclass, \u0026#34;方法名\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { } }); } }); 8.主动调用 静态方法\n1 2 Class clazz = XposedHelpers.findClass(\u0026#34;类名\u0026#34;,lpparam.classLoader); XposedHelpers.callStaticMethod(clazz,\u0026#34;方法名\u0026#34;,参数(非必须)); 实例方法\n1 2 Class clazz = XposedHelpers.findClass(\u0026#34;类名\u0026#34;,lpparam.classLoader); XposedHelpers.callMethod(clazz.newInstance(),\u0026#34;方法名\u0026#34;,参数(非必须)); 9.Hook内部类 内部类名格式为外部类$内部类（如com.zj.wuaipojie.Demo$InnerClass）\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo$InnerClass\u0026#34;, lpparam.classLoader, \u0026#34;innerFunc\u0026#34;,String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } }); 10.反射大法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Class clazz = XposedHelpers.findClass(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, lpparam.classLoader); XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo$InnerClass\u0026#34;, lpparam.classLoader, \u0026#34;innerFunc\u0026#34;,String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); //第一步找到类 //找到方法，如果是私有方法就要setAccessible设置访问权限 //invoke主动调用或者set修改值(变量) Class democlass = Class.forName(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;,false,lpparam.classLoader); Method demomethod = democlass.getDeclaredMethod(\u0026#34;refl\u0026#34;); demomethod.setAccessible(true); demomethod.invoke(clazz.newInstance()); } }); 11.遍历所有类下的所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 XposedHelpers.findAndHookMethod(ClassLoader.class, \u0026#34;loadClass\u0026#34;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Class clazz = (Class) param.getResult(); String clazzName = clazz.getName(); //排除非包名的类 if(clazzName.contains(\u0026#34;com.zj.wuaipojie\u0026#34;)){ Method[] mds = clazz.getDeclaredMethods(); for(int i =0;i\u0026lt;mds.length;i++){ final Method md = mds[i]; int mod = mds[i].getModifiers(); //去除抽象、native、接口方法 if(!Modifier.isAbstract(mod) \u0026amp;\u0026amp; !Modifier.isNative(mod) \u0026amp;\u0026amp;!Modifier.isAbstract(mod)){ XposedBridge.hookMethod(mds[i], new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.d(\u0026#34;zj2595\u0026#34;,md.toString()); } }); } } } } }); 0x06 Xposed妙用 字符串赋值定位:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 XposedHelpers.findAndHookMethod(\u0026#34;android.widget.TextView\u0026#34;, lpparam.classLoader, \u0026#34;setText\u0026#34;, CharSequence.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.d(\u0026#34;zj2595\u0026#34;,param.args[0].toString()); if(param.args[0].equals(\u0026#34;已过期\u0026#34;)){ printStackTrace(); } } }); private static void printStackTrace() { Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); for (int i = 0; i \u0026lt; stackElements.length; i++) { StackTraceElement element = stackElements[i]; Log.d(\u0026#34;zj2595\u0026#34;,\u0026#34;at \u0026#34; + element.getClassName() + \u0026#34;.\u0026#34; + element.getMethodName() + \u0026#34;(\u0026#34; + element.getFileName() + \u0026#34;:\u0026#34; + element.getLineNumber() + \u0026#34;)\u0026#34;); } } 点击事件监听\n1 2 3 4 5 6 7 8 9 10 11 Class clazz = XposedHelpers.findClass(\u0026#34;android.view.View\u0026#34;, lpparam.classLoader); XposedBridge.hookAllMethods(clazz, \u0026#34;performClick\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Object listenerInfoObject = XposedHelpers.getObjectField(param.thisObject, \u0026#34;mListenerInfo\u0026#34;); Object mOnClickListenerObject = XposedHelpers.getObjectField(listenerInfoObject, \u0026#34;mOnClickListener\u0026#34;); String callbackType = mOnClickListenerObject.getClass().getName(); Log.d(\u0026#34;zj2595\u0026#34;,callbackType); } }); 改写布局\n在 Activity 初始化后修改 UI 元素（如隐藏图片）：\n1 2 3 4 5 6 7 8 9 10 11 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.ui.ChallengeSixth\u0026#34;, lpparam.classLoader, \u0026#34;onCreate\u0026#34;, Bundle.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); View img = (View)XposedHelpers.callMethod(param.thisObject, \u0026#34;findViewById\u0026#34;, 0x7f0800de); img.setVisibility(View.GONE); } }); 修改前 修改后 0x07 Lsposed 免root实现 Lsposed：LSPosed 框架的无 Root 实现方案，通过将 dex 文件与 so 文件插入到目标 APK（安卓应用安装包）中，实现 Xposed API（应用程序编程接口）的集成。 核心原理：重打包目标 APK，将模块代码集成到其中，避免对系统环境的依赖。 0x07 Xposed快速Hook\u0026mdash;\u0026ndash;SimpleHook SimpleHook 是 GitHub 用户 littleWhiteDuck 开发的一款 Android 轻量型 Hook 工具，核心定位是 “简单易用”—— 无需复杂配置即可实现常见 Hook 需求，适合对 Hook 操作复杂度要求低的用户；若需复杂功能（如自定义脚本）或更多扩展能力，官方推荐搭配 jshook（复杂功能）、曲境（电脑端浏览器操作）或算法助手（扩展功能）使用。\n使用步骤： 在 LSPosed 中启用 SimpleHook 模块； 选择目标应用，添加 Hook 配置（类名、方法名、参数类型等）； 重启应用，配置生效。 工具覆盖多种常见 Hook 场景，部分关键模式及示例如下：\n模式类型 功能说明 关键特点 Hook 返回值 修改目标方法的返回结果，支持基本类型（如 boolean、int）、字符串及 null 参数类型留空表示无参，多参数用英文逗号分隔（如 java.lang.String,int） Hook 返回值 + 进阶功能，支持通过 JSON 格式将数据转为目标对象（依赖 Gson） 需填写 “返回值类名”，修改值为 JSON 字符串（如 {\u0026quot;isHook\u0026quot;:false,\u0026quot;level\u0026quot;:10000}） Hook 参数值 修改目标方法的输入参数，支持部分参数或全部参数修改 未修改的参数留空（如仅改第 2、3 个参数，修改值填 ,啦啦啦,99） 中断执行 拦截目标方法执行，使其不触发原有逻辑 无需填写修改值，仅需配置类名、方法名及参数类型 特殊方法 Hook - 构造方法：方法名填写 \u0026lt;init\u0026gt;- 所有同名方法：参数类型填 *- 类内所有方法：方法名填 * 适配不同场景下的批量或特殊方法 Hook 需求 变量 Hook - 静态变量：支持 before/after 两个 Hook 点（方法执行前后修改）- 实例变量：仅支持在本类方法执行后修改，不可跨类 仅支持基本类型和字符串，需填写 “变量所在类名”“变量名” 记录类模式（3 种） 记录参数值、记录返回值、记录参返（参数 + 返回值） 数组或 List 类型参数 / 返回值会自动转为 JSON 格式，便于查看 该软件还满足自定义hook，具体细节请前往SimpleHook学习。\n参考文档 《安卓逆向这档事》七、Sorry，会Hook真的可以为所欲为-Xposed快速上手(上)\n《安卓逆向这档事》八、Sorry，会Hook真的可以为所欲为-xposed快速上手(下)\n源码编译（2）——Xopsed源码编译详解 Xposed Hook技巧，代{过}{滤}理abstract Xposed callMethod 如何传入接口参数\nXPOSED魔改一：获取特征 Lsposed 技术原理探讨 \u0026amp;\u0026amp; 基本安装使用\n","date":"2025-09-21T23:31:39+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250921233613.png","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%BA%94xposed%E5%92%8Chook%E5%85%A5%E9%97%A8/","title":"安卓逆向入门五：Xposed和hook入门"},{"content":"安卓逆向入门四 关键词：apk签名、apk校验及对抗方法、PM代理、io重定向\n学习链接：https://www.52pojie.cn/thread-1731181-1-1.html\n0x00 APK签名 校验是开发者在数据传送时采用的一种校正数据的一种方式 常见的校验有:签名校验(最常见)、dexcrc校验、apk完整性校验、路径文件校验等\n什么是APK签名? 我建议直接去看 Android 官方文档 中关于 APK签名 的安全特性介绍。\nAPK签名是开发者使用私钥对安卓应用进行数字签名的过程，确保应用的完整性和来源，防止被篡改。只有经过签名的应用才能在安卓设备上安装和运行，签名还帮助系统识别应用的开发者，并确保应用在独立的沙盒环境中安全运行。 Android 目前支持以下四种应用签名方案： v1 方案：基于 JAR 签名。 v2 方案：APK 签名方案 v2（在 Android 7.0 中引入） v3 方案：APK 签名方案 v3（在 Android 9 中引入） v4 方案：APK 签名方案 v4（在 Android 11 中引入） 签名方案 推出版本 校验范围 安全优势 局限性 适用场景 v1（JAR 签名） Android 1.0 仅校验 APK 内单个文件（META-INF 下签名文件） 兼容所有安卓版本 可篡改未签名文件（如新增文件） 需兼容 Android 6.0 及以下设备 v2 Android 7.0 校验整个 APK（通过 “签名块” 校验 APK 完整性） 更高效（无需解压）、防篡改新增文件 不兼容 Android 6.0 及以下 目标设备为 Android 7.0+ v3 Android 9.0 在 v2 基础上支持 “签名轮换”（更换签名无需卸载旧版） 支持签名更新（如企业应用换证书） 依赖 Android 9.0+ 需要签名更新的应用（如企业级 APP） v4 Android 11.0 生成单独的签名文件（.apksig），支持增量更新校验 优化大文件安装效率（仅校验变更部分） 依赖 Android 11.0+ 大型应用（如游戏）的增量更新 v4签名生成的.apksig文件必须配合adb install --incremental使用，常规APK安装不会触发此校验。逆向中较少遇到，主要用于Google Play增量更新。 一次让你搞懂Android应用签名 这篇文章讲了签名步骤和原理相关知识，值得一看 APP 的签名检验 系统更多的只是对 APK 做完整性校验，身份校验很容易通过卸载方式来解决，因此许多 APP 为了防止自身被修改和破解，会对自身进行额外的校验，确保没有被修改。\n我们一般称此类检查自身是否被修改的保护技术为签名校验，其校验原理几乎也都是基于文件完整性检验与签名身份信息验证。\n1 2 3 4 5 kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因. system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。 finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理 普通获取签名校验代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private boolean SignCheck() { String trueSignMD5 = \u0026#34;d0add9987c7c84aeb7198c3ff26ca152\u0026#34;; String nowSignMD5 = \u0026#34;\u0026#34;; try { // 得到签名的MD5 PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES); Signature[] signs = packageInfo.signatures; String signBase64 = Base64Util.encodeToString(signs[0].toByteArray()); nowSignMD5 = MD5Utils.MD5(signBase64); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return trueSignMD5.equals(nowSignMD5); } 系统将应用的签名信息封装在PackageInfo中，调用 PackageManager 的getPackageInfo(String packageName, int flags)即可获取指定包名的签名信息.\n0x01 签名校验对抗 方法一:核心破解插件，不签名安装应用 方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能 方法三:具体分析签名校验逻辑(手撕签名校验) 方法四:io重定向\u0026ndash;VA\u0026amp;SVC：ptrace+seccomp SVC的TraceHook沙箱的实现\u0026amp;无痕Hook实现思路 方法五:去作者家严刑拷打拿到.jks文件和密码\n0x02 手动实现PM代{过}{滤}理 1.什么是PMS 思路源自：Android中Hook 应用签名方法\nPackageManagerService（简称PMS），是Android系统核心服务之一，处理包管理相关的工作，常见的比如安装、卸载应用等。\n核心原理\n安卓应用获取签名的流程：应用调用PackageManager.getPackageInfo() → 系统通过PMS（PackageManagerService）查询签名信息并返回； PM 代理的本质：通过 Hook 替换PMS的返回结果 —— 当应用查询签名时，返回原始合法签名（而非修改后 APK 的签名），从而绕过校验。 使用条件与限制\n环境要求：需要 root 权限（修改系统服务）或通过 Xposed/LSPosed 框架（无需 root，但需模块支持）； 局限性：仅对通过PackageManager获取签名的校验有效，若应用直接读取 APK 文件计算签名（如读取/data/app/xxx.apk的签名），则 PM 代理无效（需结合IO重定向，将应用访问的APK路径（如/data/app/包名/base.apk）重定向到保留原始签名的伪造APK文件（仅包含签名所需文件，如META-INF/）。 2.实现方法以及原理解析 HOOK PMS代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.zj.hookpms; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import android.content.Context; import android.content.pm.PackageManager; import android.util.Log; public class ServiceManagerWraper { public final static String ZJ = \u0026#34;ZJ595\u0026#34;; public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) { try { // 获取全局的ActivityThread对象 Class\u0026lt;?\u0026gt; activityThreadClass = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 获取ActivityThread里面原始的sPackageManager Field sPackageManagerField = activityThreadClass.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); // 准备好代{过}{滤}理对象, 用来替换原始的对象 Class\u0026lt;?\u0026gt; iPackageManagerInterface = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{iPackageManagerInterface}, new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0)); // 1. 替换掉ActivityThread里面的 sPackageManager 字段 sPackageManagerField.set(currentActivityThread, proxy); // 2. 替换 ApplicationPackageManager里面的 mPM对象 PackageManager pm = context.getPackageManager(); Field mPmField = pm.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPmField.setAccessible(true); mPmField.set(pm, proxy); } catch (Exception e) { Log.d(ZJ, \u0026#34;hook pms error:\u0026#34; + Log.getStackTraceString(e)); } } public static void hookPMS(Context context) { String Sign = \u0026#34;原包的签名信息\u0026#34;; hookPMS(context, Sign, \u0026#34;com.zj.hookpms\u0026#34;, 0); } } ActivityThread的静态变量sPackageManager ApplicationPackageManager对象里面的mPM变量\n0x03 IO重定向 什么是IO重定向？\nI/O重定向是指改变程序的标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）的默认设备，将其与其他设备或文件进行关联。通过I/O重定向，我们可以将程序的输入从键盘转向文件或其他设备，将程序的输出和错误信息输出到文件或其他设备而不是屏幕上。\n例：在读A文件的时候指向B文件\n平头哥的核心代码 Virtual Engine for Android(Support 12.0 in business version)\nIO重定向可以干嘛？\n1，可以让文件只读，不可写\n2，禁止访问文件\n3，路径替换\n具体实现： 过签名检测(读取原包) 风控对抗(例:一个文件记录App启动的次数) 过Root检测，Xposed检测(文件不可取)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 using namespace std; string packname; string origpath; string fakepath; int (*orig_open)(const char *pathname, int flags, ...); int (*orig_openat)(int,const char *pathname, int flags, ...); FILE *(*orig_fopen)(const char *filename, const char *mode); static long (*orig_syscall)(long number, ...); int (*orig__NR_openat)(int,const char *pathname, int flags, ...); void* (*orig_dlopen_CI)(const char *filename, int flag); void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo); void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr); static inline bool needs_mode(int flags) { return ((flags \u0026amp; O_CREAT) == O_CREAT) || ((flags \u0026amp; O_TMPFILE) == O_TMPFILE); } bool startsWith(string str, string sub){ return str.find(sub)==0; } bool endsWith(string s,string sub){ return s.rfind(sub)==(s.length()-sub.length()); } bool isOrigAPK(string path){ if(path==origpath){ return true; } return false; } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_open 函数有三个参数： //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 int fake_open(const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } //LOGI(\u0026#34;open, path: %s, flags: %d, mode: %d\u0026#34;,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_open, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_open(\u0026#34;/data/user/0/com.zj.wuaipojie/files/base.apk\u0026#34;, flags, mode); } return orig_open(pathname, flags, mode); } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_openat 函数有四个参数： //fd：一个整数，表示要打开的文件的文件描述符。 //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 //openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。 //例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。 // int fake_openat(int fd, const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } LOGI(\u0026#34;openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,fd ,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_openat(fd,fakepath.data(), flags, mode); } return orig_openat(fd,pathname, flags, mode); } FILE *fake_fopen(const char *filename, const char *mode) { string cpp_path= filename; if(isOrigAPK(cpp_path)){ return orig_fopen(fakepath.data(), mode); } return orig_fopen(filename, mode); } //该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。 //syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。 // static long fake_syscall(long number, ...) { void *arg[7]; va_list list; va_start(list, number); for (int i = 0; i \u0026lt; 7; ++i) { arg[i] = va_arg(list, void *); } va_end(list); if (number == __NR_openat){ const char *cpp_path = static_cast\u0026lt;const char *\u0026gt;(arg[1]); LOGI(\u0026#34;syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,arg[0] ,arg[1], arg[2], arg[3]); if (isOrigAPK(cpp_path)){ LOGI(\u0026#34;syscall __NR_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,arg[1], fakepath.data()); return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]); } } return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]); } //函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中 //函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中 //接着，函数使用 fakepath 全局变量保存了 /data/user/0/\u0026lt;packname\u0026gt;/files/base.apk 这样的路径，其中 \u0026lt;packname\u0026gt; 是当前应用的包名。 //然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。 //它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。 //最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) { jclass conext_class = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack = env-\u0026gt;GetMethodID(conext_class, \u0026#34;getPackageName\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;); auto packname_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;CallObjectMethod(context, methodId_pack)); const char *pn = env-\u0026gt;GetStringUTFChars(packname_js, 0); packname = string(pn); env-\u0026gt;ReleaseStringUTFChars(packname_js, pn); //LOGI(\u0026#34;packname: %s\u0026#34;, packname.data()); fakepath= \u0026#34;/data/user/0/\u0026#34;+ packname +\u0026#34;/files/base.apk\u0026#34;; jclass conext_class2 = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack2 = env-\u0026gt;GetMethodID(conext_class2,\u0026#34;getApplicationInfo\u0026#34;,\u0026#34;()Landroid/content/pm/ApplicationInfo;\u0026#34;); jobject application_info = env-\u0026gt;CallObjectMethod(context,methodId_pack2); jclass pm_clazz = env-\u0026gt;GetObjectClass(application_info); jfieldID package_info_id = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;sourceDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto sourceDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id)); const char *sourceDir = env-\u0026gt;GetStringUTFChars(sourceDir_js, 0); origpath = string(sourceDir); LOGI(\u0026#34;sourceDir: %s\u0026#34;, sourceDir); jfieldID package_info_id2 = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;nativeLibraryDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto nativeLibraryDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id2)); const char *nativeLibraryDir = env-\u0026gt;GetStringUTFChars(nativeLibraryDir_js, 0); LOGI(\u0026#34;nativeLibraryDir: %s\u0026#34;, nativeLibraryDir); //LOGI(\u0026#34;%s\u0026#34;, \u0026#34;Start Hook\u0026#34;); //启动hook void *handle = dlopen(\u0026#34;libc.so\u0026#34;,RTLD_NOW); auto pagesize = sysconf(_SC_PAGE_SIZE); auto addr = ((uintptr_t)dlsym(handle,\u0026#34;open\u0026#34;) \u0026amp; (-pagesize)); auto addr2 = ((uintptr_t)dlsym(handle,\u0026#34;openat\u0026#34;) \u0026amp; (-pagesize)); auto addr3 = ((uintptr_t)fopen) \u0026amp; (-pagesize); auto addr4 = ((uintptr_t)syscall) \u0026amp; (-pagesize); //解除部分机型open被保护 mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); DobbyHook((void *)dlsym(handle,\u0026#34;open\u0026#34;), (void *)fake_open, (void **)\u0026amp;orig_open); DobbyHook((void *)dlsym(handle,\u0026#34;openat\u0026#34;), (void *)fake_openat, (void **)\u0026amp;orig_openat); DobbyHook((void *)fopen, (void *)fake_fopen, (void**)\u0026amp;orig_fopen); DobbyHook((void *)syscall, (void *)fake_syscall, (void **)\u0026amp;orig_syscall); } 1 2 3 4 5 6 7 sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils; invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;getContext()Landroid/content/Context; move-result-object p10 invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;-\u0026gt;hook(Landroid/content/Context;)V 0x04 其他常见校验 root检测：\n反制手段 1.算法助手、对话框取消等插件一键hook 2.分析具体的检测代码 3.利用IO重定向使文件不可读 4.修改Andoird源码，去除常见指纹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fun isDeviceRooted(): Boolean { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3() } fun checkRootMethod1(): Boolean { val buildTags = android.os.Build.TAGS return buildTags != null \u0026amp;\u0026amp; buildTags.contains(\u0026#34;test-keys\u0026#34;) } fun checkRootMethod2(): Boolean { val paths = arrayOf(\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;, \u0026#34;/su/bin/su\u0026#34;) for (path in paths) { if (File(path).exists()) return true } return false } fun checkRootMethod3(): Boolean { var process: Process? = null return try { process = Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;)) val bufferedReader = BufferedReader(InputStreamReader(process.inputStream)) bufferedReader.readLine() != null } catch (t: Throwable) { false } finally { process?.destroy() } } 定义了一个 isDeviceRooted() 函数，该函数调用了三个检测 root 的方法：checkRootMethod1()、checkRootMethod2() 和 checkRootMethod3()。\ncheckRootMethod1() 方法检查设备的 build tags 是否包含 test-keys。这通常是用于测试的设备，因此如果检测到这个标记，则可以认为设备已被 root。\ncheckRootMethod2() 方法检查设备是否存在一些特定的文件，这些文件通常被用于执行 root 操作。如果检测到这些文件，则可以认为设备已被 root。\ncheckRootMethod3() 方法使用 Runtime.exec() 方法来执行 which su 命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被 root。\n模拟器检测\n1 2 3 fun isEmulator(): Boolean { return Build.FINGERPRINT.startsWith(\u0026#34;generic\u0026#34;) || Build.FINGERPRINT.startsWith(\u0026#34;unknown\u0026#34;) || Build.MODEL.contains(\u0026#34;google_sdk\u0026#34;) Build.MODEL.contains(\u0026#34;Emulator\u0026#34;) || Build.MODEL.contains(\u0026#34;Android SDK built for x86\u0026#34;) || Build.MANUFACTURER.contains(\u0026#34;Genymotion\u0026#34;) || Build.HOST.startsWith(\u0026#34;Build\u0026#34;) || Build.PRODUCT == \u0026#34;google_sdk\u0026#34; } 通过检测系统的 Build 对象来判断当前设备是否为模拟器。具体方法是检测 Build.FINGERPRINT 属性是否包含字符串 \u0026quot;generic\u0026quot;。\n模拟器检测对抗\n反调试检测\n安卓系统自带调试检测函数 1 2 3 4 5 6 fun checkForDebugger() { if (Debug.isDebuggerConnected()) { // 如果调试器已连接，则终止应用程序 System.exit(0) } } debuggable属性 1 2 3 4 5 6 public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this { boolean isDebug = context.getApplicationInfo() != null \u0026amp;\u0026amp; (context.getApplicationInfo().flags \u0026amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; return isDebug; } ptrace检测 1 2 3 4 int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote { return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试 } 每个进程同时刻只能被1个调试进程ptrace ，主动ptrace本进程可以使得其他调试器无法调试\n调试进程名检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int SearchObjProcess() { FILE* pfile=NULL; char buf[0x1000]={0}; pfile=popen(\u0026#34;ps\u0026#34;,\u0026#34;r\u0026#34;); if(NULL==pfile) { //LOGA(\u0026#34;SearchObjProcess popen打开命令失败!\\n\u0026#34;); return -1; } // 获取结果 //LOGA(\u0026#34;popen方案:\\n\u0026#34;); while(fgets(buf,sizeof(buf),pfile)) { char* strA=NULL; char* strB=NULL; char* strC=NULL; char* strD=NULL; strA=strstr(buf,\u0026#34;android_server\u0026#34;);//通过查找匹配子串判断 strB=strstr(buf,\u0026#34;gdbserver\u0026#34;); strC=strstr(buf,\u0026#34;gdb\u0026#34;); strD=strstr(buf,\u0026#34;fuwu\u0026#34;); if(strA || strB ||strC || strD) { return 1; // 执行到这里，判定为调试状态 } } pclose(pfile); return 0; } [原创]对安卓反调试和校验检测的一些实践与结论\nfrida检测 一些Frida检测手段\n0x05 smali语法\u0026mdash;\u0026ndash;赋值 1.Int型赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 .method private static final onCreate$lambda-0(Lcom/zj/wuaipojie/ui/SmaliLearn;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/view/View;)V .registers 9 .line 21 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;isVip()I move-result p4 //判断vip的值分别对应不用的会员的等级 if-eqz p4, :cond_35 const/4 v0, 0x1 if-eq p4, v0, :cond_2d const/4 v0, 0x4 if-eq p4, v0, :cond_25 const/16 v0, 0x10 if-eq p4, v0, :cond_1d const/16 v0, 0x63 if-eq p4, v0, :cond_15 goto :goto_3c :cond_15 const-string p4, \u0026#34;至尊会员\u0026#34; .line 26 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_1d const-string p4, \u0026#34;超级会员\u0026#34; .line 25 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_25 const-string p4, \u0026#34;大会员\u0026#34; .line 24 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_2d const-string p4, \u0026#34;会员\u0026#34; .line 23 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_35 const-string p4, \u0026#34;非会员\u0026#34; .line 22 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 28 //判断vipEndTime的时间戳是否小于系统时间 :goto_3c new-instance p1, Ljava/util/Date; invoke-direct {p1}, Ljava/util/Date;-\u0026gt;\u0026lt;init\u0026gt;()V invoke-virtual {p1}, Ljava/util/Date;-\u0026gt;getTime()J move-result-wide v0 .line 29 new-instance p1, Ljava/text/SimpleDateFormat; const-string p4, \u0026#34;yyyy-MM-dd\u0026#34; invoke-direct {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;)V .line 30 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v2 cmp-long p4, v2, v0 if-gez p4, :cond_5c const-string p1, \u0026#34;已过期\u0026#34; .line 31 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_6d .line 33 :cond_5c invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v0 invoke-static {v0, v1}, Ljava/lang/Long;-\u0026gt;valueOf(J)Ljava/lang/Long; move-result-object p4 invoke-virtual {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;format(Ljava/lang/Object;)Ljava/lang/String; move-result-object p1 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 35 :goto_6d iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V :cond_74 return-void .end method const/4和const/16的区别？\nconst/4 最大只允许存放4个二进制位(4bit)，\nconst/16 最大值允许存放16个二进制位(16bit)， 第一位(即最高位)默认为符号位。单位换算 1byte=8bit 举例说明下寄存器的取值范围: # 以下数据定义高位默认为符号位\nconst/4 v0,0x2 # 最大只允许存放半字节数据 取值范围为 -8 and 7\nconst/16 v0 , 0xABCD # 定义一个寄存器变量，最大只允许存放16位数据 比如short类型数据 取值范围为-32768~32767\nconst v0 , 0xA# 定义一个寄存器， 最大只允许存放32位数据,比如int类型数据 将数字10赋值给v0 取值范围-2147483647~2147483647\nconst/high16 #定义一个寄存器， 最大只允许存放高16位数值 比如0xFFFF0000末四位补0 存入高四位0XFFFF\n2.Long型赋值 const-wide vx, lit32 表示将一个 32 位的常量存储到 vx 与 vx+1 两个寄存器中 —— 即一个 long 类型的数据\n1 2 3 4 5 6 7 .method public final vipEndTime()J .registers 3 const-wide v0, 0x1854460ef29L return-wide v0 .end method -会员到期时间就是2022年12月24日。那么1854460ef29L 怎么来的呢？也就是（2022年12月24日-1970年1月1日）×365天×24小时×60分钟×60秒×1000毫秒，转换成16进制就大概是那个数了\n在线时间戳转换\n3.变量赋值(正则) 1 2 3 4 5 6 7 8 9 10 11 12 iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V *. ** 这个表示任意寄存器，什么寄存器都能匹配，所以你正则查找的时候只需把寄存器替换成这个就可以了 (.*) 这里多了个英文小括号，框哪个就是对哪个寄存器赋值。 参考文章：\nAPK 签名：v1 v2 v3 v4 如何把签名校验做到极致 Android PMS HOOK [实战破解]白描-动态代{过}{滤}理Hook签名校验 [原创]对安卓反调试和校验检测的一些实践与结论 新版MT去签及对抗 【小白教程】正则匹配的写法 多行匹配 批量赋值 smali逆向 简单实用\n逆向之Smali入门学习\n","date":"2025-07-20T12:02:51+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124723.png","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%9B%9B/","title":"安卓逆向入门四"},{"content":"安卓逆向入门三 学习关键词: Jeb、动态调试、Log插桩\n学习链接：《安卓逆向这档事》五、1000-7=？\u0026amp;动态调试\u0026amp;Log插桩\nJEB学习 环境配置\nJava环境配置，我这里不细讲。没有配置过java环境的我建议去看看 多个 JDK 版本（Java 8、Java 17、Java 21）下载和切换 这篇文章，我的建议是一开始就做好java多版本共存的准备 下载JEB\nJEB (Java Editor for Android) 是一款用于安卓应用逆向工程的工具，它可以帮助开发者分析和修改安卓应用的字节码。\njeb推荐jdk-11或jdk-17（我用的是jdk-11）\n下载教程可以看这篇文章：JEB动态调试Smali-真机/模拟器（详细，新手必看）\n本次学习下载正己提供的jeb安装包，下载好就可以使用，如果需要激活就去看上面的文章\n动态调试 熟悉IDA的逆向人应该知道动态调试是什么，这里指的是Android动态调试，\n修改方法：\n修改debug权限 **方法一:**在AndroidManifest.xml里添加可调试权限\n1 android:debuggable=\u0026#34;true\u0026#34; **方法二：**XappDebug模块hook对应的app\n**方法三：**Magisk命令(重启失效)\n1 2 3 4 5 6 7 1. adb shell #adb进入命令行模式 2. su #切换至超级用户 3. magisk resetprop ro.debuggable 1 4. stop;start; #一定要通过该方式重启 **方法四:**刷入MagiskHide Props Config模块\n一般来说，在4选项中如果有ro.debuggable那就直接修改\n没有的话就选5\n端口转发以及开启adb权限 版本号点击七次开启开发者模式并开启adb调试权限 有时候重新进入模拟器的时候usb调试会取消，需要手动开启 下断点 ctrl+b下断点\ndebug模式启动 1 adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity adb shell am start -D -n adb shell am start -D -n 包名/类名 am start -n 表示启动一个activity am start -D 表示将应用设置为可调试模式\nJeb附加调试进程 常用快捷键： F6 进入方法 F6 跳过方法 F7 从方法中跳出来 R 运行到光标处\n运行到断点 步进 得到参数值：5qKA5q61DAUM\nLog插桩 定义：Log 插桩是在反编译 APK 后的 Smali 代码中插入日志输出语句，通过Log.v()等方法将关键变量、函数调用过程打印到系统日志，适用于无法动态调试或需要追踪后台逻辑的场景。\n1 invoke-static {对应寄存器}, Lcom/mtools/LogUtils;-\u0026gt;v(Ljava/lang/Object;)V 在应用里随机输入字符串，然后查看日志 ","date":"2025-06-26T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124652.png","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B8%89/","title":"安卓逆向入门三"},{"content":"0x00 smali及其语法 smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 Smali是Dalvik虚拟机和ART运行时的寄存器指令语言，相当于Android平台的汇编语言。当APK被反编译时，DEX文件会转换为Smali代码（.smali文件），它是逆向分析的核心载体。\n关键字\n名称 注释 .class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应\nsmali类型 java类型 注释 V void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx/xxx/xxx object 对象类型，返回对象 常用指令\n关键字 注释 const 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a=b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!=b)，ab内容不相同则跳 if-eqz 全称equal zero(a=0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!=0)，a不等于0则跳 if-ge 全称greater equal(a\u0026gt;=b)，a大于或等于则跳 if-le 全称little equal(a\u0026lt;=b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 “vip终结者” 定位方法：\n搜索弹窗关键字（用jd-gui搜索字符串）、抓取按钮id（本质与前一个方法一样）\n（字符串有时候是用unicode显示，搜关键文字搜不到的话可以试试搜对应的unicode）\n（此处演示的是抓取按钮id）\n修改方法：\n修改判断、强制跳转、修改寄存器的值 (这里与反调试中修改标志位或者修改跳转指令类似)\ndemo代码例子（注释为正己所写）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //一个私有、静态、不可变的方法 方法名 .method private static final onCreate$lambda-2(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z //(这里面是方法的参数)这里是方法返回值类型，表示布尔值类型，返回假或真 .registers 7 //寄存器数量 .line 33 //代码所在的行数 iget p0, p0, Lkotlin/jvm/internal/Ref$IntRef;-\u0026gt;element:I //读取p0(第一个参数，参考寄存器知识)中element的值赋值给p0 const/4 p5, 0x1 //p5赋值1 const/16 v0, 0xa //v0赋值10，在16进制里a表示10 if-ge p0, v0, :cond_15 //判断p0的值是否大于或等于v0的值(即p0的值是否大于或等于10)，如果大于或等于则跳转到:cond_15 .line 34 //以下是常见的Toast弹窗代码 check-cast p1, Landroid/content/Context; //检查Context对象引用 const-string p0, \u0026#34;请先获取10个硬币哦\u0026#34; //弹窗文本信息，把\u0026#34;\u0026#34;里的字符串数据赋值给p0 check-cast p0, Ljava/lang/CharSequence; //检查CharSequence对象引用 invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; //将弹窗文本、显示时间等信息传给p1 move-result-object p0 //结果传递给p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V //当看到这个Toast;-\u0026gt;show你就应该反应过来这里是弹窗代码 goto :goto_31 //跳转到:goto_31 :cond_15 //跳转的一个地址 invoke-virtual {p1}, Lcom/zj/wuaipojie/ui/ChallengeSecond;-\u0026gt;isvip()Z //判断isvip方法的返回值是否为真(即结果是否为1) move-result p0 //结果赋值给p0 if-eqz p0, :cond_43 //如果结果为0则跳转cond_43地址 const p0, 0x7f0d0018 //在arsc中的id索引，这个值可以进行查询 .line 37 invoke-virtual {p2, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V //设置图片资源 const p0, 0x7f0d0008 .line 38 invoke-virtual {p3, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V const p0, 0x7f0d000a .line 39 invoke-virtual {p4, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V .line 40 sget-object p0, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/SPUtils; check-cast p1, Landroid/content/Context; const/4 p2, 0x2 //p2赋值2 const-string p3, \u0026#34;level\u0026#34; //sp的索引 invoke-virtual {p0, p1, p3, p2}, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;saveInt(Landroid/content/Context;Ljava/lang/String;I)V //写入数据 goto :goto_50 //跳转地址 :cond_43 check-cast p1, Landroid/content/Context; const-string p0, \u0026#34;\\u8bf7\\u5148\\u5145\\u503c\\u5927\\u4f1a\\u5458\\u54e6\\uff01\u0026#34; //请先充值大会员哦！ check-cast p0, Ljava/lang/CharSequence; invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V :goto_50 return p5 //返回p5的值 .end method //方法结束 //判断是否是大会员的方法 .method public final isvip()Z .registers 2 const/4 v0, 0x0 //v0赋值0 return v0 //返回v0的值 .end method 寄存器机制 命名规则：v0-vN 本地寄存器，p0-pN 参数寄存器 关键特性： 非静态方法中 p0 固定表示this指针 静态方法中 p0 对应第一个参数 64位类型(long/double)占用两个连续寄存器（如v0-v1） 这里可以切换成Smali语言（但是java代码更好看一点）\n0x02 activity的切换 组件 描述 Activity(活动) 在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。 Service(服务) Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。 Broadcast Receiver(广播接收器) 一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。 Content Provider(内容提供者) 作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等） 广告拦截实战 启动广告流程： 启动Activity-\u0026gt;广告Activity-\u0026gt;主页Activity\n修改方法：\n1.修改加载时间\n此小节中用到了mt管理器的Activity管理器，可以用于记录广告用到的AdActivity类 然后通过类名搜索可以定位到代码位置\n转换成java 阅读java代码，然后可以知道有一个3000毫秒广告显示时间，退回到smali代码中修改为零即可。\n2.Acitivity切换定位，修改Intent的Activity类名（直接在AndroidManifest.xml文件中修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 \u0026lt;activity\u0026gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----\u0026gt; \u0026lt;activity android:label=\u0026#34;@string/app_name\u0026#34; android:name=\u0026#34;com.zj.wuaipojie.ui.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动--\u0026gt; \u0026lt;!---指明这个activity可以以什么样的意图(intent)启动---\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFirst\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFifth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFourth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeThird\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeSecond\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.AdActivity\u0026#34; /\u0026gt; ​\n3.在classes.dex文件中查找并修改\n图一为之前的查找内容，图二是类的一个smali路径代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 switch (position) { case 0: Intent intent = new Intent(); intent.setClass(it.getContext(), ChallengeFirst.class); it.getContext().startActivity(intent); return; case 1: Intent intent2 = new Intent(); intent2.setClass(it.getContext(), ChallengeSecond.class); it.getContext().startActivity(intent2); return; case 2: Intent intent3 = new Intent(); //new一个Intent， intent3.setClass(it.getContext(), AdActivity.class); //传入要切换的Acitivity的类名 it.getContext().startActivity(intent3); //启动对应的Activity return; case 3: Intent intent4 = new Intent(); intent4.setClass(it.getContext(), ChallengeFourth.class); it.getContext().startActivity(intent4); return; default: return; } 0x03 Activity生命周期 函数名称 描述 onCreate() 一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。 onStart() 当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。 onResume() 这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。 onPause() 这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。 onStop() 这个方法是在Activity完全不可见的时候调用的。 onDestroy() 这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。 onRestart() 当Activity从停止stop状态恢进入start状态时调用状态。 0x04 弹窗定位\u0026amp;堆栈分析 修改方法： 1.修改xml中的versioncode 2.Hook弹窗(推荐算法助手开启弹窗定位) 这里demo中的广告返回键被劫持，只能跟着广告走，就需要hook\n3.修改dex弹窗代码 在算法助手里找到最新的日志，找到对应打方法名，然后搜索查找对应-\u0026gt;show()代码，删掉或者注释掉就行\n4.抓包修改响应体(也可以路由器拦截) 0x05 布局优化 1.开发者助手抓布局 2.MT管理器xml搜索定位 3.修改xml代码 用的软件：开发助手（可以识别到图片信息），通过搜索Veiw id（hex），可以查找到对应的xml文件，注意这里是xml文件不是之前的dex文件里搜索。 此处既可以修改图片显示的长宽，也可以通过加入下面这段代码隐藏（布局隐藏，文字图片都可以隐藏）。\n1 android:visibility=\u0026#34;gone\u0026#34; ","date":"2025-06-01T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250601010933131.png","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%BA%8C/","title":"安卓逆向入门二"},{"content":"热身题 re1 flag{1c98572d-7f7b-4fbf-8750-4a2986c695ce}\n注意到如下代码是关键：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 v29 = *(_WORD *)v16; v30 = sub_7FF7D5E81800(v4, 1i64); if ( !v30 ) sub_7FF7D5E9AFA0(1i64, v4); v31 = (_BYTE *)v30; for ( i = 0i64; i != v4; ++i ) { HIWORD(v33) = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1); LOWORD(v33) = v29; v29 = v33 \u0026gt;\u0026gt; 1; v34 = __ROL1__(v33, 4); v35 = (4 * (v34 \u0026amp; 0x33)) | (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33; v31[i] = *(_BYTE *)(v16 + i) ^ (i + ((2 * (v35 \u0026amp; 0x55)) | (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)); } if ( v4 == 42 \u0026amp;\u0026amp; !memcmp(v31, \u0026amp;unk_7FF7D5E9C458, 42ui64) ) { sub_7FF7D5E817E0(v31, 42i64, 1i64); v39 = \u0026amp;off_7FF7D5E9C4A0; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } else { sub_7FF7D5E817E0(v31, v4, 1i64); v39 = (void **)\u0026amp;off_7FF7D5E9C488; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } 其实就是对输入做了xor，用的序列也是由输入的前两个字节+下标生成，那么z3就是一个很自然的想法。偷懒用AI写的代码。注意需要限制开头字符是flag才能解出唯一解，或者用cfbb的这个办法获取所有解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from z3 import * def rol1_byte(value: int, shift: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Rotate left 1 byte (8 bits) with carry-over\u0026#34;\u0026#34;\u0026#34; shift %= 8 return ((value \u0026lt;\u0026lt; shift) | (value \u0026gt;\u0026gt; (8 - shift))) \u0026amp; 0xFF def transform_data(input_data: bytes) -\u0026gt; bytearray: \u0026#34;\u0026#34;\u0026#34; Replicates the transformation logic from the original code: - Processes each byte with a custom bit manipulation algorithm - Uses a rolling state (v29) that affects subsequent bytes - Applies XOR with transformed index values \u0026#34;\u0026#34;\u0026#34; n = len(input_data) output = bytearray(n) v29 = (input_data[1] \u0026lt;\u0026lt; 8) | input_data[0] for i in range(n): # HIWORD/LOWORD simulation (assuming v33 is 32-bit) hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = (hiword \u0026lt;\u0026lt; 16) | (loword \u0026amp; 0xFFFF) v29 = v33 \u0026gt;\u0026gt; 1 # Bit manipulation steps v34 = rol1_byte(v33 \u0026amp; 0xFF, 4) # __ROL1__(v33, 4) v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # Final XOR operation transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) output[i] = input_data[i] ^ (transformed_index \u0026amp; 0xFF) return output # 目标密文 Buf2 = bytes([ 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B ]) # 创建 Z3 求解器 solver = Solver() # 定义输入变量（每个字节是一个 8 位无符号整数） input_bytes = [BitVec(f\u0026#39;byte_{i}\u0026#39;, 8) for i in range(len(Buf2))] # 初始化状态变量 v29 (32-bit) #v29 = BitVecVal(0, 32) v29 = Concat(input_bytes[1], input_bytes[0]) for i in range(len(Buf2)): # HIWORD/LOWORD 计算 hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = Concat(Extract(15, 0, hiword), Extract(15, 0, loword)) # 更新 v29 v29 = v33 \u0026gt;\u0026gt; 1 # ROL1(v33, 4) - 取最低字节并循环左移4位 v34_lowbyte = Extract(7, 0, v33) v34 = RotateLeft(v34_lowbyte, 4) # v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # 修正后的计算方式： part1 = (v34 \u0026amp; 0x33) \u0026lt;\u0026lt; 2 part2 = (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33 v35 = part1 | part2 # transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) part_a = (v35 \u0026amp; 0x55) \u0026lt;\u0026lt; 1 part_b = (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55 transformed_index = i + (part_a | part_b) # 添加约束：input_byte ^ (transformed_index的低8位) == cipher_byte solver.add(input_bytes[i] ^ Extract(7, 0, transformed_index) == Buf2[i]) # 检查是否有解 solver.add(input_bytes[0] == ord(\u0026#39;f\u0026#39;)) solver.add(input_bytes[1] == ord(\u0026#39;l\u0026#39;)) solver.add(input_bytes[2] == ord(\u0026#39;a\u0026#39;)) solver.add(input_bytes[3] == ord(\u0026#39;g\u0026#39;)) def get_models(s, count = 1): result = [] while len(result) \u0026lt; count and s.check() == sat: m = s.model() sol = bytes([m[input_bytes[i]].as_long() for i in range(len(Buf2))]) result.append(sol) # Create a new constraint the blocks the current model block = [] for d in m: # d is a declaration if d.arity() \u0026gt; 0: raise Z3Exception(\u0026#34;uninterpreted functions are not supported\u0026#34;) # create a constant from declaration c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception(\u0026#34;arrays and uninterpreted sorts are not supported\u0026#34;) block.append(c != m[d]) s.add(Or(block)) return result m = get_models(solver, 1000) print(m) 补一个c语言脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { unsigned char output[42] = { 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B }; unsigned char input[42] = { 0 }; input[0] = \u0026#39;f\u0026#39;; input[1] = \u0026#39;l\u0026#39;; uint16_t v29 = (input[1] \u0026lt;\u0026lt; 8) | input[0]; for (int i = 0; i \u0026lt; 42; ++i) { uint32_t v33= (((v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1)) \u0026lt;\u0026lt; 16) | v29; v29 = (v33 \u0026gt;\u0026gt; 1) \u0026amp; 0xFFFF; uint8_t v34 = ((v33 \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | ((v33 \u0026amp; 0xFF) \u0026gt;\u0026gt; 4); // 循环左移4位 uint8_t v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33); uint8_t combined = (2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55); uint8_t index = (i + combined) \u0026amp; 0xFF; input[i] = output[i] ^ index; } for (int i = 0; i \u0026lt; 42; ++i) { printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } re2 flag{cdb0444318e24beb8f374e9181599072}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { uint8_t v8[16] = { 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 }; uint8_t v9[16] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10 }; const char* target = \u0026#34;cge87k?9\u0026lt;\u0026gt;?@=pss393=\u0026gt;;8@:Cp@DAuH\u0026#34;; uint8_t enc[32]; memcpy(enc, target, 32); uint8_t flag[33]; for (int i = 0; i \u0026lt; 32; i += 16) { // 先减去v9[j] for (int j = 0; j \u0026lt; 16; j++) { flag[i + j] = enc[i + j] - v9[j]; } // 反转块以实现逆置换 for (int j = 0; j \u0026lt; 8; j++) { int pos1 = i + j; int pos2 = i + 15 - j; uint8_t temp = flag[pos1]; flag[pos1] = flag[pos2]; flag[pos2] = temp; } } flag[32] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;flag{%s}\\n\u0026#34;, flag); return 0; } //flag{cdb0444318e24beb8f374e9181599072} 很简单的一道题，唯一就是涉及到一定的sse语句\n","date":"2025-05-30T23:34:46+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/a0457db2a018c2ee683618e3e5a3b90e_720.jpg","permalink":"https://fanshanng.cn/p/%E4%BA%AC%E9%BA%92ctf-2025%E5%A4%8D%E7%9B%98%E4%B8%AD/","title":"京麒ctf 2025（复盘中）"},{"content":"hook随记 此文目前为摘录他人\nhook（钩子）是一种编程机制，在操作系统、编程里也会用到。\nhook的作用是让程序能够在特定事件发生时插入自定义代码，或者对系统行为进行拦截和修改。它是一种软件设计模式，借助预留接口，实现对系统或框架原有流程的扩展与增强。\nJava中有一种机制，叫做动态代理（Dynamic Proxy），它可以被视为一种特殊的运行时钩子（Runtime Hook），因为它允许你在不修改原有代码的情况下，拦截并增强对象方法的调用。\n在编程中，Hook（钩子）的本质是一种 “程序拦截机制”，它允许你在不修改原始代码的前提下，介入并改变程序的执行流程。这种机制通过注入自定义逻辑到现有系统的特定点来实现增强或修改功能的目的。\n以JavaScript为例， 源代码\n1 2 3 4 5 6 function add(a,b){ return a + b } res = add(1,3) console.log(\u0026#34;结果: \u0026#34; + res) 结果显而易见，是4.\n但是，我们想在不改变调用的情况下，在执行add方法时，在其前面打印”add方法执行“，结束时打印”add方法结束“，并让返回的结果+1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function add(a, b) { return a + b; } const hook = { originalAdd: add // 立即保存引用 }; // 重新定义add函数 add = function(a, b) { console.log(\u0026#34;add方法调用前\u0026#34;); let res = hook.originalAdd(a, b); console.log(\u0026#34;add方法调用后\u0026#34;); return res + 1; }; let res = add(1, 3); console.log(\u0026#34;结果: \u0026#34; + res); // 输出5 结果如图：\n调用的代码并未变化，但是结果发声改变了。 上述的案例就是一个hook的过程。 它先将原函数对象的引用（即内存地址）保存起来，然后在新函数中调用原add函数，最后令add指向一个新函数。\n","date":"2025-05-30T10:26:28+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/1.jpg","permalink":"https://fanshanng.cn/p/hook/","title":"Hook"},{"content":"安卓逆向入门一 0x01 前置 下载migisk\nMagisk（俗称面具），是一个ROOT工具。\n它提供了多种功能，包括但不限于： 1 2 3 4 MagiskSU: 提供应用程序的 root 访问权限。 Magisk 模块: 通过安装模块来修改只读分区。 MagiskBoot: 用于解包和重新打包 Android 启动镜像的最完整工具。 Zygisk: 在每个 Android 应用程序的进程中运行代码。 不要去Magisk中文网,这里用的是正己提供的安装包\n这里如果下载失败的话，可以去设置里修改下图选项\n0x02 apk的文件结构 Apk结构 apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。\n文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidManifest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 demo实例中另外出现的kotlin代表这个apk文件大概是有kotlin语言编写，OkHttp 是一个流行的开源 HTTP 客户端库，用于发送和接收网络请求。 Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。\nKotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\n在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。\n0x03 双开及原理 指手机同时运行两个或多个相同的应用\n【VirtualAPP 双开系列08】如何实现多开 - UID\n通过在宿主容器上面新建一个进程供插件 APK 寄宿，然后通过 hook 一些系统接口欺骗应用—让虚拟化后应用以为自己是正常运行的独立 APP，欺骗系统—让系统认为此虚拟化应用是一个已正常安装在系统的应用。\n原理 解释 修改包名 让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 修改Framework 对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 通过虚拟化技术实现 虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 以插件机制运行 利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 0x04 汉化APK 1.Arsc汉化\n2.xml汉化\n3.Dex汉化 (教程里的汉化插件需要vip，我这里是手动改的，知道原理就行)\n教程中用到的主要就是在mt管理器或者np管理器中对文件进行字符串搜索（管理器中设置了自动签名），如果手动的话，可以反编译改源码等 apk安装包快速反编译，多种反编译及失败的解决方案\n这是汉化前⬇\n这是汉化（手改）后⬇\n0x05 初识AndroidManifest.xml AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。\n注：这里文件名不能修改\nAndroidManifest.xml 最全详解 AndroidManifest.xml文件主要包含以下几个元素：\n元素 功能描述 action 添加一个action到intent filter activity 声明 activity组件 activity-alias 声明activity别名 application 声明应用程序 category 添加一个category名称到intent filter compatible-screens 定义应用所兼容的每种屏幕配置 data 添加数据定义到intent filter grant-uri-permission 定义应用数据的子集以供父内容提供者有权限可以访问 instrumentation 声明Instrumentation工具类并是您可以监控应用程序的交互系统 intent-filter 定义activity、service或者是broadcast receiver可以响应的意图（intent）类型， manifest AndroidManifest.xml文件中的根元素 meta-data 一条额外添加的名称-值对，可以给父组件提供任意的数据。 path-permission 在content provider内定义所需路径和权限特定子集数据 permission 声明一个安全权限，可以用来限制访问特定应用的组件或功能 permission-group 声明一个相关权限的逻辑组名称 permission-tree 声明权限树的基础名称 provider 声明一个内容提供者(content provider)组件 receiver 声明一个广播接收器(broadcast receiver)组件 service 声明一个服务(service)组件 supports-gl-texture 声明一种应用单一支持的GL纹理(texture)压缩格式 supports-screens 声明应用所支持的屏幕尺寸大小以及在启用兼容模式下系统屏幕超出应用所支持的尺寸 uses-configuration 声明应用程序的软硬件需求 uses-feature 声明应用程序需要用到的软、硬件特性。 uses-library 指定应用程序必须引用的共享库 uses-permission 指定了让应用程序正常运行，用户必须授予的系统权限。 uses-permission-sdk-23 指定了应用程序在Android 6.0以上所需的特定权限 uses-sdk 通过API整数值来声明应用程序所兼容的Android平台版 MT管理器使用手册\nAndroid逆向0基础入门-APK全面解析,动调与脱壳\n","date":"2025-05-25T16:15:22+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/preview.jpg","permalink":"https://fanshanng.cn/p/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E4%B8%80/","title":"安卓逆向学习一"},{"content":"并非是wp，而是做题过程中的一些记录\nluck_guy 主函数 ①.Case2 和 case3 只是一个打印函数。 ②.strcat 是连接字符串函数，所以 case4 是对 s 赋值并将 s 与 f2 进行拼接。 ③.case5 是对 f2 进行处理：j 为奇数，f2 减 2；j 为偶数，f2 减 1。 ④.Case1 是要得到 flag，首先memset函数先对 s 进行初始化，s 变成了一个空数组，所以之后的 strcat 函数相当于直接把 f1 复制到了 s 里，再之后的 strcat 函数将 s 与 f2 连接相当于 f1 与 f2 连接，最终打印出来的 flag 就是 f1 加上 f2。 s=0x7F666F6067756369LL，按r键将它转换为字符就是“\\x7Ffo`guci”，这里要注意是小端序存储！所以要把字符顺序反过来，就是“icug`of\\x7F” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char f2[] = \u0026#34;icug`of\\x7F\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j) { if ( j % 2 == 1 ) f2[j]-=2; else f2[j]--; } printf(\u0026#34;%s\u0026#34;,f2); return 0; } 刮开有奖 加密逻辑其实挺清晰的一道题，快速排序+base64编码，快速排序这里不懂的话可以去问ai，不过还是要自己判断，也可以把代码复制下来在vscode中运行一遍看看结果 但是第一次疑惑的地方是加密排序那个数组a1只初始化了两个数，但是它的结束索引却是十。这里学到的知识是：\n根据这段初始化，知道这段的地址是连续的。所以实际上是一个长度为11的数组，别问我为什么不动调，F9点开后调不了一点 然后就是\n对比判断的时候这里用的是地址处的值也就是说是排序后的值\n然后要提一嘴的是\n具体可以去看这里 WinMain函数 （winbase.h） WinMain 函数（Windows图形应用程序入口点）\n1 2 3 4 5 6 int __clrcall WinMain( [in] HINSTANCE hInstance, [in, optional] HINSTANCE hPrevInstance, [in] LPSTR lpCmdLine, [in] int nShowCmd ); 参数： hInstance：当前应用程序实例的句柄。 hPrevInstance：上一个实例的句柄（在现代Windows中始终为NULL）。 lpCmdLine：命令行参数，不包括程序名称。 nShowCmd：控制窗口显示方式的标志。 返回值：程序的退出状态码，通常返回 WM_QUIT 消息的 wParam 参数值。\neasyre 脱壳后的主函数 分析比较语句，大致猜到v5就是输入的函数，这里的意思是输入字符的ascii值+1后作为索引进行判断\npython中的find()函数是找到对应的下标值 1 2 3 4 5 6 7 8 9 10 11 12 U U9 U9X U9X_ U9X_1 U9X_1S U9X_1S_ U9X_1S_W U9X_1S_W6 U9X_1S_W6@ U9X_1S_W6@T U9X_1S_W6@T? [GUET-CTF2019]re 考z3处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from z3 import * solver = Solver() # 使用Int类型而非BitVec，并添加字符范围约束 a1 = [Int(f\u0026#39;a1_{i}\u0026#39;) for i in range(32)] # 添加所有等式约束 solver.add(1629056 * a1[0] == 166163712) solver.add(6771600 * a1[1] == 731332800) solver.add(3682944 * a1[2] == 357245568) solver.add(10431000 * a1[3] == 1074393000) solver.add(3977328 * a1[4] == 489211344) solver.add(5138336 * a1[5] == 518971936) solver.add(7532250 * a1[7] == 406741500) solver.add(5551632 * a1[8] == 294236496) solver.add(3409728 * a1[9] == 177305856) solver.add(13013670 * a1[10] == 650683500) solver.add(6088797 * a1[11] == 298351053) solver.add(7884663 * a1[12] == 386348487) solver.add(8944053 * a1[13] == 438258597) solver.add(5198490 * a1[14] == 249527520) solver.add(4544518 * a1[15] == 445362764) solver.add(3645600 * a1[17] == 174988800) solver.add(10115280 * a1[16] == 981182160) solver.add(9667504 * a1[18] == 493042704) solver.add(5364450 * a1[19] == 257493600) solver.add(13464540 * a1[20] == 767478780) solver.add(5488432 * a1[21] == 312840624) solver.add(14479500 * a1[22] == 1404511500) solver.add(6451830 * a1[23] == 316139670) solver.add(6252576 * a1[24] == 619005024) solver.add(7763364 * a1[25] == 372641472) solver.add(7327320 * a1[26] == 373693320) solver.add(8741520 * a1[27] == 498266640) solver.add(8871876 * a1[28] == 452465676) solver.add(4086720 * a1[29] == 208422720) solver.add(9374400 * a1[30] == 515592000) solver.add(5759124 * a1[31] == 719890500) # 确保每个字符在0-255范围内（ASCII） for c in a1: solver.add(c \u0026gt;= 0, c \u0026lt;= 255) if solver.check() == sat: model = solver.model() flag = \u0026#39;\u0026#39;.join([chr(model[c].as_long()) for c in a1]) # type: ignore print(\u0026#34;\u0026#34;, flag) else: print(\u0026#34;无解\u0026#34;) # flag{e65421110ba03099a1c039337} 但是疑惑的是少了一位，最后看别人题解都是爆破出来的（，a1[6]=\u0026lsquo;1\u0026rsquo;, 所以正确的应该是flag{e165421110ba03099a1c039337}\nCrackRTF 这道题的考点是rtf文件,主要的逻辑是先输入六个数字拼接@DBApp然后判断hash-sha1编码，这里爆破出的结果是123321，然后是长度为6的字符串，拼接在一起进行MD5编码，由于MD5编码不可逆，我尝试过爆破，生成所有 6 位组合，总数为 95^6 ≈ 735 亿次，遂放弃。\nRTF是Rich Text Format的缩写，意即多文本格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 char __cdecl sub_4014D0(LPCSTR Destination) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026#34;AAA\u0026#34;);// FindResourceA 函数用于查找程序资源中的一个资源。 // 第一个参数为 NULL，表示查找当前进程的资源。 // 第二个参数为资源标识符，这里是 0x65。 // 第三个参数为资源类型，这里是 \u0026#34;AAA\u0026#34;。 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo);// SizeofResource 函数用于获取资源的大小。 // 如果资源大小为 0，表示资源无效。 hResData = LoadResource(0, hResInfo); // LoadResource 函数用于加载资源。 if ( !hResData ) return 0; lpBuffer = LockResource(hResData); // LockResource 函数用于锁定资源，并返回资源的指针。 sub_401005(Destination, (int)lpBuffer, nNumberOfBytesToWrite);// 异或 hFile = CreateFileA(\u0026#34;dbapp.rtf\u0026#34;, GENERIC_ALL, 0, 0, CREATE_ALWAYS, FILE_READ_ATTRIBUTES, 0);// CreateFileA 函数用于创建或打开一个文件。 // 文件名为 \u0026#34;dbapp.rtf\u0026#34;。 // 打开模式为 CREATE_ALWAYS，表示如果文件不存在则创建，如果存在则覆盖。 // 文件访问权限为 GENERIC_ALL，表示完全访问权限。 if ( hFile == (HANDLE)-1 ) // 如果文件创建失败，返回 0。 return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); // 关闭文件句柄。 return 1; } 这里就是我们输入的东西拼接后与“AAA”文件中的读取的前几位异或\n从网上找到rtf的示例文件下下来对比发现前几位都是一样的\n把前几位截下来，然后进行异或处理就能得到前六位~!3a@0123321,很明显**~!3a@0**为所求。于是在ida中动调，生成rtf文件，打开后得到flag ","date":"2025-05-22T21:08:17+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/2.jpg","permalink":"https://fanshanng.cn/p/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/","title":"Buuctf刷题记录"},{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-19T00:15:39+08:00","image":"https://img.scwcd.cn/markdown/27lh0p36.jpg","permalink":"https://fanshanng.cn/p/frida/","title":"Frida"}]