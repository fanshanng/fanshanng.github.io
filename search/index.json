[{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签 Frida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-18T23:49:23+08:00","permalink":"https://fanshanng.github.io/p/asasas/","title":"Asasas"},{"content":"","date":"2025-05-18T23:38:28+08:00","permalink":"https://fanshanng.github.io/p/new/","title":"New"},{"content":"111111111111111111111111111111111111111111111111111111111111111111111\n","date":"2025-05-18T18:30:38+08:00","permalink":"https://fanshanng.github.io/p/second/","title":"Second"},{"content":"test test1 ","date":"2025-05-18T18:27:08+08:00","permalink":"https://fanshanng.github.io/p/%E4%BB%8A%E6%97%A5%E6%B5%8B%E8%AF%95/","title":"今日测试"},{"content":"hello world ","date":"2025-05-14T22:23:13+08:00","permalink":"https://fanshanng.github.io/p/test/","title":"Test"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://fanshanng.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://fanshanng.github.io/p/test-chinese/","title":"Chinese Test"}]