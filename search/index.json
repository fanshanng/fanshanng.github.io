[{"content":"软件逆向工程组会：IDA 常见操作与基础知识 面向课程与安全研究，请遵守所在地法律与软件授权。涉及下载/外链：按授权使用或选开源替代（Ghidra/Cutter）。\n一、核心认知：IDA 作用与逆向目标 1.1 IDA Pro 定位 IDA Pro 是逆向工程核心工具，支持将二进制文件（exe/so/elf/dll）反汇编为汇编代码并生成伪代码，辅助解析程序逻辑。\n1.2 逆向入门核心目标 将 “不可读的二进制文件” 转化为 “可理解的逻辑”，具体包括：\n定位程序入口（主函数）；\n识别关键逻辑（验证、加密等）；\n修改程序行为（Patch 操作）；\n跟踪运行流程（动态调试）。\n二、环境准备：IDA工具安装 IDA Pro 版本：推荐 9.1/9.2（稳定性与新功能兼顾），需匹配样本位数（32 位 / 64 位）；\n通过网盘分享的文件：IDA Professional 9.1.7z 链接: https://pan.baidu.com/s/1yrROk_2y_jpwky_AsaOQSw?pwd=f4ns 提取码: f4ns\n通过网盘分享的文件：ida9.2.zip 链接: https://pan.baidu.com/s/1YInTZr7qnGNMLvqz9b-5ZQ?pwd=f4ns 提取码: f4ns\nIDA 9.2的官方文档\n三、核心操作：静态分析（逆向基础） 静态分析无需运行程序，直接通过 IDA 解析代码逻辑，是逆向的核心环节。\n3.1 视图切换与高频快捷键（分类汇总） 功能类型 快捷键 作用说明 视图切换 tab 汇编视图 ↔ 伪代码视图（核心切换方式） 空格 text view（文本视图） ↔ graph view（图表视图） 导航类 G 跳转至指定地址（需输入目标地址） Alt+T 全局文本搜索（搜指令、字符串、函数名） 编辑类（汇编） ;（分号） 为汇编指令添加注释（便于后续回溯） U Undefine：将代码转换为 “数据”（处理花指令） C Code：将数据转换为 “代码”（恢复误判代码） 编辑类（伪代码） N 变量 / 函数重命名（如 sub_401000 → main） Y 修改变量 / 函数类型（如 void → int，识别 JNI） /（斜杠） 为伪代码添加多行注释（可读性优先） LazyIDA Ctrl+Alt+N 一键 NOP 选中代码（过反调、去花指令，基础功能） 函数 / 字符串 Shift+F12 打开字符串窗口（定位关键逻辑核心工具） ida9.2更新跳转 Ctrl-Alt-G 函数、局部类型、名称和段进行不区分大小写的搜索 重点提示：空格（视图切换）、G（地址跳转）、N/Y（伪代码编辑）、Shift+F12（字符串查询）为基础高频操作；LazyIDA 进阶功能见第四章专项。\n3.2 汇编界面操作要点 3.2.1 必认汇编指令（对应 C 语言逻辑） 汇编指令 核心作用 对应 C 语言场景 mov 数据赋值（mov a,b → a=b） 变量赋值（如 int a = b;） push/pop 栈操作（push：数据入栈；pop：数据出栈） 函数传参（参数入栈）、局部变量初始化（栈空间分配 / 释放） call 调用函数（call sub_401000 → 跳转到 sub_401000 执行） 函数调用（如 check_password (input);） ret 函数返回（从当前函数跳回调用处） 函数执行结束（return 语句） jmp 无条件跳转（jmp 0x401200 → 强制跳转到 0x401200） goto 语句（如 goto end;） je/jne 条件跳转（je：等于时跳；jne：不等于时跳） if-else（如 if (a==b) { \u0026hellip; } else { \u0026hellip; }）、循环 cmp 比较两个值（cmp a,b → 计算 a - b，仅置标志位不保存结果） if 判断的条件基础（如 if (a==b)、if (a\u0026gt;b) 的底层判断） jz 零标志位（ZF=1）时跳转（即上一步结果为 0 时跳） if (结果 == 0)（如 if (func_return == 0) { \u0026hellip; }） jnz 零标志位（ZF=0）时跳转（即上一步结果不为 0 时跳） if (结果！= 0)（如 if (func_return != 0) { \u0026hellip; }） test 按位与运算（不保存结果，仅置标志位），常用于判断是否为 0 if (变量 == 0)（如 test eax,eax → 判断 eax 是否为 0，对应 if (eax == 0)） and 按位与运算（a and b → 结果存回 a），可用于清零、保留特定位 按位与操作（如 a \u0026amp;= b;）、清零变量（如 a \u0026amp;= 0;） lea 计算有效地址（非加载数据），常用于取变量地址或简单计算 取变量地址（如 int *p = \u0026amp;a; → lea eax,[a]）、简单表达式计算（如 lea eax,[ebx+4] → eax = ebx + 4） add 加法运算（add a,b → a = a + b） 数值加法（如 a = a + b;） sub 减法运算（sub a,b → a = a - b） 数值减法（如 a = a - b;） xor 按位异或运算（a xor b → 结果存回 a），可用于清零、交换变量 按位异或操作（如 a ^= b;）、清零变量（如 xor eax,eax → eax = 0）、交换变量（无需临时变量） shr 逻辑右移（shr a,n → a 右移 n 位，高位补 0） 无符号数除法（如 a = a \u0026raquo; 1; → a = a / 2）、取高位字节 shl 逻辑左移（shl a,n → a 左移 n 位，低位补 0） 无符号数乘法（如 a = a \u0026laquo; 1; → a = a * 2）、低位字节赋值 leave 释放当前函数栈帧（等价于 mov esp, ebp; pop ebp），恢复调用者栈环境 函数执行结束前清理栈空间（对应 C 函数中局部变量销毁、栈帧恢复，通常紧跟在 return 前） nop 无操作（仅占用 1 个指令周期，不修改寄存器 / 内存） 代码字节对齐（编译器填充空白）、调试占位（预留指令位置）、延时（底层简单延时逻辑）、屏蔽无用指令（如破解时 nop 掉校验指令） 3.2.2 汇编界面核心操作 注释添加：选中目标指令，按「;」输入注释内容；\n关键词搜索：按「Alt+T」输入关键词（如 password,success），定位关键逻辑；\n交叉引用查询：选中函数名（如 sub_401000），按「Alt+F7」，查看调用该函数的指令位置。\n3.3 伪代码界面操作要点 伪代码可读性优于汇编，是逆向分析的主力视图。\n3.3.1 核心编辑操作 重命名（N）：选中默认名称（如 v1、sub_401000），按「N」输入有意义名称（如 input、check）；\n类型修改（Y）：选中变量 / 函数，按「Y」修改类型，例如：\nJNI 函数（so文件分析）：将 void __cdecl sub_10001234() 改为 JNIEXPORT jint JNICALL Java_com_example_Test_check(JNIEnv *env, jobject thiz, jstring input)，IDA 自动识别 JNI 参数；\n数组类型：将 int v2 改为 char v2[]，明确数组逻辑；\n注释添加：按「/」输入多行注释，补充逻辑说明（如 “密码验证核心逻辑，返回 1 表示验证通过”）。 3.3.2 伪代码生成失败解决 若提示 “Cannot generate pseudocode”，需修正 IDA 代码识别：\n切换至汇编视图，定位报错地址；\n选中误判为 “数据” 的代码段，按「U」（undefine）转为数据；\n重新选中目标段，按「C」（code）转为代码（按P识别成函数）；\n按「tab」切换回伪代码视图，即可正常生成。\n3.4 主函数定位方法（分场景） 场景 1：样本带符号（如调试版 exe/so） 一般主界面左侧就是函数列表，如果不存在就按「Shift+F3」打开函数列表；\n搜索目标函数名：C 语言程序搜 main/start，Windows GUI 程序搜 WinMain，Android so 搜 JNI_OnLoad；\n双击函数名跳转至主函数。\n场景 2：样本无符号（脱壳后 /release 版） 按「Shift+F12」打开字符串窗口，筛选关键字符串（如 “success”“right”“flag”）；\n右键选中目标字符串 → 「Jump to xref」（交叉引用 , 快捷键是[ x ]），跳转至引用该字符串的代码；\n向上追溯代码，找到 “调用次数最少、层级最顶层” 的函数（通常整个程序仅调用一次，且调用其他函数），即为主函数。\n场景 3：DLL/so 文件（导出函数） 按「Ctrl+I」打开导出表；\n筛选对外提供的函数（如 DLL 的 ExportFunc、so 的 Java_包名_类名_方法名）；\n此类导出函数为外部调用入口，等效于 DLL/so 的 “主函数”。\n重点提示：无符号样本优先使用「Shift+F12 找关键字符串」，为最高效的主函数定位方式。\n四、LazyIDA 专项速查 LazyIDA 是逆向高频操作的 “加速器”，以下按「快捷键」「右键菜单」「实操工作流」分类，覆盖地址处理、Patch、格式转换等核心场景（组会重点演示功能）。\n4.1 快捷键速查表（按视图 / 上下文分类） 快捷键 动作 作用说明 适用视图 / 上下文 备注 w Copy EA 复制当前地址到剪贴板（如：0x401000） 反汇编视图 / 转储视图 输出窗口会打印确认信息 Shift+G Goto clip EA 读取剪贴板地址 / 文本，打开 Lazy Jumper 窗口并跳转 反汇编视图 / 转储视图 支持 “新镜像基址 + 目标地址” 的无重定位跳转，Esc 关闭窗口 Ctrl+Alt+N NOP them 对选区批量写 NOP；无选区时对当前指令地址写 1 个 NOP 反汇编视图 输出区打印起止地址与字节数，比基础 Ctrl+N 更灵活 v Remove return type 把当前函数 / 调用点的返回类型临时改为 void（再次按可还原） Hex-Rays 伪代码视图 针对 VDI_FUNC / 函数指针调用生效 w（伪代码） Copy EA (Hex-Rays) 复制当前伪代码位置关联的 EA Hex-Rays 伪代码视图 与反汇编视图的 w 不冲突，各自生效 c（伪代码） Copy name 复制当前高亮名称（变量 / 函数名等） Hex-Rays 伪代码视图 取自 IDA 的 get_highlight () 接口 Shift+G（伪代码） Goto clip EA (Hex-Rays) 从剪贴板取地址并在 IDA 中跳转 Hex-Rays 伪代码视图 与反汇编视图的 Shift+G 行为一致 小技巧：Lazy Jumper 对话框中，按 Enter/Return 可触发跳转，Esc 关闭窗口，无需鼠标点击（组会实操演示重点）。\n4.2 右键菜单功能（按视图分类） 4.2.1 反汇编 / 转储视图（通用右键菜单） 菜单项 作用说明 备注 Paste Data 弹出 “粘贴数据” 窗口，支持 HEX / BASE64 / ASCII 三种输入并写回字节 适合快速打补丁，输入后点击 Apply 生效（组会实操演示） Lazy Dumper 弹出转储窗口：输入基址与大小，保存选定范围字节到文件 操作失败会在输出窗口提示原因 Lazy Jumper [Shift + G] 打开跳转窗口：输入新基址 / 目标地址，计算偏移后跳到当前 IDB 的等效位置 自动记忆历史基址，下次打开可快速复用 Copy RVA 计算并复制当前地址的 RVA（相对虚拟地址） 调试中按 “模块基址” 计算，非调试按 “imagebase” 计算 NOP them 与 Ctrl+Alt+N 功能一致：选区批量 NOP / 无选区单字节 NOP 快速过反调、去花指令（组会实操演示） Get xored data 选中一段代码→输入 0–255 的 XOR 值，输出异或后的文本 仅只读输出结果到输出窗口，不写回二进制文件 Fill with NOPs 把选区整段填充为 NOP 必须先框选代码段（单指令不生效），比 NOP them 更彻底 Convert/ → 格式选项 把选中字节转为指定格式：- 转义字符串- 十六进制串- C 数组（BYTE/WORD/DWORD/QWORD）- Python 列表（同上） 转换结果打印到 Output 窗口，需手动复制使用 注：Get xored data / Fill with NOPs / Convert/ 仅在 “存在选区” 或 “当前指令大小 \u0026gt; 1” 时显示。\n4.2.2 仅反汇编视图（特定架构专属菜单） 菜单项 作用说明 备注 Scan format string vulnerabilities 扫描 printf/sprintf/fprintf 等调用点，若格式串来自可写段则标记为 “可能漏洞”，列表展示可跳转 仅支持 x86 (32/64)、ARM32 架构，其他架构不挂载 4.2.3 Hex-Rays 伪代码视图（右键菜单） 菜单项 作用说明 备注 Remove return type 与快捷键 v 一致：临时将返回类型改为 void（再次点击还原） 针对复杂函数指针调用场景优化 Copy ea 与快捷键 w（伪代码）一致：复制当前伪代码关联的 EA 快速定位伪代码对应的汇编地址 Copy name 与快捷键 c（伪代码）一致：复制高亮的变量 / 函数名 避免手动输入名称，减少拼写错误 Goto clipboard ea 与快捷键 Shift+G（伪代码）一致：从剪贴板跳转地址 伪代码中快速跳转到外部引用的地址 双击增强：obj-\u0026gt;func () 表达式 自动解析并跳转到目标 func；若找不到则尝试 Class::func 命中时直接跳转，未命中无响应（需手动定位） 4.3 常见工作流 一键 NOP 某段代码： 框选目标代码段 → 右键点击「Fill with NOPs」（或按 Ctrl+Alt+N）→ 输出窗口确认 NOP 范围。\n（适用场景：批量去除花指令、跳过反调试检测代码）\n快速打补丁： 定位需修改的地址 → 右键「Paste Data」→ 选择输入格式（如 HEX）→ 粘贴修改后的字节（如将 74 改为 75，je 改 jne）→ 点击「Apply」→ 保存 Patch 后的文件。\n（适用场景：修改跳转条件、绕过验证逻辑）\n跨镜像基址跳转： 复制外部样本的目标地址（如 0x10001234）→ 在当前 IDA 按 Shift+G → Lazy Jumper 窗口输入 “新镜像基址（如 0x10000000）” 和 “目标地址（0x10001234）”→ 按 Enter 跳转。\n（适用场景：对比多个样本、分析脱壳后代码）\n五、Patch/Keypatch（修改程序逻辑） Patch 即 “二进制打补丁”，通过修改代码实现逻辑调整（如过反调、跳过验证），依赖 IDA+LazyIDA+Keypatch 组合（LazyIDA 负责高效操作，Keypatch 负责指令汇编）。\n5.1 Keypatch 插件安装 将 Keypatch 插件文件复制至 IDA 的 plugins 目录，重启 IDA 即可（与 IDA 9.1/9.2 兼容），功能为 “可视化修改汇编指令，无需手动计算机器码”。\n5.2 核心 Patch 操作（分场景） 场景 1：NOP 掉无用代码（基础版） （LazyIDA 已实现进阶批量 NOP，见第四章 4.3 工作流）\n适用场景：单指令 NOP、简单逻辑跳过；\n操作步骤：选中指令 → 按 Ctrl+N（LazyIDA 基础功能）→ 指令替换为 NOP。\n场景 2：修改指令（调整跳转条件） 适用场景：强制跳转至正确逻辑（如跳过验证失败分支）；\n操作步骤：\n在汇编视图选中待修改指令（如 je 0x401200）；\n右键 → 「Keypatch」→ 输入新指令（如 jmp 0x401300）；\n点击「Assemble」→ 「Patch file」→ 保存修改后的二进制文件。\n场景 3：恢复误判代码（U+C 组合） 适用场景：IDA 将正常代码误判为数据（显示为十六进制）；\n操作步骤：\n选中误判数据段，按「U」（undefine）转为数据；\n重新选中目标段，按「C」（code）转为代码；\n按「tab」切换回伪代码视图，恢复解析。\n5.3 地址跳转操作（G 快捷键 + Lazy Jumper） 基础跳转：已知地址（如 0x401100）→ 按「G」→ 输入地址跳转；\n进阶跳转：跨基址 / 剪贴板地址 → 按 W和Shift+G（Lazy Jumper）组合→ 输入参数跳转（见第四章 4.1）。\n六、动态调试：跟踪程序运行 动态调试通过运行程序、下断点，观察变量值与函数调用，精准定位核心逻辑。\n6.1 核心概念 断点：程序运行至指定位置暂停，便于观察；\n单步执行：暂停后逐行执行代码，跟踪变量变化；\n本地调试：在本地设备运行并调试程序；\n远程调试：调试其他设备（如 Linux 服务器、Android 手机）上的程序。\n6.2 断点类型对比（分场景选用） 断点类型 操作方式 原理 优点 缺点 软件断点 选中指令按「F2」 将指令替换为 int3（调试中断指令） 操作简单、无数量限制 易被程序检测（int3 为特征） 硬件断点 右键断点 → 「Edit breakpoint」→ 勾选「Hardware breakpoint」 利用 CPU 调试寄存器实现 隐蔽性强、不易被检测 数量有限（通常最多 4 个） 重点提示：新手优先使用软件断点（F2），遇到反调试检测时切换为硬件断点（组会实操演示）。\n6.3 Windows 平台调试（exe/dll） 6.3.1 本地调试步骤 IDA 加载 exe 文件，等待分析完成；\n按「F9」（Start process）启动程序（无断点时程序会直接运行结束）；\n在关键位置（如验证函数、字符串引用处）按「F2」下断点，程序运行至断点处自动暂停；\n单步操作：\nF7：单步步入（进入函数内部，如 call 指令时跟进）；\nF8：单步步过（不进入函数，直接执行完 call 指令）；\nF9：运行至当前函数结束（快速跳出函数）；\n变量观察：暂停时，鼠标悬停伪代码中的变量（如 input_pass），显示当前变量值（组会实操演示重点）。 6.3.2 附加进程调试（调试已运行程序） 确保目标程序已在本地运行；\nIDA 菜单栏 → 「Debugger」→ 「Attach」→ 「Local Process」；\n在进程列表中筛选目标程序（按名称检索），选中后点击「Attach」；\n按「F2」下断点，按「F9」恢复程序运行，触发断点后按单步操作调试。\n6.4 Linux 平台调试（elf/so） 6.4.1 远程调试步骤（如调试服务器 / 手机 so） 从本地 IDA 安装目录获取调试服务器：\n本地路径：E:\\IDA\\IDA Professional 9.2\\dbgsrv 选择对应版本：32 位样本用 linux_server，64 位样本用 linux_server（Android 对应 android_server/android_server32）； 将调试服务器文件复制到目标机的「调试样本同目录」；\n给调试服务器和样本文件加权（赋予执行权限）：\n1 2 chmod 777 linux_server # 调试服务器加权 chmod 777 test.exe # 待调试样本加权 启动调试服务器：\n方式 1：使用自定义端口（推荐，避免端口冲突）\n1 ./linux_server -p 1234 # 1234 为自定义端口，可替换为 1024-65535 之间未占用端口 方式 2：使用默认端口（无需指定 -p，默认端口为 23946）\n1 ./linux_server 启动成功后，终端会显示 “Listening on port XXXX”（XXXX 为端口号），保持终端窗口开启。\n6.5 调试避坑指南 调试前关闭杀毒软件 / 防火墙，避免程序被拦截；\nWindows 调试 GUI 程序时，断点不设置在 UI 初始化函数（易导致程序卡住）；\n远程调试需确保目标机与本地机网络互通（如同一局域网，关闭防火墙）；\nAndroid so 调试：先将 so 文件从手机拉取至本地，IDA 加载后远程附加手机进程。这里可以参考\n[一次IDA动态调试安卓apk记录]\n","date":"2025-11-06T13:57:03+08:00","image":"https://s.panlai.com/upload/bizhihui_com_20231112122819169976329926177.png-arthumbs","permalink":"https://fanshanng.cn/p/zuhu1/","title":"软件逆向工程组会：IDA 常见操作与基础知识"},{"content":"bbox 主函数目测是一个类似迷宫，点进去看了逻辑，发现是推箱子，简单来说2是人，3是箱子，4是目的地\n这个是d的逻辑，如果不是最右边（19)，就会+1，y_1是新的横坐标索引，x是纵坐标索引，n应该是挑战的个数，5600/400=14个挑战。 前九个的最短路径字符串拼接成是212139211325313,MD5值是fec2d316d20dbacbe0cdff8fb6ff07b9,后五个目测不是推箱子，是qwb!还有一个是纯0填充 组成flag：flag {qwb!_fec2d316d20dbacbe0cdff8fb6ff07b9}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 11111111111111111111 11111111111111111111 11411111111111111111 11030011111111111111 11011011111111111111 00000211111111111111 11101111111111111111 11101111111111111111 01100110001000100010 01000000001000100010 01000000001000111110 01111111111000000010 00000000001000000010 00001111111000111110 00001000001000100010 01111000001000100010 01000000001111100010 01000000000000000010 01000000001111100010 01000000000000000010//2 00000000000000000000 01111111111111111110 01000000000000000010 01200300040000000010 01000000000000000010 01111111111111101110 01000000000000000010 01000011111000111110 01000010001000100010 01111110001000100010 00000010000000100010 00111110001000111110 00100000001000000010 00100010111000111110 00100030001000100010 00111100001000100010 00400000001000100010 01111111111000100010 01000000000000000010 01000000000000000010//4+8=12 11111111111111111111 14000000000000000001 10111111111111100001 10100000000000100001 10100000000000100001 10103000000000100001 10111011101111100001 10000000000000000001 10111111111111011111 10000000100000000001 10000000000000001001 10000000100000001001 11111111100000001001 10000000000000002001 11111111111111111111 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000//13 11111111111111111111 14000000000000000001 10000001111111000001 10000000300001000001 10000001000001000001 10000001000021000001 10000001111111000001 10000000000000000001 11111111111111111111 10000000100000000001 10000000100000000111 10000000100000000100 10111111100000000100 10000000000000000100 11111111111111111111 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000//9 11111111111111111111 10000000000000000001 10111111111111111001 10100000000000001001 10101111111111111001 10101000000000001001 10101011111111111001 10101010000000000001 10101010111111111101 10001000100000000001 11111111111111111111 10000000000000100001 10000001111111101101 10000001000000001001 11111111111111111111 10000000000000040001 10000001111111110101 10000000000000300001 11111011111111101111 10000000000000020001//21 11111111111111111111 14000003000000000001 10111111111111100001 10100000002000000001 10101111111111101101 10101000001000001001 10101011111011101001 10001010001010001001 10111010101010101101 10100000000000000001 11111111111111101111 10000001000000000001 10000001111111011101 10000001000000301001 11111111400000001001 10000000000000001001 10111111111111111001 10100000000000000001 11111111111111111111 10000000000000000001//6+7=13 11111111111111111111 10000010000000000001 10111111111111111001 10100000000000001001 10101111111111111001 10101000021000000001 10101011111011111101 10101010000010000001 10001010111110111101 11111010100000100001 10000010101111101101 10111110101000001001 10100000101011111001 10101111101010000001 10003000000000111111 11111011111010100001 10000000000010101111 10111111111110001001 14000000000000001001 11111111111111111111//25 11111111111111111111 14000000000002003001 10111011111111111001 10100000000000000001 10101111111011111001 10101400001000001001 10101011111010101001 10101010001010101001 10101010111010101101 10003000100000000001 10111011111111111101 10000001000010000001 11111111111111111101 10003000000000041001 10111111111111111001 10100000001000000001 10101111111011111101 10101000001000001001 10101011111111111001 10000000000000000001//15+5+11=31 11111111111111111111 10000000000000100001 10111111111111111001 10100000000000001001 10101111111111111001 10101000000000000001 10101110111011111101 10001013001010001001 11111002111010101001 10000010100000101001 10111114101111111001 10100000001000000001 10101111101111111101 10101000000000001001 10001111111111111001 11111000000000000001 10000011111111111101 10111110000000000001 10100000000000000001 11111111111111111111//3 11111111111111111111 11111111111111111111 11111111111111111111 11100000000001111111 11101111111101111111 11101111111101111111 11101111111101111111 11101111111101111111 11101111111101111111 11100000000001111111 11111111111101111111 11111111111101111111 11111111111101111111 11111111111101111111 11111111111101111111 11111111111101111111 11111111111101111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11011110111101111111 11011110111101111111 11011110111101111111 11011110111101111111 11011110111101111111 11101110111011111111 11101110111011111111 11101101010111111111 11110101010111111111 11110101010111111111 11111011101111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11101111111111111111 11101111111111111111 11101111111111111111 11101111111111111111 11101111111111111111 11100000000011111111 11101111111011111111 11101111111011111111 11101111111011111111 11101111111011111111 11101111111011111111 11101111111011111111 11100000000011111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111111111111111111 11111110000011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110111011111111 11111110000011111111 11111111111111111111 11111111111111111111 11111111000111111111 11111111010111111111 11111111010111111111 11111111000111111111 11111111111111111111 11111111111111111111 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 00000000000000000000 0000000000000000000 snake 文件打开后发现大概是一个贪吃蛇游戏 在绑定上下左右方向键中，学到windows的虚拟键位\n符号常量名称 十六进制值 ascii值 描述 VK_LEFT 0x25 \u0026lsquo;%\u0026rsquo; 向左键 VK_UP 0x26 \u0026lsquo;\u0026amp;\u0026rsquo; 向上键 VK_RIGHT 0x27 \u0026lsquo;\\\u0026rsquo; 向右键 VK_DOWN 0x28 \u0026lsquo;(\u0026rsquo; 向下键 看别人的wp知道 然后就直接玩，保证最短路径就行，到第十分的时候就会自动断下来，进入lpAddress指向的地址2373D8A000h\n写了一段 idc 脚本dump出来得到1.bin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 定义需要提取的起始地址和结束地址（替换为你的实际地址） auto start_addr = 0x000002373D8A0000; auto end_addr = 0x000002373D8A047F; auto file_handle, byte_count, i; // 创建/打开1.bin文件（\u0026#34;wb\u0026#34;表示二进制写入模式） file_handle = fopen(\u0026#34;1.bin\u0026#34;, \u0026#34;wb\u0026#34;); if (file_handle == 0) { Message(\u0026#34;创建文件失败！请检查路径\\n\u0026#34;); return; } // 计算需要导出的字节数（结束地址 - 起始地址 + 1，确保包含最后一个字节） byte_count = end_addr - start_addr + 1; // 循环读取每个地址的字节并写入文件 for (i = 0; i \u0026lt; byte_count; i++) { fputc(Byte(start_addr + i), file_handle); } // 关闭文件并提示成功 fclose(file_handle); Message(\u0026#34;导出成功！共导出 %d 字节到 1.bin\\n\u0026#34;, byte_count); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 char __fastcall sub_0(__int64 a1, __int64 a2, __int64 a3, unsigned int *a4) { char *v4; // rdi __int64 n78; // rcx char v7; // [rsp+20h] [rbp+0h] BYREF unsigned int v8; // [rsp+24h] [rbp+4h] int v9; // [rsp+44h] [rbp+24h] _DWORD v10[12]; // [rsp+68h] [rbp+48h] BYREF unsigned int v11; // [rsp+98h] [rbp+78h] unsigned int v12; // [rsp+9Ch] [rbp+7Ch] unsigned int v13; // [rsp+A0h] [rbp+80h] unsigned int v14; // [rsp+A4h] [rbp+84h] unsigned int n0x20; // [rsp+C4h] [rbp+A4h] unsigned int n0x20_1; // [rsp+E4h] [rbp+C4h] _BYTE v17[44]; // [rsp+108h] [rbp+E8h] int n16; // [rsp+134h] [rbp+114h] v4 = \u0026amp;v7; for ( n78 = 78; n78; --n78 ) { *(_DWORD *)v4 = -858993460; v4 += 4; } v8 = 0; v9 = -1640531527; qmemcpy(v10, \u0026#34;W31c0m3. 2 QWBs8\u0026#34;, 16); v11 = *a4; v12 = a4[1]; v13 = a4[2]; v14 = a4[3]; for ( n0x20 = 0; n0x20 \u0026lt; 0x20; ++n0x20 ) { v11 += (v10[v8 \u0026amp; 3] + v8) ^ (v12 + ((v12 \u0026gt;\u0026gt; 5) ^ (16 * v12))); v8 += v9; v12 += (v10[(v8 \u0026gt;\u0026gt; 11) \u0026amp; 3] + v8) ^ (v11 + ((v11 \u0026gt;\u0026gt; 5) ^ (16 * v11))); } for ( n0x20_1 = 0; n0x20_1 \u0026lt; 0x20; ++n0x20_1 ) { v13 += (v10[v8 \u0026amp; 3] + v8) ^ (v14 + ((v14 \u0026gt;\u0026gt; 5) ^ (16 * v14))); v8 += v9; v14 += (v10[(v8 \u0026gt;\u0026gt; 11) \u0026amp; 3] + v8) ^ (v13 + ((v13 \u0026gt;\u0026gt; 5) ^ (16 * v13))); } v11 ^= v13; v12 ^= v14; v14 ^= v11; v13 ^= v12; v17[0] = -104; v17[1] = -96; v17[2] = -39; v17[3] = -104; v17[4] = -70; v17[5] = -105; v17[6] = 27; v17[7] = 113; v17[8] = -101; v17[9] = -127; v17[10] = 68; v17[11] = 47; v17[12] = 85; v17[13] = -72; v17[14] = 55; v17[15] = -33; for ( n16 = 0; n16 \u0026lt; 16; ++n16 ) { if ( *((char *)\u0026amp;v11 + n16) != (char)v17[n16] ) return 0; } return 1; } 魔改tea，脚本如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from ctypes import * delta = 0x9e3779b9 sum1 = c_uint32(delta * 64) def decrypt(v, k): v0 = c_uint32(v[0]) v1 = c_uint32(v[1]) for i in range(32): # 解密轮次运算 v1.value -= (((v0.value \u0026lt;\u0026lt; 4) ^ (v0.value \u0026gt;\u0026gt; 5)) + v0.value) ^ (sum1.value + k[(sum1.value \u0026gt;\u0026gt; 11) \u0026amp; 3]) sum1.value -= delta v0.value -= (((v1.value \u0026lt;\u0026lt; 4) ^ (v1.value \u0026gt;\u0026gt; 5)) + v1.value) ^ (sum1.value + k[sum1.value \u0026amp; 3]) return v0.value, v1.value def long_to_bytes(n): return n.to_bytes((n.bit_length() + 7) // 8, byteorder=\u0026#39;big\u0026#39;) or b\u0026#39;\\x00\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: a = [0x98D9A098, 0x711B97BA, 0x2F44819B, 0xDF37B855] k = [0x63313357, 0x2E336D30, 0x51203220, 0x38734257] # 预处理异或操作 a[2] ^= a[1] a[3] ^= a[0] a[1] ^= a[3] a[0] ^= a[2] temp = [0] * 2 # 分块解密 for i in range(1, -1, -1): temp[0] = a[i * 2] temp[1] = a[i * 2 + 1] res = decrypt(temp, k) a[i * 2] = res[0] a[i * 2 + 1] = res[1] # 转换为字符串并输出 for i in range(len(a)): # 使用自定义的long_to_bytes并处理字节顺序 print(long_to_bytes(a[i])[::-1].decode(errors=\u0026#39;ignore\u0026#39;), end=\u0026#39;\u0026#39;) #flag{G0@d_Snake} 2024-强网杯-初赛-Writeup-By-Xp0int\n强网杯 2024 All RE wp\n2024 强网杯 - Reverse\n2024强网杯 web\u0026amp;re 部分wp\nmips 1 strings ./emu | grep -i \u0026#34;qemu.*version\\|version.*qemu\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #下载官方完整包（已含子模块） wget https://download.qemu.org/qemu-6.2.0.tar.xz # 官方源，子模块都齐了 tar -xf qemu-6.2.0.tar.xz cd qemu-6.2.0 #一次性配置 + 编译 export CFLAGS=\u0026#34;-g -O0\u0026#34; export CXXFLAGS=\u0026#34;-g -O0\u0026#34; ./configure --target-list=x86_64-softmmu \\ --disable-werror \\ --enable-debug \\ --disable-strip make -j$(nproc) 然后就可以在~/qemu-6.2.0/build 目录下找到qemu-system-x86_64\n右键全部 import model ，可以看到一个魔改的RC4\nmips64逆向新手入门（从jarvisoj一道mips64题目说起）\n","date":"2025-10-07T23:31:14+08:00","image":"https://s.panlai.com/zb_users/upload/2025/04/20250428000432174576987299815.jpg-arthumbs","permalink":"https://fanshanng.cn/p/qwbs8/","title":"2024强网杯复盘"},{"content":"0x00 什么是Frida frida官方文档\n它是原生应用的Greasemonkey，或者用更专业的术语来说，它是一个动态代码插桩工具包。它允许你将 JavaScript 代码片段或你自己的库注入到 Windows、macOS、GNU/Linux、iOS、watchOS、tvOS、Android、FreeBSD 和 QNX 上的原生应用中。Frida 还提供了基于 Frida API 构建的一些简单工具。这些工具可以直接使用，也可以根据你的需求进行调整，或者作为 API 使用示例。\nFrida原理及重要组件 frida注入的原理就是找到目标进程,使用ptrace跟踪目标进程获取mmap，dlpoen，dlsym等函数库的偏移获取mmap在目标进程申请一段内存空间将在目标进程中找到存放frida-agent-32/64.so的空间启动执行各种操作由agent去实现\n组件名称 功能描述 frida-gum 提供了inline-hook的核心实现，还包含了代码跟踪模块Stalker，用于内存访问监控的MemoryAccessMonitor，以及符号查找、栈回溯实现、内存扫描、动态代码生成和重定位等功能 frida-core fridahook的核心，具有进程注入、进程间通信、会话管理、脚本生命周期管理等功能，屏蔽部分底层的实现细节并给最终用户提供开箱即用的操作接口。包含了frida-server、frida-gadget、frida-agent、frida-helper、frida-inject等关键模块和组件，以及之间的互相通信底座 frida-gadget 本身是一个动态库，可以通过重打包修改动态库的依赖或者修改smali代码去实现向三方应用注入gadget，从而实现Frida的持久化或免root frida-server 本质上是一个二进制文件，类似于前面学习到的android_server，需要在目标设备上运行并转发端口，在Frida hook中起到关键作用 Frida与Xposed的对比 工具 优点 缺点 Xposed 直接编写Java代码，Java层hook方便，可打包模块持久化hook 环境配置繁琐，兼容性较差，难以Hook底层代码。 Frida 配置简单，免重启hook。支持Java层和Native层的hook操作 持久化hook相对麻烦 Frida环境配置 推荐用python的虚拟环境env ​\tPython 虚拟环境的创建（venv）\nFrida安装以及多版本处理 1 pip install frida-tools -i https://pypi.tuna.tsinghua.edu.cn/simple push Frida-server 注意要下载对应版本 不知道手机基础框架（ABI）的，可以使用这个指令：adb shell getprop ro.product.cpu.abi arm64-v8a → 64 位 ARM（主流新机） armeabi-v7a → 32 位 ARM（老机型） x86 / x86_64 → Intel 架构（模拟器或极少数真机） FIrda基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 3.操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。\n4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.frida_server自定义端口\n1 2 3 4 5 frida server 默认端口：27042 taimen:/ $ su taimen:/ # cd data/local/tmp/ taimen:/data/local/tmp # ./fs1280 -l 0.0.0.0:6666 6.基础语法\nAPI名称 描述 Java.use(className) 获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback) 确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks) 枚举指定类的所有实例。 Java.cast(obj, cls) 将一个Java对象转换成另一个Java类的实例。 Java.enumerateLoadedClasses(callbacks) 枚举进程中已经加载的所有Java类。 Java.enumerateClassLoaders(callbacks) 枚举进程中存在的所有Java类加载器。 Java.enumerateMethods(targetClassMethod) 枚举指定类的所有方法。 7.日志输出\n日志方法 描述 区别 console.log() 使用JavaScript直接进行日志打印 多用于在CLI模式中，console.log()直接输出到命令行界面，使用户可以实时查看。在RPC模式中，console.log()同样输出在命令行，但可能被Python脚本的输出内容掩盖。 send() Frida的专有方法，用于发送数据或日志到外部Python脚本 多用于RPC模式中，它允许JavaScript脚本发送数据到Python脚本，Python脚本可以进一步处理或记录这些数据。 8.日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\n9.Hook框架模板\n1 2 3 4 5 6 7 8 9 10 11 // 定义主函数 function main() { // Frida提供的Java环境操作API，确保在Java虚拟机上下文执行 Java.perform(function() { // 调用自定义的Hook逻辑函数（需要自己实现） hookTest1(); }); } // 立即执行main函数（Frida脚本常用的启动方式） setImmediate(main); Java.perform(callback)Frida 的核心 API 之一，用于在目标进程的Java 虚拟机（JVM）上下文中执行代码。因为 Hook Java 方法需要访问 JVM 环境，Java.perform会确保回调函数中的代码在 JVM 就绪后执行，避免因环境未初始化导致的错误。\n**hookTest1()**这是一个自定义函数（需要你自己实现具体逻辑），用于编写实际的 Hook 操作，例如：\n拦截某个 Java 方法的调用 修改方法的参数或返回值 打印方法调用栈信息等 **setImmediate(main)**用于启动整个 Hook 流程。setImmediate是 JavaScript 的异步 API，会将main函数放入事件循环中立即执行（类似setTimeout(fn, 0)）。在 Frida 脚本中，这是启动 Hook 逻辑的标准方式，确保代码在进程初始化完成后运行。\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 此案例中，类名修改为com.zj.wuaipojie.Demo,将参数和方法名都修改。\n最新的jadx中已经可以将方法复制成frida片段，如下：\n1 2 3 4 5 6 7 var Demo = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); Demo[\u0026#34;a\u0026#34;].implementation = function (str) { console.log(`Demo.a is called: str=${str}`); let result = this[\u0026#34;a\u0026#34;](str); console.log(`Demo.a result=${result}`); return result; }; 使用frida-ps -U 查看当前手机运行的进程得到 1821 wuaipojie\n然后使用frida -U 进程名 -l hook.js启动命令，下图是另一个终端窗口中logcat |grep \u0026quot;D.zj2595\u0026quot;进行的日志捕获 可以看到，终端输出了方法传入的参数和输出的返回值 在let result = this[\u0026quot;a\u0026quot;](str);这条语句中即可修改方法的返回值，但需注意原方法返回值的类型，若原方法返回int，应该返回数字22（而不是字符串\u0026quot;22\u0026quot;）\n2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 再看一个自定义参数类型的方法案例\n当overload()中没有填入参数类型或者你不知道该参数的类型时候可以尝试运行在报错的提示中可以找到参数类型，也可以从Java文件定位到对应的smali语句，也可以看到相应的参数类型\n有时候文件运行后，没有hook成功，可以多尝试几次\n3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 在第一次的使用过程中，发现obj.privateInt.value = 9999;并没有成功，可能的原因是\nprivate 修饰：Java 中 private 字段只能在当前类内部访问，外部（包括 Frida 直接访问）默认没有权限修改； final 修饰：final 字段初始化后不允许重新赋值（即使是类内部也不行），Java 的语法规则会阻止修改。 翻论坛评论的时候发现了这个帖子 尝试了一下，确实可以，真的要和别人多交流学习啊（感慨） 附上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function hookTest5(){ Java.perform(function(){ //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 // obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同时 前面加个下划线 console.log(\u0026#34;here!\u0026#34;) obj.publicInt.value = 8888; obj.privateInt.value = 9999; //由于样本代码的原因，需要再主动调用一下Demo类日志输出函数test()，才能在adb的log界面看到输出改变 obj.test(); console.log(obj.privateInt.value ) }, onComplete: function(){ } }); }); } 5.Hook内部类 1 2 3 4 5 6 7 8 9 10 11 function hookTest5(){ Java.perform(function(){ //内部类 var innerClass = Java.use(\u0026#34;com.zj.wuaipojie.Demo$innerClass\u0026#34;); console.log(innerClass); innerClass.$init.implementation = function(){ console.log(\u0026#34;eeeeeeee\u0026#34;); } }); } 6. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function hookTest6(){ Java.perform(function(){ //枚举所有的类与类的所有方法,异步枚举 Java.enumerateLoadedClasses({ onMatch: function(name,handle){ //过滤类名 if(name.indexOf(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;) !=-1){ console.log(name); var clazz =Java.use(name); console.log(clazz); var methods = clazz.class.getDeclaredMethods(); console.log(methods); } }, onComplete: function(){} }) }) } 7.枚举所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function hookTest7(){ Java.perform(function(){ var Demo = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //getDeclaredMethods枚举所有方法 var methods =Demo.class.getDeclaredMethods(); for(var j=0; j \u0026lt; methods.length; j++){ var methodName = methods[j].getName(); console.log(methodName); for(var k=0; k\u0026lt;Demo[methodName].overloads.length;k++){ Demo[methodName].overloads[k].implementation = function(){ for(var i=0;i\u0026lt;arguments.length;i++){ console.log(arguments[i]); } return this[methodName].apply(this,arguments); } } } }) } 8.主动调用 静态方法 1 2 var ClassName=Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); ClassName.privateFunc(\u0026#34;传参\u0026#34;); 下图就能显示出修改后的加密结果\n非静态方法 1 2 3 4 5 6 7 8 9 10 11 12 var ret = null; Java.perform(function () { Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;,{ //要hook的类 onMatch:function(instance){ ret=instance.privateFunc(\u0026#34;aaaaaaa\u0026#34;); //要hook的方法 }, onComplete:function(){ //console.log(\u0026#34;result: \u0026#34; + ret); } }); }) //return ret; 0x01 objection 什么是objection objection是基于frida的命令行hook集合工具, 可以让你不写代码, 敲几句命令就可以对java函数的高颗粒度hook, 还支持RPC调用。可以实现诸如内存搜索、类和模块搜索、方法hook打印参数返回值调用栈等常用功能，是一个非常方便的，逆向必备、内存漫游神器。 项目地址\n由于objection在2021就已经停止更新，所以需要使用较低版本的frida和frida_tools，建议重新设置一个虚拟环境，因为之前虚拟环境用的是最新版本的，不太支持objection，配置一个新的环境也方便管理 我这里配置的是\n1 2 3 4 5 objection 1.11.0 frida 16.2.1 frida-tools 13.2.0 简单测试一下，出现如下图所示就是成功了 objection 命令注释 1.help命令注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 objection --help(help命令) Checking for a newer version of objection... Usage: objection [OPTIONS] COMMAND [ARGS]... _ _ _ _ ___| |_|_|___ ___| |_|_|___ ___ | . | . | | -_| _| _| | . | | |___|___| |___|___|_| |_|___|_|_| |___|(object)inject(ion) Runtime Mobile Exploration by: @leonjza from @sensepost 默认情况下，通信将通过USB进行，除非提供了`--network`选项。 选项: -N, --network 使用网络连接而不是USB连接。 -h, --host TEXT [默认: 127.0.0.1] -p, --port INTEGER [默认: 27042] -ah, --api-host TEXT [默认: 127.0.0.1] -ap, --api-port INTEGER [默认: 8888] -g, --gadget TEXT 要连接的Frida Gadget/进程的名称。 [默认: Gadget] -S, --serial TEXT 要连接的设备序列号。 -d, --debug 启用带有详细输出的调试模式。(在堆栈跟踪中包括代{过}{滤}理源图) --help 显示此消息并退出。 命令: api 以无头模式启动objection API服务器。 device-type 获取关于已连接设备的信息。 explore 启动objection探索REPL。 patchapk 使用frida-gadget.so补丁一个APK。 patchipa 使用FridaGadget dylib补丁一个IPA。 run 运行单个objection命令。 signapk 使用objection密钥对APK进行Zipalign和签名。 version 打印当前版本并退出。 2.注入命令 1 2 3 4 5 6 objection -g 包名 explore - help：不知道当前命令的效果是什么，在当前命令前加help比如:help env，回车之后会出现当前命令的解释信息 - 按空格：不知道输入什么就按空格，会有提示出来 - jobs：可以进行多项hook - 日志：objection的日志文件生成在 C:\\Users\\Administrator\\.objection 启动前就hook\n1 objection -g 进程名 explore --startup-command \u0026#34;android hooking watch class 路径.类名\u0026#34; 3.objection基础api\nmemory list modules -查看内存中加载的库 1 2 3 4 5 6 7 8 9 10 11 12 memory list modules Save the output by adding `--json modules.json` to this command Name Base Size Path ---------------------------------------------------------------- ------------ ------------------- ------------------------------------------------------------------------------ app_process64 0x57867c9000 40960 (40.0 KiB) /system/bin/app_process64 linker64 0x72e326a000 229376 (224.0 KiB) /system/bin/linker64 libandroid_runtime.so 0x72e164e000 2113536 (2.0 MiB) /system/lib64/libandroid_runtime.so libbase.so 0x72dfa67000 81920 (80.0 KiB) /system/lib64/libbase.so libbinder.so 0x72dec1c000 643072 (628.0 KiB) /system/lib64/libbinder.so libcutils.so 0x72de269000 86016 (84.0 KiB) /system/lib64/libcutils.so libhidlbase.so 0x72df4cc000 692224 (676.0 KiB) /system/lib64/libhidlbase.so liblog.so 0x72e0be1000 98304 (96.0 KiB) /system/lib64/liblog memory list exports so名称 - 查看库的导出函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 memory list exports liblog.so Save the output by adding `--json exports.json` to this command Type Name Address -------- ------------------------------------ ------------ function android_log_write_int32 0x72e0be77c8 function android_log_write_list_begin 0x72e0be76f0 function __android_log_bswrite 0x72e0be9bd8 function __android_log_security 0x72e0bf2144 function __android_log_bwrite 0x72e0be9a18 function android_log_reset 0x72e0be75ec function android_log_write_string8 0x72e0be7a38 function android_logger_list_free 0x72e0be8c04 function __android_log_print 0x72e0be9728 function __android_logger_property_get_bool 0x72e0bf2248 function android_logger_get_id 0x72e0be8270 function android_logger_set_prune_list 0x72e0be8948 android hooking list activities -查看内存中加载的activity /android hooking list services -查看内存中加载的services android intent launch_activity 类名 -启动activity或service(可以用于一些没有验证的activity,在一些简单的ctf中有时候可以出奇效) 关闭ssl校验 android sslpinning disable 关闭root检测 android root disable 4.objection内存漫游\n内存搜刮类实例 1 2 3 4 5 android heap search instances 类名(命令) Class instance enumeration complete for com.zj.wuaipojie.Demo Hashcode Class toString() --------- --------------------- ----------------------------- 215120583 com.zj.wuaipojie.Demo com.zj.wuaipojie.Demo@cd27ac7 调用实例的方法 1 2 3 4 5 android heap execute \u0026lt;handle\u0026gt; getPublicInt(实例的hashcode+方法名) 如果是带参数的方法，则需要进入编辑器环境 android heap evaluate \u0026lt;handle\u0026gt; console.log(clazz.a(\u0026#34;吾爱破解\u0026#34;)); 按住esc+enter触发 android hooking list classes -列出内存中所有的类(结果比静态分析的更准确) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 android hooking list classes tw.idv.palatis.xappdebug.MainApplication tw.idv.palatis.xappdebug.xposed.HookMain tw.idv.palatis.xappdebug.xposed.HookMain$a tw.idv.palatis.xappdebug.xposed.HookMain$b tw.idv.palatis.xappdebug.xposed.HookMain$c tw.idv.palatis.xappdebug.xposed.HookMain$d tw.idv.palatis.xappdebug.xposed.HookSelf u v void w xposed.dummy.XResourcesSuperClass xposed.dummy.XTypedArraySuperClass Found 10798 classes android hooking search classes 关键类名 -在内存中所有已加载的类中搜索包含特定关键词的类 1 2 3 4 5 6 7 8 9 10 11 12 android hooking search classes wuaipojie Note that Java classes are only loaded when they are used, so if the expected class has not been found, it might not have been loaded yet. com.zj.wuaipojie.Demo com.zj.wuaipojie.Demo$Animal com.zj.wuaipojie.Demo$Companion com.zj.wuaipojie.Demo$InnerClass com.zj.wuaipojie.Demo$test$1 com.zj.wuaipojie.MainApplication com.zj.wuaipojie.databinding.ActivityMainBinding ... Found 38 classes android hooking search methods 关键方法名 -在内存中所有已加载的类的方法中搜索包含特定关键词的方法(一般不建议使用，特别耗时，还可能崩溃) android hooking list class_methods 类名 -内存漫游类中的所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 android hooking list class_methods com.zj.wuaipojie.ui.ChallengeSixth private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate$lambda-0(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate$lambda-1(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate$lambda-2(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate$lambda-3(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) protected void com.zj.wuaipojie.ui.ChallengeSixth.onCreate(android.os.Bundle) public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.hexToString(java.lang.String) public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.unicodeToString(java.lang.String) public final void com.zj.wuaipojie.ui.ChallengeSixth.toastPrint(java.lang.String) public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda$1lrkrgiCEFWXZDHzLRibYURG1h8(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda$IUqwMqbTKaOGiTaeOmvy_GjNBso(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda$Kc_cRYZjjhjsTl6GYNHbgD-i6sE(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda$PDKm2AfziZQo6Lv1HEFkJWkUsoE(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View) Found 12 method(s) 5.objectionHook\nhook类的所有方法\n1 android hooking watch class 类名 hook方法的参数、返回值和调用栈\n1 android hooking watch class_method 类名.方法名 --dump-args --dump-return --dump-backtrace hook 类的构造方法\n1 android hooking watch class_method 类名.$init hook 方法的所有重载\n1 android hooking watch class_method 类名.方法名 参考：\n实用FRIDA进阶：内存漫游、hook anywhere、抓包\n使用objection对吾爱破解2023春节安卓初级题进行快速解题\ntrace实战java控制流混淆 用到的实战题目：吾爱破解2023春节红包题\n用到的混淆项目：DEX控制流混淆 · BlackObfuscator\n项目效果展示：\n混淆前 混淆后 对抗方法：\nZenTracer\n注意:无法打印调用栈，无法hook构造函数，高版本Frida不一定兼容，需要pyqt5的库\nr0tracer\nAKA：精简版 objection + Wallbreaker\n0x02 Process、Module、Memory基础 1.Process Process 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等\nAPI 含义 Process.id 返回附加目标进程的 PID Process.isDebuggerAttached() 检测当前是否对目标程序已经附加 Process.enumerateModules() 枚举当前加载的模块，返回模块对象的数组 Process.enumerateThreads() 枚举当前所有的线程，返回包含 id, state, context 等属性的对象数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function processInfo() { Java.perform(function() { console.log(\u0026#34;PID:\u0026#34;, Process.id); console.log(\u0026#34;架构:\u0026#34;, Process.arch); console.log(\u0026#34;平台:\u0026#34;, Process.platform); console.log(\u0026#34;调试器附加:\u0026#34;, Process.isDebuggerAttached()); // 枚举模块 var modules = Process.enumerateModules(); modules.forEach(function(module) { console.log(\u0026#34;模块:\u0026#34;, module.name, \u0026#34;基址:\u0026#34;, module.base, \u0026#34;大小:\u0026#34;, module.size); }); // 枚举线程 var threads = Process.enumerateThreads(); threads.forEach(function(thread) { console.log(\u0026#34;线程ID:\u0026#34;, thread.id, \u0026#34;状态:\u0026#34;, thread.state); }); }); } 2.Module Module 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux/Android 上的 .so 文件),能查询模块的信息，如模块的基址、名称、导入/导出的函数等\nAPI 含义 Module.load() 加载指定so文件，返回一个Module对象 enumerateImports() 枚举所有Import库函数，返回Module数组对象 enumerateExports() 枚举所有Export库函数，返回Module数组对象 enumerateSymbols() 枚举所有Symbol库函数，返回Module数组对象 Module.findExportByName(exportName)、Module.getExportByName(exportName) 寻找指定so中export库中的函数地址 Module.findBaseAddress(name)、Module.getBaseAddress(name) 返回so的基地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function moduleInfo() { Java.perform(function() { // 获取模块基址的多种方式 var base1 = Module.findBaseAddress(\u0026#34;libtarget.so\u0026#34;); var base2 = Process.getModuleByName(\u0026#34;libtarget.so\u0026#34;).base; console.log(\u0026#34;模块基址:\u0026#34;, base1, base2); // 查找导出函数 var exportAddr = Module.findExportByName(\u0026#34;libtarget.so\u0026#34;, \u0026#34;target_function\u0026#34;); console.log(\u0026#34;导出函数地址:\u0026#34;, exportAddr); // 枚举导入表 var imports = Module.enumerateImports(\u0026#34;libtarget.so\u0026#34;); imports.forEach(function(imp) { console.log(\u0026#34;导入:\u0026#34;, JSON.stringify(imp)); }); // 枚举导出表 var exports = Module.enumerateExports(\u0026#34;libtarget.so\u0026#34;); exports.forEach(function(exp) { console.log(\u0026#34;导出:\u0026#34;, JSON.stringify(exp)); }); }); } 3.Memory Memory是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等\n方法 功能 Memory.copy() 复制内存 Memory.scan() 搜索内存中特定模式的数据 Memory.scanSync() 同上，但返回多个匹配的数据 Memory.alloc() 在目标进程的堆上申请指定大小的内存，返回一个NativePointer Memory.writeByteArray() 将字节数组写入一个指定内存 Memory.readByteArray 读取内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function memoryOperations() { Java.perform(function() { try { // 分配内存 var allocated = Memory.alloc(1024); console.log(\u0026#34;分配内存:\u0026#34;, allocated); // 写入字符串 var testStr = \u0026#34;Hello Frida\u0026#34;; Memory.writeUtf8String(allocated, testStr); // 读取字符串 var readStr = Memory.readCString(allocated); console.log(\u0026#34;读取字符串:\u0026#34;, readStr); // 内存扫描 var pattern = \u0026#34;48 89 5C 24 ?? 48 89 6C 24\u0026#34;; Memory.scan(Module.findBaseAddress(\u0026#34;libtarget.so\u0026#34;), Process.getModuleByName(\u0026#34;libtarget.so\u0026#34;).size, pattern, { onMatch: function(address, size) { console.log(\u0026#34;找到模式在:\u0026#34;, address, \u0026#34;大小:\u0026#34;, size); }, onError: function(reason) { console.log(\u0026#34;扫描错误:\u0026#34;, reason); }, onComplete: function() { console.log(\u0026#34;扫描完成\u0026#34;); } }); } catch(e) { console.log(\u0026#34;内存操作错误:\u0026#34;, e); } }); } 0x03 枚举导入导出表 导出表（Export Table）：列出了库中可以被其他程序或库访问的所有公开函数和符号的名称。 导入表（Import Table）：列出了库需要从其他库中调用的函数和符号的名称。 简而言之，导出表告诉其他程序：“这些是我提供的功能。”，而导入表则表示：“这些是我需要的功能。”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function hookTest1(){ Java.perform(function(){ //打印导入表 var imports = Module.enumerateImports(\u0026#34;lib52pojie.so\u0026#34;); for(var i =0; i \u0026lt; imports.length;i++){ if(imports[i].name == \u0026#34;vip\u0026#34;){ console.log(JSON.stringify(imports[i])); //通过JSON.stringify打印object数据 console.log(imports[i].address); } } //打印导出表 var exports = Module.enumerateExports(\u0026#34;lib52pojie.so\u0026#34;); for(var i =0; i \u0026lt; exports.length;i++){ console.log(JSON.stringify(exports[i])); } }) } 0x04 Native函数的基础Hook打印 1.整数型、布尔值类型、char类型Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function hookTest2(){ Java.perform(function(){ //根据导出函数名打印地址 var helloAddr = Module.findExportByName(\u0026#34;lib52pojie.so\u0026#34;,\u0026#34;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip\u0026#34;); console.log(helloAddr); if(helloAddr != null){ //Interceptor.attach是Frida里的一个拦截器 Interceptor.attach(helloAddr,{ //onEnter里可以打印和修改参数 onEnter: function(args){ //args传入参数 console.log(args[0]); //打印第一个参数的值 console.log(this.context.x1); // 打印寄存器内容 console.log(args[1].toInt32()); //toInt32()转十进制 console.log(args[2].readCString()); //读取字符串 char类型 console.log(hexdump(args[2])); //内存dump }, //onLeave里可以打印和修改返回值 onLeave: function(retval){ //retval返回值 console.log(retval); console.log(\u0026#34;retval\u0026#34;,retval.toInt32()); } }) } }) } 2.字符串类型Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function hookTest2(){ Java.perform(function(){ //根据导出函数名打印地址 var helloAddr = Module.findExportByName(\u0026#34;lib52pojie.so\u0026#34;,\u0026#34;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel\u0026#34;); if(helloAddr != null){ Interceptor.attach(helloAddr,{ //onEnter里可以打印和修改参数 onEnter: function(args){ //args传入参数 // 方法一 var jString = Java.cast(args[2], Java.use(\u0026#39;java.lang.String\u0026#39;)); console.log(\u0026#34;参数:\u0026#34;, jString.toString()); // 方法二 var JNIEnv = Java.vm.getEnv(); var originalStrPtr = JNIEnv.getStringUtfChars(args[2], null).readCString(); console.log(\u0026#34;参数:\u0026#34;, originalStrPtr); }, //onLeave里可以打印和修改返回值 onLeave: function(retval){ //retval返回值 var returnedJString = Java.cast(retval, Java.use(\u0026#39;java.lang.String\u0026#39;)); console.log(\u0026#34;返回值:\u0026#34;, returnedJString.toString()); } }) } }) } 0x05 Native函数的基础Hook修改 1.整数型修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function hookTest3(){ Java.perform(function(){ //根据导出函数名打印地址 var helloAddr = Module.findExportByName(\u0026#34;lib52pojie.so\u0026#34;,\u0026#34;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip\u0026#34;); console.log(helloAddr); if(helloAddr != null){ Interceptor.attach(helloAddr,{ onEnter: function(args){ //args参数 args[0] = ptr(1000); //第一个参数修改为整数 1000，先转为指针再赋值 console.log(args[0]); }, onLeave: function(retval){ //retval返回值 retval.replace(20000); //返回值修改 console.log(\u0026#34;retval\u0026#34;,retval.toInt32()); } }) } }) } 2.字符串类型修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function hookTest2(){ Java.perform(function(){ //根据导出函数名打印地址 var helloAddr = Module.findExportByName(\u0026#34;lib52pojie.so\u0026#34;,\u0026#34;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel\u0026#34;); if(helloAddr != null){ Interceptor.attach(helloAddr,{ //onEnter里可以打印和修改参数 onEnter: function(args){ //args传入参数 var JNIEnv = Java.vm.getEnv(); var originalStrPtr = JNIEnv.getStringUtfChars(args[2], null).readCString(); console.log(\u0026#34;参数:\u0026#34;, originalStrPtr); var modifiedContent = \u0026#34;至尊\u0026#34;; var newJString = JNIEnv.newStringUtf(modifiedContent); args[2] = newJString; }, //onLeave里可以打印和修改返回值 onLeave: function(retval){ //retval返回值 var returnedJString = Java.cast(retval, Java.use(\u0026#39;java.lang.String\u0026#39;)); console.log(\u0026#34;返回值:\u0026#34;, returnedJString.toString()); var JNIEnv = Java.vm.getEnv(); var modifiedContent = \u0026#34;无敌\u0026#34;; var newJString = JNIEnv.newStringUtf(modifiedContent); retval.replace(newJString); } }) } }) } 0x06 SO基址的获取方式 1 2 3 var moduleAddr1 = Process.findModuleByName(\u0026#34;lib52pojie.so\u0026#34;).base; var moduleAddr2 = Process.getModuleByName(\u0026#34;lib52pojie.so\u0026#34;).base; var moduleAddr3 = Module.findBaseAddress(\u0026#34;lib52pojie.so\u0026#34;); 0x07 Hook未导出函数与函数地址计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function hookTest6(){ Java.perform(function(){ //根据导出函数名打印基址 var soAddr = Module.findBaseAddress(\u0026#34;lib52pojie.so\u0026#34;); console.log(soAddr); var funcaddr = soAddr.add(0x1071C); console.log(funcaddr); if(funcaddr != null){ Interceptor.attach(funcaddr,{ onEnter: function(args){ //args参数 }, onLeave: function(retval){ //retval返回值 console.log(retval.toInt32()); } }) } }) } 函数地址计算\n1.安卓里一般32 位的 so 中都是thumb指令，64 位的 so 中都是arm指令\n2.通过IDA里的opcode bytes来判断，arm 指令为 4 个字节(options -\u0026gt; general -\u0026gt; Number of opcode bytes (non-graph) 输入4)\n3.thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1 arm 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移\n0x08 Hook_dlopen dlopen/android_dlopen_ext 是 Android 加载 SO 的系统函数，Hook 后可捕获 SO 加载时机，实现延迟 Hook（避免 SO 未加载时 Hook 失败）。\ndlopen源码 android_dlopen_ext源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function hook_dlopen() { var dlopen = Module.findExportByName(null, \u0026#34;dlopen\u0026#34;); Interceptor.attach(dlopen, { onEnter: function (args) { var so_name = args[0].readCString(); if (so_name.indexOf(\u0026#34;lib52pojie.so\u0026#34;) \u0026gt;= 0) this.call_hook = true; }, onLeave: function (retval) { if (this.call_hook) hookTest2(); } }); // 高版本Android系统使用android_dlopen_ext var android_dlopen_ext = Module.findExportByName(null, \u0026#34;android_dlopen_ext\u0026#34;); Interceptor.attach(android_dlopen_ext, { onEnter: function (args) { var so_name = args[0].readCString(); if (so_name.indexOf(\u0026#34;lib52pojie.so\u0026#34;) \u0026gt;= 0) this.call_hook = true; }, onLeave: function (retval) { if (this.call_hook) hookTest2(); } }); } 参考文档：\nIDA\u0026amp;Frida 学习\nFRIDA-API使用篇：rpc、Process、Module、Memory使用方法及示例\nIDA\u0026amp;Frida 学习\nFrida Hook 常用函数、java 层 hook、so 层 hook、RPC、群控\n","date":"2025-09-28T22:21:41+08:00","image":"https://img.scwcd.cn/markdown/27lh0p36.jpg","permalink":"https://fanshanng.cn/p/frida/","title":"安卓逆向入门七：Frida入门"},{"content":"一次IDA动态调试安卓apk记录 工具清单：IDA Pro9.1 小米手机（MIUI 15.5.2）吾爱破解的教程demo（解压密码：52pj） ADB环境 在IDA目录下的dbgsrv，选择跟手机架构一致的server 在mt管理器中点开目标app的属性进行手动提权 也可以adb进入提权 重命名android_server为as，可以防止一些反调试\n此处运行编辑好的.bat文件，也可以用命令行替代\n运行成功就会显示如下画面（只需点击IDAdebug1.bat即可） 打开ida pro，设置Hostname为127.0.0.1 使用默认端口号为23946 对check函数下断点\n然后\n附加到对应进程，会出现如下所示窗口，选择same 然后程序会停在如图所示的地方，这时候要点开始调试（蓝色小三角），在手机输入任意字符串后点击验证 等待程序运行到断点\n步进到比较函数处\n点击_wuaipojie0123456就可以看到比较的值，即为flag 在第一次调试过程遇到了反调试，在JNI_OnLoad中 将对应代码patch掉后，右键保存 点击Apply patches覆盖掉原本的so文件，然后将这个so文件替换原本的apk/lib/arm64-v8a中的so文件，重新安装该应用，再次运行上述操作，即可绕过反调试 补充常见寄存器知识 在进行动态调试，以下是一些常用的寄存器介绍：\n寄存器名称 功能介绍 R0-R12 通用寄存器，用于存储临时数据。在函数调用时，R0-R3用于存储前四个参数，其余的参数通过堆栈传递。返回值也通过R0和R1传递。 R13 (SP) 堆栈指针寄存器，指向当前堆栈的顶部。 R14 (LR) 链接寄存器，存储子程序的返回地址。 R15 (PC) 程序计数器，指向下一条要执行的指令。 CPSR 当前程序状态寄存器，保存程序的状态信息，如算术运算的结果标志、中断禁止标志等。 FPSCR 浮点状态和控制寄存器，如果你在调试的代码中涉及到浮点运算，那么这个寄存器会比较重要。 常用快捷键 快捷键 功能 F2 在所在行下断点 F5 可以将ARM指令转化为可读的C代码，同时可以使用Y键，对JNIEnv指针做一个类型转换，从而对JNI里经常使用的JNIEnv方法能够识别 F7 单步进入调试 F8 按照顺序一行一行，单步调试 F9 直接跳到下一个断点处 Shift + F12 快速查看so文件中的字符串信息，分析过程中通过一些关键字符串能够迅速定位到关键函数 Ctrl + s 有两个用途，在IDA View页面中可以查看文件so文件的所有段信息，在调试页面可以查看程序中所有so文件映射到内存的基地址。tips:在进行so调试过程中，很有用的一个小技巧就是IDA双开，一个用于进行静态分析；一个用于动态调试。比如说调试过程中要找到一个函数的加载到内存中的位置 Esc 回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口） g 直接跳到某个地址 y 更改变量的类型 x 对着某个函数、变量按该快捷键，可以查看它的交叉引用 n 更改变量的名称 p 创建函数 可能遇到的问题 1.jdb 不是内部或外部命令，也不是可运行的程序或批处理文件。 ​\thttp://t.csdn.cn/paKAt\n1 2 3 4 5 6 7 8 9 10 11 12 java.io.IOException: handshake failed - connection prematurally closed at com.sun.tools.jdi.SocketTransportService.handshake(SocketTransportService.java:136) at com.sun.tools.jdi.SocketTransportService.attach(SocketTransportService.java:232) at com.sun.tools.jdi.GenericAttachingConnector.attach(GenericAttachingConnector.java:116) at com.sun.tools.jdi.SocketAttachingConnector.attach(SocketAttachingConnector.java:90) at com.sun.tools.example.debug.tty.VMConnection.attachTarget(VMConnection.java:519) at com.sun.tools.example.debug.tty.VMConnection.open(VMConnection.java:328) at com.sun.tools.example.debug.tty.Env.init(Env.java:63) at com.sun.tools.example.debug.tty.TTY.main(TTY.java:1066) 致命错误: 无法附加到目标 VM。 解决方法：有可能是手机问题，建议低版本真机，不要用模拟器！切命令顺序不要乱！另外也有可能软件有反调试！ 3.动态调试中找不到so文件 解决方法：可以尝试手动复制一份对应的so文件放到data/app/包名/lib目录下\n4.device offline 解决方法：重新插拔usb，再不行就重启机子\n5.0.0.0.0:23946: bind: Address already in use 解决方案： adb shell \u0026quot;su -c 'lsof | grep 23946'\u0026quot; //获取pid adb shell \u0026quot;su -c 'kill -9 PID'\u0026quot; //这里的pid要根据上一步获取的填写\n6.常见反调试\n调试端口检测\n检测常见的23946端口，所以在运行时可以加-p指定一个另外的端口来过掉这个检测\n例如，使用./as -p 12345命令启动调试server，将调试端口改为12345，然后在IDA Pro中相应地修改端口号为12345进行连接。\n调试进程名检测\n固定的进程名 android_server gdb_server等等，所以要改个名字，例如as64\nptrace检测\n每个进程同时刻只能被1个调试进程ptrace ，主动ptrace本进程可以使得其他调试器无法调试\n实现代码：\n1 2 3 4 int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote { return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试 } 推荐一个安卓的显示控制软件：QtScrcpy 打开如下按钮后可以实现电脑的模拟点击，非常好用 参考文件：\n《安卓逆向这档事》十二、大佬帮我分析一下\nIDA修改exe并保存运行\n使用IDA进行动态调试与过反调试（上）（三）\n","date":"2025-09-26T23:55:59+08:00","image":"https://s.panlai.com/zb_users/upload/2025/06/20250625120242175082416230890.jpg-arthumbs","permalink":"https://fanshanng.cn/p/as_debug/","title":"一次IDA动态调试安卓apk记录"},{"content":"关键词：ELF文件入门、so文件分析 、ARM基础知识\n0x00 ELF文件入门 ELF（Executable and Linkable Format）是一种可执行和可链接的文件格式，是linux底下二进制文件，可以理解为windows下的PE文件，在Android中可以比作SO，方便函数的移植，在常用于保护Android软件，增加逆向难度。其核心价值在于支持程序的执行（如二进制程序运行、动态库加载）和链接（编译过程中的模块组合），是跨平台二进制兼容的基础。\nELF文件的主要组成部分包括：\nELF Header：文件头，描述文件的基本信息\nProgram Header Table：程序头表，描述进程映像的布局\nSection Header Table：节区头表，描述文件的各个节区\n程序头表与分段头表引用的数据，比如 .text .data。\nELF Header（文件头） ELF Header 描述了 ELF 文件的概要信息，利用这个数据结构可以索引到 ELF 文件的全部信息，是ELF 文件的 \u0026ldquo;总目录\u0026rdquo;，存储文件的基础元信息，可通过这些信息索引到其他所有结构。32 位 ELF 的文件头结构定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; ELF32_Half e_type; ELF32_Half e_machine; ELF32_Word e_version; ELF32_Addr e_entry; ELF32_Off e_phoff; ELF32_Off e_shoff; ELF32_Word e_flags; ELF32_Half e_ehsize; ELF32_Half e_phentsize; ELF32_Half e_phnum; ELF32_Half e_shentsize; ELF32_Half e_shnum; ELF32_Half e_shstrndx; } Elf32_Ehdr; ELF 头中的 e_shoff 项给出了从文件开头到节头表位置的字节偏移。e_shnum 告诉了我们节头表包含的项数；e_shentsize 给出了每一项的字节大小。\nProgram Header Table（程序头表） Program Header Table 是一个结构体数组，每一个元素的类型是 Elf32_Phdr，描述了一个段或者其它系统在准备程序执行时所需要的信息。\n其中，ELF 头中的 e_phentsize 和 e_phnum 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。程序的头部只有对于可执行文件和共享目标文件有意义。\n可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。\nElf32_Phdr的定义如下\n1 2 3 4 5 6 7 8 9 10 typedef struct { ELF32_Word p_type; ELF32_Off p_offset; ELF32_Addr p_vaddr; ELF32_Addr p_paddr; ELF32_Word p_filesz; ELF32_Word p_memsz; ELF32_Word p_flags; ELF32_Word p_align; } Elf32_Phdr; 字段说明 字段 说明 p_type 该字段为段的类型，或者表明了该结构的相关信息。 p_offset 该字段给出了从文件开始到该段开头的第一个字节的偏移。 p_vaddr 该字段给出了该段第一个字节在内存中的虚拟地址。 p_paddr 该字段仅用于物理地址寻址相关的系统中， 由于 “System V” 忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。 p_filesz 该字段给出了文件镜像中该段的大小，可能为 0。 p_memsz 该字段给出了内存镜像中该段的大小，可能为 0。 p_flags 该字段给出了与段相关的标记。 p_align 可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。 核心意义：操作系统加载 ELF 文件时，根据程序头表将 \u0026ldquo;段\u0026rdquo; 映射到内存，例如：\np_type=PT_LOAD的段会被加载到p_vaddr指定的内存地址。 p_flags=0x5（R+X）通常对应代码段（可执行且只读），p_flags=0x6（R+W）对应数据段。 Section Header Table（节区头表） 该结构用于定位 ELF 文件中的每个节区的具体位置。描述 ELF 文件在编译链接时的结构（即 \u0026ldquo;节区\u0026rdquo; 信息），用于调试、静态分析等场景。每个条目对应一个Elf32_Shdr结构：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { ELF32_Word sh_name; ELF32_Word sh_type; ELF32_Word sh_flags; ELF32_Addr sh_addr; ELF32_Off sh_offset; ELF32_Word sh_size; ELF32_Word sh_link; ELF32_Word sh_info; ELF32_Word sh_addralign; ELF32_Word sh_entsize; } Elf32_Shdr; 成员 说明 取值 说明 sh_name sh_name节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。 0 无名称 sh_type sh_type根据节的内容和语义进行分类，具体的类型下面会介绍。 SHT_NULL 限制 sh_flags sh_flags每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。 0 无标志 sh_addr sh_addr如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 0 无地址 sh_offset sh_offset给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 0 无文件偏移 sh_size sh_size此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 0 无大小 sh_link sh_link此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。 SHN_UNDEF 无链接信息 sh_info sh_info此成员给出附加信息，其解释依赖于节区类型。 0 无辅助信息 sh_addralign sh_addralign某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，sh_addr%sh_addralign=0。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 0 无对齐要求 常见节区（Sections） 节区是 ELF 文件的实际数据载体，常见类型及作用如下：\n节区名 描述 .text 代码段，存放程序的指令 .data 数据段，存放已初始化的全局变量和静态变量 .rodata 只读数据段，存放只读数据 .bss 未初始化数据段，存放未初始化的全局变量和静态变量 .symtab 符号表，存放符号信息 .strtab 字符串表，存放字符串数据 .dynsym 动态符号表，存放动态链接需要的符号信息 .dynamic 动态链接信息，存放动态链接器需要的信息 段与节区的关系\n段（Segment）：面向运行时，由一个或多个节区组成（如.text和.rodata可合并为一个 \u0026ldquo;代码段\u0026rdquo;）。 节区（Section）：面向编译时，按功能划分的最小数据单元。 例如：一个PT_LOAD段可能包含.text（代码）和.rodata（只读数据）两个节区，共同映射到内存的只读可执行区域。\n0x01 ARM基础知识 \u0026ldquo;x86、arm、RISC-V\u0026rdquo; 都是 指令集架构 ( CPU架构 )。ARM 是主流的 RISC（精简指令集）架构，广泛用于嵌入式设备（如 Android 手机）。\n指令集特点\n固定指令长度（32 位 ARM 指令，Thumb 模式为 16 位）。\n大部分指令可条件执行（如ADDNE R0, R1, R2：仅当标志位不为 0 时执行加法）。\n寄存器操作优先（算术 / 逻辑运算通常基于寄存器，内存访问需专用指令）。\n核心寄存器\n​\tARM32 架构有 16 个通用寄存器（R0-R15），其中：\nR0-R3：函数调用参数 / 返回值寄存器。 R4-R11：通用寄存器（需手动保存）。 R12（IP）：临时寄存器。 R13（SP）：栈指针寄存器（指向栈顶）。 R14（LR）：链接寄存器（存储函数返回地址）。 R15（PC）：程序计数器（存储下一条执行的指令地址）。 常见寻址方式 寻址方式 描述 立即数寻址 直接使用立即数值作为操作数，例如：MOV R0, #5 寄存器直接寻址 使用寄存器中的值作为操作数，例如：MOV R0, R1 寄存器间接寻址 使用寄存器中的值作为内存地址，访问该地址中的数据，例如：LDR R0, [R1] 寄存器相对寻址 使用寄存器中的值加上一个立即偏移量作为内存地址，例如：LDR R0, [R1, #4] 寄存器变址寻址 使用两个寄存器中的值相加作为内存地址，例如：LDR R0, [R1, R2] 带有变址寄存器的寄存器相对寻址 使用寄存器中的值加上另一个寄存器的值乘以一个比例因子作为内存地址，例如：LDR R0, [R1, R2, LSL #2] 堆栈寻址 使用堆栈指针寄存器（如SP）进行操作，例如：PUSH {R0, R1} 或 POP {R0, R1} 压栈和出栈指令 指令类型 指令示例 描述 压栈 PUSH {R0, R1} 将寄存器R0和R1的内容压入堆栈中 压栈 PUSH {R0-R5} 将寄存器R0到R5的内容压入堆栈中 压栈 STMDB SP!, {R0-R5} 将寄存器R0到R5的内容压入堆栈中（与PUSH等效） 出栈 POP {R0, R1} 从堆栈中弹出数据，恢复到寄存器R0和R1中 出栈 POP {R0-R5} 从堆栈中弹出数据，恢复到寄存器R0到R5中 跳转指令 指令类型 指令示例 描述 无条件跳转 B label 无条件跳转到标签label指向的位置 子程序调用 BL label 调用子程序，将当前指令的下一条指令地址存入链接寄存器（LR），然后跳转到标签label指向的位置 子程序返回 BX LR 返回子程序调用前的位置，跳转到链接寄存器（LR）中存储的地址 寄存器跳转 BX Rn 跳转到寄存器Rn中存储的地址 算术运算指令 汇编中也可以进行算术运算， 比如加减乘除，常用的运算指令用法如表 所示：\n指令 计算公式 备注 ADD Rd, Rn, Rm Rd = Rn + Rm 加法运算，指令为 ADD ADD Rd, Rn, #immed Rd = Rn + #immed 加法运算，指令为 ADD ADC Rd, Rn, Rm Rd = Rn + Rm + 进位 带进位的加法运算，指令为 ADC ADC Rd, Rn, #immed Rd = Rn + #immed + 进位 带进位的加法运算，指令为 ADC SUB Rd, Rn, Rm Rd = Rn - Rm 减法 SUB Rd, #immed Rd = Rd - #immed 减法 SUB Rd, Rn, #immed Rd = Rn - #immed 减法 SBC Rd, Rn, #immed Rd = Rn - #immed - 借位 带借位的减法 SBC Rd, Rn ,Rm Rd = Rn - Rm - 借位 带借位的减法 MUL Rd, Rn, Rm Rd = Rn * Rm 乘法 (32 位) UDIV Rd, Rn, Rm Rd = Rn / Rm 无符号除法 SDIV Rd, Rn, Rm Rd = Rn / Rm 有符号除法 逻辑运算 汇编语言的时候也可以使用逻辑运算指令，常用的运算指令用法如表 所示： 0x02 Android so文件分析 1.SO 文件概述 SO 文件是 Unix/Linux 系统中的动态库文件，被称为共享目标文件（Shared Object File），后缀名为 .so，它是 ELF 的一种，另外属于 ELF 类型的还有可重定位文件（Relocatable File）以及核心转储文件（Core Dump File）。\nSO 文件通常用于提高开发效率、方便快速移植代码，以及保护 Android 应用的核心逻辑，增加逆向工程的难度。不同的 CPU 架构（如 ARM、x86 等）需要不同版本的 SO 文件来适配其指令集和运行环境。\nELF 文件类型 典型后缀 核心用途 逆向 / 开发场景举例 与 ARM 的关联 可执行文件 无（如/bin/ls） 直接运行的程序 分析 Linux/ARM 嵌入式设备的二进制逻辑 ARM32/64 位设备的可执行文件需对应架构 共享目标文件（SO） .so 供其他程序动态调用的库（代码复用 + 保护） 逆向 Android 的libnative.so（核心逻辑载体） Android SO 分armeabi-v7a（ARM32）、arm64-v8a（ARM64） 目标文件 .o 编译后的中间文件（未链接） 分析编译后的单个模块代码（如 NDK 编译的xxx.o） ARM 编译器（如arm-linux-androideabi-gcc）生成对应.o 核心转储文件 .core 程序崩溃时的内存快照 分析 SO 崩溃原因（如空指针访问导致的 core dump） ARM 设备崩溃时生成的 core 需用 ARM 架构的 gdb 分析 Android 是基于 Linux 内核开发的操作系统，所以 Android 平台上的可执行文件格式和 Unix/Linux 是一致的。\nso文件大体上可分为四部分，一般来说从上往下是ELF头部-\u0026gt;Pargarm头部-\u0026gt;节区(Section)-\u0026gt;节区头，其中，除了ELF头部在文件位置固定不变外，其余三部分的位置都不固定。\n整体结构图参考非虫大佬的图：\n2.SO 文件的加载方法 Android 通过 Java 层的System类加载 SO，核心方法有两种：\n方法 签名 特点 适用场景 loadLibrary System.loadLibrary(String name) 自动拼接文件名（name → libname.so），从默认路径（如/data/app/.../lib）加载。 应用内置 SO 的常规加载。 load System.load(String path) 需传入 SO 的绝对路径（如/sdcard/libtest.so）。 插件化加载、动态下载的 SO。 3.SO 文件的加载流程 loadLibrary 加载流程 调用 System.loadLibrary(String libName) 时，实际上会调用 Runtime.getRuntime().loadLibrary(String libName)。 Runtime.loadLibrary(String libName) 会进一步调用 Runtime.loadLibrary(String libName, ClassLoader loader)，其中 loader 是当前线程的类加载器。 通过类加载器找到对应的 SO 文件路径，然后调用 doLoad(String name, ClassLoader loader) 方法进行加载。 load 加载流程 调用 System.load(String pathName) 时，实际上会调用 Runtime.getRuntime().load(String pathName)。 Runtime.load(String pathName) 会调用 Runtime.load(String pathName, ClassLoader loader)，同样会调用 doLoad(String name, ClassLoader loader) 方法进行加载。 核心加载流程：doLoad 路径处理：doLoad 方法会根据传入的路径和类加载器，确定 SO 文件的实际路径。 动态链接库加载：调用 dlopen 函数加载动态链接库。 JNI_OnLoad 调用：如果 SO 文件中定义了 JNI_OnLoad 函数，则在加载完成后调用该函数进行初始化。 参考文件：\nAndroid so(ELF)文件解析\n《安卓逆向这档事》十、不是我说，有了IDA还要什么女朋友？\nandroid 加载so过程分析\n[ctfwiki]so 介绍 ","date":"2025-09-25T22:07:51+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250925233532.png","permalink":"https://fanshanng.cn/p/ar6/","title":"安卓逆向入门六：so(ELF)文件分析与ARM基础知识"},{"content":"一、手机端下载并配置光速虚拟机 3.8.2 1.下载模拟器：在手机应用商店或官方渠道，搜索并下载 “光速虚拟机 3.8.2” 版本，安装完成后打开，此时会指导进行解除安卓进程限制，跟着步骤来即可。\n2.创建安卓 10 实例：进入模拟器主界面，点击 “新建实例”，在系统版本选项中选择 “安卓 10”，等待实例创建完成（过程需耐心等待，避免中途退出)。\n3.开启 root 相关权限：\n进入已创建的安卓 10 实例，在实例浮窗内找到 “设置” 图标，进入后依次开启 “Magisk 支持” 和 “超级用户” 功能。 4.调整网络设置：\n因使用手机自身流量（路由器不支持远程 adb），需关闭网络隔离：进入浮窗内的 “设置 - 网络设置”，找到 “本地网络隔离” 选项，将其关闭（防止流量网络被隔离，影响后续连接）。 二、安装 Magisk25.0 完成 root 下载指定版本 Magisk：在安卓 10 实例内，通过浏览器访问 Magisk 官网旧版本页面，下载 “Magisk25.0” 安装包（高版本不兼容光速虚拟机 3.8.2，需严格选择 25.0 版本，其余低版本未曾尝试，可能也支持）。 安装 Magisk：\n找到下载好的 Magisk25.0 安装包，点击Magisk处的“安装”，弹出安装界面后直接点击 “下一步”，在安装方式中选择 “直接安装（推荐）”，等待安装进度完成。 重启验证 root： 安装完成后，按照提示重启安卓 10 实例；重启后先关闭实例内的 “超级用户” 功能，再重启，此时 root 操作完成（可通过实例内的 Magisk 应用查看 “已安装” 状态，确认 root 成功）。 三、在安卓 10 实例内开启开发者模式与 USB 调试 进入 “关于手机”：在安卓 10 实例内打开 “设置”，滑动至底部找到 “关于手机” 选项，点击进入。\n触发开发者模式：在 “关于手机” 页面中，找到 “版本号” 选项，连续点击 7 次 “版本号”，此时会弹出 “您现在处于开发者模式！” 的提示（若弹出验证密码 / 指纹，按实例内设置完成验证即可）。\n开启 USB 调试：返回 “设置” 主界面，找到 “系统” 选项；点击进入 “开发者选项”，找到 “USB 调试” 选项并开启（部分系统需勾选 “允许 USB 调试” 弹窗，点击 “确定” 即可）。\n四、电脑端通过 adb 远程连接手机 准备工作：确保电脑已提前下载并配置好 adb 环境（adb 工具包路径已添加至系统环境变量，可通过 “cmd 输入 adb \u0026ndash;version” 验证配置）。\n建立网络连接：\n打开手机的 “个人热点”，将电脑连接至该热点（确保手机与电脑处于同一热点网络，替代不支持 adb 的路由器）。 获取手机 IP： 在手机 “设置 - 无线和网络 - 个人热点” 中，查看热点的 “已连接设备” 或 “网络详情”，记录手机当前的 IP 地址（如 10.77.xx.xx）。 执行 adb 连接命令： 打开电脑的命令提示符（CMD），输入命令：adb connect 手机IP:6556（将 “手机 IP” 替换为实际记录的地址，如adb connect 10.77.xx.xx:6556）。\n若一切正常此时手机会弹出提示，点击确认即可。\n若命令行显示 “connected to 手机 IP:6556”，则表示远程 adb 调试连接成功，可开始进行后续调试操作。\n下载用的模拟器以及magisk：\nhttps://pan.baidu.com/s/1ePYYJIPQXNRKJyA9qJclWA?pwd=kdcq 提取码: kdcq\n","date":"2025-09-23T00:37:06+08:00","image":"https://s.panlai.com/upload/bizhihui_com_20231111141953169968359310619.jpg-arthumbs","permalink":"https://fanshanng.cn/p/gs/","title":"光速虚拟机3.8.2 root及adb远程连接操作"},{"content":"关键词：Xposed原理和常用api、Android Studio安装以及环境配置、hook、借助lspatch实现免root注入、SimpleHook快速hook\n0x00 什么是Xposed Xposed 是一款无需修改 APK 即可影响程序运行的 Hook 框架，基于它可以开发功能强大的插件 APP，实现对目标应用的注入、拦截、修改等操作，且多个功能不冲突的模块可同时运行。\n简单来说，Xposed 的核心是 “在不改变原应用代码的情况下，动态干预其运行逻辑”，这使得它成为安卓逆向、功能扩展的重要工具。\nXposed (维基百科)\n0x01 Xposed原理 Xposed 的核心是劫持 Zygote 进程（安卓系统的进程孵化器，所有应用进程都由它创建），具体过程如下：\n用自定义实现的app_process替换系统原生的app_process； 加载额外的 XposedBridge.jar 包，将程序入口从系统默认的com.android.internal.os.ZygoteInit.main()替换为de.robv.android.xposed.XposedBridge.main()； 改造后的 Zygote 进程创建的所有 Dalvik/ART 虚拟机都会被 Hook，从而实现对所有应用进程的动态干预。 通俗来讲，hook就是狸猫换太子\n0x02 Xposed的发展及免root框架 随着安卓版本迭代，Xposed 衍生出多个分支，下表整理了主流框架的特点：\n名称 地址 支持版本 是否免root xposed https://github.com/rovo89/Xposed 2.3-8.1 否 EDXposed https://github.com/ElderDrivers/EdXposed 8.0-10 否 LSPosed https://github.com/LSPosed/LSPosed 8.1-13 否 VirtualXposed https://github.com/android-hacker/VirtualXposed 5.0-10.0 是 太极 https://www.coolapk.com/apk/me.weishu.exp 5.0-13 是 两仪 https://www.coolapk.com/apk/io.twoyi 8.1-13 是 天鉴 https://github.com/Katana-Official/SPatch-Update 6-10 是 0x03 Xposed可以用来做什么？ 功能增强：修改应用布局（如上帝模式）、去除广告（如知乎去广告模块）；\n数据干预：劫持参数 / 返回值（如微信防撤回、步数修改、一键新机）；\n自动化操作：微信自动抢红包、抖音自动操作等；\n逆向辅助：动态分析应用逻辑、绕过加密 / 验证（如XServer）。\n2022 最好的Xposed模块: GravityBox, Pixelify, XPrivacyLua\n基于Xposed的抖音爬虫，抖音风控后自动一键新机，模拟一个全新的运行环境\n基于xposed的frida持久化方案\nA Xposed Module for Android Penetration Test, with NanoHttpd.\nGravityBox\nXposed-Modules-Repo]\n一个旨在使QQ变得更好用的开源Xposed模块\n杜比大喇叭\n哔哩漫游\n曲境\n自动化创建Xposed模块及钩子，让Xposed模块编写时只需关注钩子实现\n0x04 Xposed环境配置 这里下载的是正己提供的Ubuntu虚拟机 密码:toor\n内置:\nFrida开发环境 动态分析及开发工具：android-studio 动态分析工具：ddms 静态分析工具：jadx1.4.4 动静态分析工具：jeb 动态分析工具：集成HyperPwn 静态分析工具：010 editor 抓包工具：Charles 抓包工具：WireShark 动态分析工具:unidbg 1.Android Studio创建新项目\n2.将下载的xposedBridgeApi.jar包拖进libs文件夹\n3.右击jar包，选择add as library\n4.修改AndroidManifest.xml文件配置\n将如下代码复制到xml文件中，如图\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedmodule\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 模块描述，显示在xposed模块列表那里第二行 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposeddescription\u0026#34; android:value=\u0026#34;这是一个Xposed模块\u0026#34; /\u0026gt; \u0026lt;!-- 最低xposed版本号(lib文件名可知) --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedminversion\u0026#34; android:value=\u0026#34;89\u0026#34; /\u0026gt; 5.修改build.gradle,将此处修改为compileOnly 默认的是implementation\nimplementation 使用该方式依赖的库将会参与编译和打包\ncompileOnly 只在编译时有效，不会参与打包\n6.新建\u0026ndash;\u0026gt;Folder\u0026ndash;\u0026gt;Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类\n7.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑\n1 2 3 4 5 6 7 8 9 import de.robv.android.xposed.IXposedHookLoadPackage; import de.robv.android.xposed.callbacks.XC_LoadPackage; public class Hook implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { } } 继承了IXposedHookLoadPackag便拥有了hook的能力\n0x05 Xposed常用API 1.Hook普通方法 修改返回值\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(999); } }); 修改参数\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); String a = \u0026#34;pt\u0026#34;; param.args[0] = a; } }); 2.Hook复杂\u0026amp;自定义参数 1 2 3 4 5 6 7 8 Class a = loadPackageParam.classLoader.loadClass(\u0026#34;类名\u0026#34;); XposedBridge.hookAllMethods(a, \u0026#34;方法名\u0026#34;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } }); 3.Hook替换函数 使用XC_MethodReplacement直接替换原方法：\n1 2 3 4 5 6 7 Class a = classLoader.loadClass(\u0026#34;类名\u0026#34;) XposedBridge.hookAllMethods(a,\u0026#34;方法名\u0026#34;,new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return \u0026#34;\u0026#34;; } }); 上图中日志这里的 “这是替换函数” 就被替换无了\n4.Hook加固通杀 加固应用会动态加载 dex，需在Application.attach时获取加载后的类加载器：\n1 2 3 4 5 6 7 8 XposedHelpers.findAndHookMethod(Application.class, \u0026#34;attach\u0026#34;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Context context = (Context) param.args[0]; ClassLoader classLoader = context.getClassLoader(); //hook逻辑在这里面写 } }); 5.Hook变量 静态变量与实例变量 静态变量(static)：类被初始化，同步进行初始化 非静态变量：类被实例化(产生一个对象的时候)，进行初始化 6.Hook构造函数 无参构造函数\n1 2 3 4 5 6 7 8 9 10 XposedHelpers.findAndHookConstructor(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, classLoader, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 有参构造函数\n1 2 3 4 5 6 7 8 9 10 XposedHelpers.findAndHookConstructor(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, classLoader, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 7.Hook multiDex方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 XposedHelpers.findAndHookMethod(Application.class, \u0026#34;attach\u0026#34;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { ClassLoader cl= ((Context)param.args[0]).getClassLoader(); Class\u0026lt;?\u0026gt; hookclass=null; try { hookclass=cl.loadClass(\u0026#34;类名\u0026#34;); }catch (Exception e){ Log.e(\u0026#34;zj2595\u0026#34;,\u0026#34;未找到类\u0026#34;,e); return; } XposedHelpers.findAndHookMethod(hookclass, \u0026#34;方法名\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { } }); } }); 8.主动调用 静态方法\n1 2 Class clazz = XposedHelpers.findClass(\u0026#34;类名\u0026#34;,lpparam.classLoader); XposedHelpers.callStaticMethod(clazz,\u0026#34;方法名\u0026#34;,参数(非必须)); 实例方法\n1 2 Class clazz = XposedHelpers.findClass(\u0026#34;类名\u0026#34;,lpparam.classLoader); XposedHelpers.callMethod(clazz.newInstance(),\u0026#34;方法名\u0026#34;,参数(非必须)); 9.Hook内部类 内部类名格式为外部类$内部类（如com.zj.wuaipojie.Demo$InnerClass）\n1 2 3 4 5 6 7 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo$InnerClass\u0026#34;, lpparam.classLoader, \u0026#34;innerFunc\u0026#34;,String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } }); 10.反射大法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Class clazz = XposedHelpers.findClass(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, lpparam.classLoader); XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo$InnerClass\u0026#34;, lpparam.classLoader, \u0026#34;innerFunc\u0026#34;,String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); //第一步找到类 //找到方法，如果是私有方法就要setAccessible设置访问权限 //invoke主动调用或者set修改值(变量) Class democlass = Class.forName(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;,false,lpparam.classLoader); Method demomethod = democlass.getDeclaredMethod(\u0026#34;refl\u0026#34;); demomethod.setAccessible(true); demomethod.invoke(clazz.newInstance()); } }); 11.遍历所有类下的所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 XposedHelpers.findAndHookMethod(ClassLoader.class, \u0026#34;loadClass\u0026#34;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Class clazz = (Class) param.getResult(); String clazzName = clazz.getName(); //排除非包名的类 if(clazzName.contains(\u0026#34;com.zj.wuaipojie\u0026#34;)){ Method[] mds = clazz.getDeclaredMethods(); for(int i =0;i\u0026lt;mds.length;i++){ final Method md = mds[i]; int mod = mds[i].getModifiers(); //去除抽象、native、接口方法 if(!Modifier.isAbstract(mod) \u0026amp;\u0026amp; !Modifier.isNative(mod) \u0026amp;\u0026amp;!Modifier.isAbstract(mod)){ XposedBridge.hookMethod(mds[i], new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.d(\u0026#34;zj2595\u0026#34;,md.toString()); } }); } } } } }); 0x06 Xposed妙用 字符串赋值定位:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 XposedHelpers.findAndHookMethod(\u0026#34;android.widget.TextView\u0026#34;, lpparam.classLoader, \u0026#34;setText\u0026#34;, CharSequence.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); Log.d(\u0026#34;zj2595\u0026#34;,param.args[0].toString()); if(param.args[0].equals(\u0026#34;已过期\u0026#34;)){ printStackTrace(); } } }); private static void printStackTrace() { Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); for (int i = 0; i \u0026lt; stackElements.length; i++) { StackTraceElement element = stackElements[i]; Log.d(\u0026#34;zj2595\u0026#34;,\u0026#34;at \u0026#34; + element.getClassName() + \u0026#34;.\u0026#34; + element.getMethodName() + \u0026#34;(\u0026#34; + element.getFileName() + \u0026#34;:\u0026#34; + element.getLineNumber() + \u0026#34;)\u0026#34;); } } 点击事件监听\n1 2 3 4 5 6 7 8 9 10 11 Class clazz = XposedHelpers.findClass(\u0026#34;android.view.View\u0026#34;, lpparam.classLoader); XposedBridge.hookAllMethods(clazz, \u0026#34;performClick\u0026#34;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); Object listenerInfoObject = XposedHelpers.getObjectField(param.thisObject, \u0026#34;mListenerInfo\u0026#34;); Object mOnClickListenerObject = XposedHelpers.getObjectField(listenerInfoObject, \u0026#34;mOnClickListener\u0026#34;); String callbackType = mOnClickListenerObject.getClass().getName(); Log.d(\u0026#34;zj2595\u0026#34;,callbackType); } }); 改写布局\n在 Activity 初始化后修改 UI 元素（如隐藏图片）：\n1 2 3 4 5 6 7 8 9 10 11 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.ui.ChallengeSixth\u0026#34;, lpparam.classLoader, \u0026#34;onCreate\u0026#34;, Bundle.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); View img = (View)XposedHelpers.callMethod(param.thisObject, \u0026#34;findViewById\u0026#34;, 0x7f0800de); img.setVisibility(View.GONE); } }); 修改前 修改后 0x07 Lsposed 免root实现 Lsposed：LSPosed 框架的无 Root 实现方案，通过将 dex 文件与 so 文件插入到目标 APK（安卓应用安装包）中，实现 Xposed API（应用程序编程接口）的集成。 核心原理：重打包目标 APK，将模块代码集成到其中，避免对系统环境的依赖。 0x07 Xposed快速Hook\u0026mdash;\u0026ndash;SimpleHook SimpleHook 是 GitHub 用户 littleWhiteDuck 开发的一款 Android 轻量型 Hook 工具，核心定位是 “简单易用”—— 无需复杂配置即可实现常见 Hook 需求，适合对 Hook 操作复杂度要求低的用户；若需复杂功能（如自定义脚本）或更多扩展能力，官方推荐搭配 jshook（复杂功能）、曲境（电脑端浏览器操作）或算法助手（扩展功能）使用。\n使用步骤： 在 LSPosed 中启用 SimpleHook 模块； 选择目标应用，添加 Hook 配置（类名、方法名、参数类型等）； 重启应用，配置生效。 工具覆盖多种常见 Hook 场景，部分关键模式及示例如下：\n模式类型 功能说明 关键特点 Hook 返回值 修改目标方法的返回结果，支持基本类型（如 boolean、int）、字符串及 null 参数类型留空表示无参，多参数用英文逗号分隔（如 java.lang.String,int） Hook 返回值 + 进阶功能，支持通过 JSON 格式将数据转为目标对象（依赖 Gson） 需填写 “返回值类名”，修改值为 JSON 字符串（如 {\u0026quot;isHook\u0026quot;:false,\u0026quot;level\u0026quot;:10000}） Hook 参数值 修改目标方法的输入参数，支持部分参数或全部参数修改 未修改的参数留空（如仅改第 2、3 个参数，修改值填 ,啦啦啦,99） 中断执行 拦截目标方法执行，使其不触发原有逻辑 无需填写修改值，仅需配置类名、方法名及参数类型 特殊方法 Hook - 构造方法：方法名填写 \u0026lt;init\u0026gt;- 所有同名方法：参数类型填 *- 类内所有方法：方法名填 * 适配不同场景下的批量或特殊方法 Hook 需求 变量 Hook - 静态变量：支持 before/after 两个 Hook 点（方法执行前后修改）- 实例变量：仅支持在本类方法执行后修改，不可跨类 仅支持基本类型和字符串，需填写 “变量所在类名”“变量名” 记录类模式（3 种） 记录参数值、记录返回值、记录参返（参数 + 返回值） 数组或 List 类型参数 / 返回值会自动转为 JSON 格式，便于查看 该软件还满足自定义hook，具体细节请前往SimpleHook学习。\n参考文档 《安卓逆向这档事》七、Sorry，会Hook真的可以为所欲为-Xposed快速上手(上)\n《安卓逆向这档事》八、Sorry，会Hook真的可以为所欲为-xposed快速上手(下)\n源码编译（2）——Xopsed源码编译详解 Xposed Hook技巧，代{过}{滤}理abstract Xposed callMethod 如何传入接口参数\nXPOSED魔改一：获取特征 Lsposed 技术原理探讨 \u0026amp;\u0026amp; 基本安装使用\n","date":"2025-09-21T23:31:39+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250921233613.png","permalink":"https://fanshanng.cn/p/ar5/","title":"安卓逆向入门五：Xposed和hook入门"},{"content":"安卓逆向入门四 关键词：apk签名、apk校验及对抗方法、PM代理、io重定向\n学习链接：https://www.52pojie.cn/thread-1731181-1-1.html\n0x00 APK签名 校验是开发者在数据传送时采用的一种校正数据的一种方式 常见的校验有:签名校验(最常见)、dexcrc校验、apk完整性校验、路径文件校验等\n什么是APK签名? 我建议直接去看 Android 官方文档 中关于 APK签名 的安全特性介绍。\nAPK签名是开发者使用私钥对安卓应用进行数字签名的过程，确保应用的完整性和来源，防止被篡改。只有经过签名的应用才能在安卓设备上安装和运行，签名还帮助系统识别应用的开发者，并确保应用在独立的沙盒环境中安全运行。 Android 目前支持以下四种应用签名方案： v1 方案：基于 JAR 签名。 v2 方案：APK 签名方案 v2（在 Android 7.0 中引入） v3 方案：APK 签名方案 v3（在 Android 9 中引入） v4 方案：APK 签名方案 v4（在 Android 11 中引入） 签名方案 推出版本 校验范围 安全优势 局限性 适用场景 v1（JAR 签名） Android 1.0 仅校验 APK 内单个文件（META-INF 下签名文件） 兼容所有安卓版本 可篡改未签名文件（如新增文件） 需兼容 Android 6.0 及以下设备 v2 Android 7.0 校验整个 APK（通过 “签名块” 校验 APK 完整性） 更高效（无需解压）、防篡改新增文件 不兼容 Android 6.0 及以下 目标设备为 Android 7.0+ v3 Android 9.0 在 v2 基础上支持 “签名轮换”（更换签名无需卸载旧版） 支持签名更新（如企业应用换证书） 依赖 Android 9.0+ 需要签名更新的应用（如企业级 APP） v4 Android 11.0 生成单独的签名文件（.apksig），支持增量更新校验 优化大文件安装效率（仅校验变更部分） 依赖 Android 11.0+ 大型应用（如游戏）的增量更新 v4签名生成的.apksig文件必须配合adb install --incremental使用，常规APK安装不会触发此校验。逆向中较少遇到，主要用于Google Play增量更新。 一次让你搞懂Android应用签名 这篇文章讲了签名步骤和原理相关知识，值得一看 APP 的签名检验 系统更多的只是对 APK 做完整性校验，身份校验很容易通过卸载方式来解决，因此许多 APP 为了防止自身被修改和破解，会对自身进行额外的校验，确保没有被修改。\n我们一般称此类检查自身是否被修改的保护技术为签名校验，其校验原理几乎也都是基于文件完整性检验与签名身份信息验证。\n1 2 3 4 5 kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因. system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。 finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理 普通获取签名校验代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private boolean SignCheck() { String trueSignMD5 = \u0026#34;d0add9987c7c84aeb7198c3ff26ca152\u0026#34;; String nowSignMD5 = \u0026#34;\u0026#34;; try { // 得到签名的MD5 PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),PackageManager.GET_SIGNATURES); Signature[] signs = packageInfo.signatures; String signBase64 = Base64Util.encodeToString(signs[0].toByteArray()); nowSignMD5 = MD5Utils.MD5(signBase64); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return trueSignMD5.equals(nowSignMD5); } 系统将应用的签名信息封装在PackageInfo中，调用 PackageManager 的getPackageInfo(String packageName, int flags)即可获取指定包名的签名信息.\n0x01 签名校验对抗 方法一:核心破解插件，不签名安装应用 方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能 方法三:具体分析签名校验逻辑(手撕签名校验) 方法四:io重定向\u0026ndash;VA\u0026amp;SVC：ptrace+seccomp SVC的TraceHook沙箱的实现\u0026amp;无痕Hook实现思路 方法五:去作者家严刑拷打拿到.jks文件和密码\n0x02 手动实现PM代{过}{滤}理 1.什么是PMS 思路源自：Android中Hook 应用签名方法\nPackageManagerService（简称PMS），是Android系统核心服务之一，处理包管理相关的工作，常见的比如安装、卸载应用等。\n核心原理\n安卓应用获取签名的流程：应用调用PackageManager.getPackageInfo() → 系统通过PMS（PackageManagerService）查询签名信息并返回； PM 代理的本质：通过 Hook 替换PMS的返回结果 —— 当应用查询签名时，返回原始合法签名（而非修改后 APK 的签名），从而绕过校验。 使用条件与限制\n环境要求：需要 root 权限（修改系统服务）或通过 Xposed/LSPosed 框架（无需 root，但需模块支持）； 局限性：仅对通过PackageManager获取签名的校验有效，若应用直接读取 APK 文件计算签名（如读取/data/app/xxx.apk的签名），则 PM 代理无效（需结合IO重定向，将应用访问的APK路径（如/data/app/包名/base.apk）重定向到保留原始签名的伪造APK文件（仅包含签名所需文件，如META-INF/）。 2.实现方法以及原理解析 HOOK PMS代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.zj.hookpms; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import android.content.Context; import android.content.pm.PackageManager; import android.util.Log; public class ServiceManagerWraper { public final static String ZJ = \u0026#34;ZJ595\u0026#34;; public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) { try { // 获取全局的ActivityThread对象 Class\u0026lt;?\u0026gt; activityThreadClass = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 获取ActivityThread里面原始的sPackageManager Field sPackageManagerField = activityThreadClass.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); // 准备好代{过}{滤}理对象, 用来替换原始的对象 Class\u0026lt;?\u0026gt; iPackageManagerInterface = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{iPackageManagerInterface}, new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0)); // 1. 替换掉ActivityThread里面的 sPackageManager 字段 sPackageManagerField.set(currentActivityThread, proxy); // 2. 替换 ApplicationPackageManager里面的 mPM对象 PackageManager pm = context.getPackageManager(); Field mPmField = pm.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPmField.setAccessible(true); mPmField.set(pm, proxy); } catch (Exception e) { Log.d(ZJ, \u0026#34;hook pms error:\u0026#34; + Log.getStackTraceString(e)); } } public static void hookPMS(Context context) { String Sign = \u0026#34;原包的签名信息\u0026#34;; hookPMS(context, Sign, \u0026#34;com.zj.hookpms\u0026#34;, 0); } } ActivityThread的静态变量sPackageManager ApplicationPackageManager对象里面的mPM变量\n0x03 IO重定向 什么是IO重定向？\nI/O重定向是指改变程序的标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）的默认设备，将其与其他设备或文件进行关联。通过I/O重定向，我们可以将程序的输入从键盘转向文件或其他设备，将程序的输出和错误信息输出到文件或其他设备而不是屏幕上。\n例：在读A文件的时候指向B文件\n平头哥的核心代码 Virtual Engine for Android(Support 12.0 in business version)\nIO重定向可以干嘛？\n1，可以让文件只读，不可写\n2，禁止访问文件\n3，路径替换\n具体实现： 过签名检测(读取原包) 风控对抗(例:一个文件记录App启动的次数) 过Root检测，Xposed检测(文件不可取)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 using namespace std; string packname; string origpath; string fakepath; int (*orig_open)(const char *pathname, int flags, ...); int (*orig_openat)(int,const char *pathname, int flags, ...); FILE *(*orig_fopen)(const char *filename, const char *mode); static long (*orig_syscall)(long number, ...); int (*orig__NR_openat)(int,const char *pathname, int flags, ...); void* (*orig_dlopen_CI)(const char *filename, int flag); void* (*orig_dlopen_CIV)(const char *filename, int flag, const void *extinfo); void* (*orig_dlopen_CIVV)(const char *name, int flags, const void *extinfo, void *caller_addr); static inline bool needs_mode(int flags) { return ((flags \u0026amp; O_CREAT) == O_CREAT) || ((flags \u0026amp; O_TMPFILE) == O_TMPFILE); } bool startsWith(string str, string sub){ return str.find(sub)==0; } bool endsWith(string s,string sub){ return s.rfind(sub)==(s.length()-sub.length()); } bool isOrigAPK(string path){ if(path==origpath){ return true; } return false; } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_open 函数有三个参数： //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 int fake_open(const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } //LOGI(\u0026#34;open, path: %s, flags: %d, mode: %d\u0026#34;,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_open, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_open(\u0026#34;/data/user/0/com.zj.wuaipojie/files/base.apk\u0026#34;, flags, mode); } return orig_open(pathname, flags, mode); } //该函数的功能是在打开一个文件时进行拦截，并在满足特定条件时将文件路径替换为另一个路径 //fake_openat 函数有四个参数： //fd：一个整数，表示要打开的文件的文件描述符。 //pathname：一个字符串，表示要打开的文件的路径。 //flags：一个整数，表示打开文件的方式，例如只读、只写、读写等。 //mode（可选参数）：一个整数，表示打开文件时应用的权限模式。 //openat 函数的作用类似于 open 函数，但是它使用文件描述符来指定文件路径，而不是使用文件路径本身。这样，就可以在打开文件时使用相对路径，而不必提供完整的文件路径。 //例如，如果要打开相对于当前目录的文件，可以使用 openat 函数，而不是 open 函数，因为 open 函数只能使用绝对路径。 // int fake_openat(int fd, const char *pathname, int flags, ...) { mode_t mode = 0; if (needs_mode(flags)) { va_list args; va_start(args, flags); mode = static_cast\u0026lt;mode_t\u0026gt;(va_arg(args, int)); va_end(args); } LOGI(\u0026#34;openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,fd ,pathname, flags ,mode); string cpp_path= pathname; if(isOrigAPK(cpp_path)){ LOGI(\u0026#34;libc_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,pathname, fakepath.data()); return orig_openat(fd,fakepath.data(), flags, mode); } return orig_openat(fd,pathname, flags, mode); } FILE *fake_fopen(const char *filename, const char *mode) { string cpp_path= filename; if(isOrigAPK(cpp_path)){ return orig_fopen(fakepath.data(), mode); } return orig_fopen(filename, mode); } //该函数的功能是在执行系统调用时进行拦截，并在满足特定条件时修改系统调用的参数。 //syscall 函数是一个系统调用，是程序访问内核功能的方法之一。使用 syscall 函数可以调用大量的系统调用，它们用于实现操作系统的各种功能，例如打开文件、创建进程、分配内存等。 // static long fake_syscall(long number, ...) { void *arg[7]; va_list list; va_start(list, number); for (int i = 0; i \u0026lt; 7; ++i) { arg[i] = va_arg(list, void *); } va_end(list); if (number == __NR_openat){ const char *cpp_path = static_cast\u0026lt;const char *\u0026gt;(arg[1]); LOGI(\u0026#34;syscall __NR_openat, fd: %d, path: %s, flags: %d, mode: %d\u0026#34;,arg[0] ,arg[1], arg[2], arg[3]); if (isOrigAPK(cpp_path)){ LOGI(\u0026#34;syscall __NR_openat, redirect: %s, ---\u0026gt;: %s\u0026#34;,arg[1], fakepath.data()); return orig_syscall(number,arg[0], fakepath.data() ,arg[2],arg[3]); } } return orig_syscall(number, arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]); } //函数的功能是获取当前应用的包名、APK 文件路径以及库文件路径，并将这些信息保存在全局变量中 //函数调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getPackageName 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getPackageName 方法，获取当前应用的包名。最后，函数使用 GetStringUTFChars 函数将包名转换为 C 字符串，并将包名保存在 packname 全局变量中 //接着，函数使用 fakepath 全局变量保存了 /data/user/0/\u0026lt;packname\u0026gt;/files/base.apk 这样的路径，其中 \u0026lt;packname\u0026gt; 是当前应用的包名。 //然后，函数再次调用 GetObjectClass 和 GetMethodID 函数来获取 context 对象的类型以及 getApplicationInfo 方法的 ID。然后，函数调用 CallObjectMethod 函数来调用 getApplicationInfo 方法，获取当前应用的 ApplicationInfo 对象。 //它先调用 GetObjectClass 函数获取 ApplicationInfo 对象的类型，然后调用 GetFieldID 函数获取 sourceDir 字段的 ID。接着，函数使用 GetObjectField 函数获取 sourceDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。最后，函数将 C 字符串保存在 origpath 全局变量中，表示当前应用的 APK 文件路径。 //最后，函数使用 GetFieldID 和 GetObjectField 函数获取 nativeLibraryDir 字段的值，并使用 GetStringUTFChars 函数将其转换为 C 字符串。函数最后调用 LOGI 函数打印库文件路径，但是并没有将其保存在全局变量中。 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_zj_wuaipojie_util_SecurityUtil_hook(JNIEnv *env, jclass clazz, jobject context) { jclass conext_class = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack = env-\u0026gt;GetMethodID(conext_class, \u0026#34;getPackageName\u0026#34;, \u0026#34;()Ljava/lang/String;\u0026#34;); auto packname_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;CallObjectMethod(context, methodId_pack)); const char *pn = env-\u0026gt;GetStringUTFChars(packname_js, 0); packname = string(pn); env-\u0026gt;ReleaseStringUTFChars(packname_js, pn); //LOGI(\u0026#34;packname: %s\u0026#34;, packname.data()); fakepath= \u0026#34;/data/user/0/\u0026#34;+ packname +\u0026#34;/files/base.apk\u0026#34;; jclass conext_class2 = env-\u0026gt;GetObjectClass(context); jmethodID methodId_pack2 = env-\u0026gt;GetMethodID(conext_class2,\u0026#34;getApplicationInfo\u0026#34;,\u0026#34;()Landroid/content/pm/ApplicationInfo;\u0026#34;); jobject application_info = env-\u0026gt;CallObjectMethod(context,methodId_pack2); jclass pm_clazz = env-\u0026gt;GetObjectClass(application_info); jfieldID package_info_id = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;sourceDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto sourceDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id)); const char *sourceDir = env-\u0026gt;GetStringUTFChars(sourceDir_js, 0); origpath = string(sourceDir); LOGI(\u0026#34;sourceDir: %s\u0026#34;, sourceDir); jfieldID package_info_id2 = env-\u0026gt;GetFieldID(pm_clazz,\u0026#34;nativeLibraryDir\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); auto nativeLibraryDir_js = reinterpret_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(application_info,package_info_id2)); const char *nativeLibraryDir = env-\u0026gt;GetStringUTFChars(nativeLibraryDir_js, 0); LOGI(\u0026#34;nativeLibraryDir: %s\u0026#34;, nativeLibraryDir); //LOGI(\u0026#34;%s\u0026#34;, \u0026#34;Start Hook\u0026#34;); //启动hook void *handle = dlopen(\u0026#34;libc.so\u0026#34;,RTLD_NOW); auto pagesize = sysconf(_SC_PAGE_SIZE); auto addr = ((uintptr_t)dlsym(handle,\u0026#34;open\u0026#34;) \u0026amp; (-pagesize)); auto addr2 = ((uintptr_t)dlsym(handle,\u0026#34;openat\u0026#34;) \u0026amp; (-pagesize)); auto addr3 = ((uintptr_t)fopen) \u0026amp; (-pagesize); auto addr4 = ((uintptr_t)syscall) \u0026amp; (-pagesize); //解除部分机型open被保护 mprotect((void*)addr, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr2, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr3, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); mprotect((void*)addr4, pagesize, PROT_READ | PROT_WRITE | PROT_EXEC); DobbyHook((void *)dlsym(handle,\u0026#34;open\u0026#34;), (void *)fake_open, (void **)\u0026amp;orig_open); DobbyHook((void *)dlsym(handle,\u0026#34;openat\u0026#34;), (void *)fake_openat, (void **)\u0026amp;orig_openat); DobbyHook((void *)fopen, (void *)fake_fopen, (void**)\u0026amp;orig_fopen); DobbyHook((void *)syscall, (void *)fake_syscall, (void **)\u0026amp;orig_syscall); } 1 2 3 4 5 6 7 sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils; invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;getContext()Landroid/content/Context; move-result-object p10 invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;-\u0026gt;hook(Landroid/content/Context;)V 0x04 其他常见校验 root检测：\n反制手段 1.算法助手、对话框取消等插件一键hook 2.分析具体的检测代码 3.利用IO重定向使文件不可读 4.修改Andoird源码，去除常见指纹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fun isDeviceRooted(): Boolean { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3() } fun checkRootMethod1(): Boolean { val buildTags = android.os.Build.TAGS return buildTags != null \u0026amp;\u0026amp; buildTags.contains(\u0026#34;test-keys\u0026#34;) } fun checkRootMethod2(): Boolean { val paths = arrayOf(\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;, \u0026#34;/su/bin/su\u0026#34;) for (path in paths) { if (File(path).exists()) return true } return false } fun checkRootMethod3(): Boolean { var process: Process? = null return try { process = Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;)) val bufferedReader = BufferedReader(InputStreamReader(process.inputStream)) bufferedReader.readLine() != null } catch (t: Throwable) { false } finally { process?.destroy() } } 定义了一个 isDeviceRooted() 函数，该函数调用了三个检测 root 的方法：checkRootMethod1()、checkRootMethod2() 和 checkRootMethod3()。\ncheckRootMethod1() 方法检查设备的 build tags 是否包含 test-keys。这通常是用于测试的设备，因此如果检测到这个标记，则可以认为设备已被 root。\ncheckRootMethod2() 方法检查设备是否存在一些特定的文件，这些文件通常被用于执行 root 操作。如果检测到这些文件，则可以认为设备已被 root。\ncheckRootMethod3() 方法使用 Runtime.exec() 方法来执行 which su 命令，然后检查命令的输出是否不为空。如果输出不为空，则可以认为设备已被 root。\n模拟器检测\n1 2 3 fun isEmulator(): Boolean { return Build.FINGERPRINT.startsWith(\u0026#34;generic\u0026#34;) || Build.FINGERPRINT.startsWith(\u0026#34;unknown\u0026#34;) || Build.MODEL.contains(\u0026#34;google_sdk\u0026#34;) Build.MODEL.contains(\u0026#34;Emulator\u0026#34;) || Build.MODEL.contains(\u0026#34;Android SDK built for x86\u0026#34;) || Build.MANUFACTURER.contains(\u0026#34;Genymotion\u0026#34;) || Build.HOST.startsWith(\u0026#34;Build\u0026#34;) || Build.PRODUCT == \u0026#34;google_sdk\u0026#34; } 通过检测系统的 Build 对象来判断当前设备是否为模拟器。具体方法是检测 Build.FINGERPRINT 属性是否包含字符串 \u0026quot;generic\u0026quot;。\n模拟器检测对抗\n反调试检测\n安卓系统自带调试检测函数 1 2 3 4 5 6 fun checkForDebugger() { if (Debug.isDebuggerConnected()) { // 如果调试器已连接，则终止应用程序 System.exit(0) } } debuggable属性 1 2 3 4 5 6 public boolean getAppCanDebug(Context context)//上下文对象为xxActivity.this { boolean isDebug = context.getApplicationInfo() != null \u0026amp;\u0026amp; (context.getApplicationInfo().flags \u0026amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; return isDebug; } ptrace检测 1 2 3 4 int ptrace_protect()//ptrace附加自身线程 会导致此进程TracerPid 变为父进程的TracerPid 即zygote { return ptrace(PTRACE_TRACEME,0,0,0);;//返回-1即为已经被调试 } 每个进程同时刻只能被1个调试进程ptrace ，主动ptrace本进程可以使得其他调试器无法调试\n调试进程名检测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int SearchObjProcess() { FILE* pfile=NULL; char buf[0x1000]={0}; pfile=popen(\u0026#34;ps\u0026#34;,\u0026#34;r\u0026#34;); if(NULL==pfile) { //LOGA(\u0026#34;SearchObjProcess popen打开命令失败!\\n\u0026#34;); return -1; } // 获取结果 //LOGA(\u0026#34;popen方案:\\n\u0026#34;); while(fgets(buf,sizeof(buf),pfile)) { char* strA=NULL; char* strB=NULL; char* strC=NULL; char* strD=NULL; strA=strstr(buf,\u0026#34;android_server\u0026#34;);//通过查找匹配子串判断 strB=strstr(buf,\u0026#34;gdbserver\u0026#34;); strC=strstr(buf,\u0026#34;gdb\u0026#34;); strD=strstr(buf,\u0026#34;fuwu\u0026#34;); if(strA || strB ||strC || strD) { return 1; // 执行到这里，判定为调试状态 } } pclose(pfile); return 0; } [原创]对安卓反调试和校验检测的一些实践与结论\nfrida检测 一些Frida检测手段\n0x05 smali语法\u0026mdash;\u0026ndash;赋值 1.Int型赋值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 .method private static final onCreate$lambda-0(Lcom/zj/wuaipojie/ui/SmaliLearn;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/widget/TextView;Landroid/view/View;)V .registers 9 .line 21 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;isVip()I move-result p4 //判断vip的值分别对应不用的会员的等级 if-eqz p4, :cond_35 const/4 v0, 0x1 if-eq p4, v0, :cond_2d const/4 v0, 0x4 if-eq p4, v0, :cond_25 const/16 v0, 0x10 if-eq p4, v0, :cond_1d const/16 v0, 0x63 if-eq p4, v0, :cond_15 goto :goto_3c :cond_15 const-string p4, \u0026#34;至尊会员\u0026#34; .line 26 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_1d const-string p4, \u0026#34;超级会员\u0026#34; .line 25 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_25 const-string p4, \u0026#34;大会员\u0026#34; .line 24 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_2d const-string p4, \u0026#34;会员\u0026#34; .line 23 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_3c :cond_35 const-string p4, \u0026#34;非会员\u0026#34; .line 22 check-cast p4, Ljava/lang/CharSequence; invoke-virtual {p1, p4}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 28 //判断vipEndTime的时间戳是否小于系统时间 :goto_3c new-instance p1, Ljava/util/Date; invoke-direct {p1}, Ljava/util/Date;-\u0026gt;\u0026lt;init\u0026gt;()V invoke-virtual {p1}, Ljava/util/Date;-\u0026gt;getTime()J move-result-wide v0 .line 29 new-instance p1, Ljava/text/SimpleDateFormat; const-string p4, \u0026#34;yyyy-MM-dd\u0026#34; invoke-direct {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;\u0026lt;init\u0026gt;(Ljava/lang/String;)V .line 30 invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v2 cmp-long p4, v2, v0 if-gez p4, :cond_5c const-string p1, \u0026#34;已过期\u0026#34; .line 31 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V goto :goto_6d .line 33 :cond_5c invoke-virtual {p0}, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vipEndTime()J move-result-wide v0 invoke-static {v0, v1}, Ljava/lang/Long;-\u0026gt;valueOf(J)Ljava/lang/Long; move-result-object p4 invoke-virtual {p1, p4}, Ljava/text/SimpleDateFormat;-\u0026gt;format(Ljava/lang/Object;)Ljava/lang/String; move-result-object p1 check-cast p1, Ljava/lang/CharSequence; invoke-virtual {p2, p1}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V .line 35 :goto_6d iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V :cond_74 return-void .end method const/4和const/16的区别？\nconst/4 最大只允许存放4个二进制位(4bit)，\nconst/16 最大值允许存放16个二进制位(16bit)， 第一位(即最高位)默认为符号位。单位换算 1byte=8bit 举例说明下寄存器的取值范围: # 以下数据定义高位默认为符号位\nconst/4 v0,0x2 # 最大只允许存放半字节数据 取值范围为 -8 and 7\nconst/16 v0 , 0xABCD # 定义一个寄存器变量，最大只允许存放16位数据 比如short类型数据 取值范围为-32768~32767\nconst v0 , 0xA# 定义一个寄存器， 最大只允许存放32位数据,比如int类型数据 将数字10赋值给v0 取值范围-2147483647~2147483647\nconst/high16 #定义一个寄存器， 最大只允许存放高16位数值 比如0xFFFF0000末四位补0 存入高四位0XFFFF\n2.Long型赋值 const-wide vx, lit32 表示将一个 32 位的常量存储到 vx 与 vx+1 两个寄存器中 —— 即一个 long 类型的数据\n1 2 3 4 5 6 7 .method public final vipEndTime()J .registers 3 const-wide v0, 0x1854460ef29L return-wide v0 .end method -会员到期时间就是2022年12月24日。那么1854460ef29L 怎么来的呢？也就是（2022年12月24日-1970年1月1日）×365天×24小时×60分钟×60秒×1000毫秒，转换成16进制就大概是那个数了\n在线时间戳转换\n3.变量赋值(正则) 1 2 3 4 5 6 7 8 9 10 11 12 iget p0, p0, Lcom/zj/wuaipojie/ui/SmaliLearn;-\u0026gt;vip_coin:I if-eqz p0, :cond_74 .line 36 invoke-static {p0}, Ljava/lang/String;-\u0026gt;valueOf(I)Ljava/lang/String; move-result-object p0 check-cast p0, Ljava/lang/CharSequence; invoke-virtual {p3, p0}, Landroid/widget/TextView;-\u0026gt;setText(Ljava/lang/CharSequence;)V *. ** 这个表示任意寄存器，什么寄存器都能匹配，所以你正则查找的时候只需把寄存器替换成这个就可以了 (.*) 这里多了个英文小括号，框哪个就是对哪个寄存器赋值。 参考文章：\nAPK 签名：v1 v2 v3 v4 如何把签名校验做到极致 Android PMS HOOK [实战破解]白描-动态代{过}{滤}理Hook签名校验 [原创]对安卓反调试和校验检测的一些实践与结论 新版MT去签及对抗 【小白教程】正则匹配的写法 多行匹配 批量赋值 smali逆向 简单实用\n逆向之Smali入门学习\n","date":"2025-07-20T12:02:51+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124723.png","permalink":"https://fanshanng.cn/p/ar4/","title":"安卓逆向入门四"},{"content":"安卓逆向入门三 学习关键词: Jeb、动态调试、Log插桩\n学习链接：《安卓逆向这档事》五、1000-7=？\u0026amp;动态调试\u0026amp;Log插桩\nJEB学习 环境配置\nJava环境配置，我这里不细讲。没有配置过java环境的我建议去看看 多个 JDK 版本（Java 8、Java 17、Java 21）下载和切换 这篇文章，我的建议是一开始就做好java多版本共存的准备 下载JEB\nJEB (Java Editor for Android) 是一款用于安卓应用逆向工程的工具，它可以帮助开发者分析和修改安卓应用的字节码。\njeb推荐jdk-11或jdk-17（我用的是jdk-11）\n下载教程可以看这篇文章：JEB动态调试Smali-真机/模拟器（详细，新手必看）\n本次学习下载正己提供的jeb安装包，下载好就可以使用，如果需要激活就去看上面的文章\n动态调试 熟悉IDA的逆向人应该知道动态调试是什么，这里指的是Android动态调试，\n修改方法：\n修改debug权限 **方法一:**在AndroidManifest.xml里添加可调试权限\n1 android:debuggable=\u0026#34;true\u0026#34; **方法二：**XappDebug模块hook对应的app\n**方法三：**Magisk命令(重启失效)\n1 2 3 4 5 6 7 1. adb shell #adb进入命令行模式 2. su #切换至超级用户 3. magisk resetprop ro.debuggable 1 4. stop;start; #一定要通过该方式重启 **方法四:**刷入MagiskHide Props Config模块\n一般来说，在4选项中如果有ro.debuggable那就直接修改\n没有的话就选5\n端口转发以及开启adb权限 版本号点击七次开启开发者模式并开启adb调试权限 有时候重新进入模拟器的时候usb调试会取消，需要手动开启 下断点 ctrl+b下断点\ndebug模式启动 1 adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity adb shell am start -D -n adb shell am start -D -n 包名/类名 am start -n 表示启动一个activity am start -D 表示将应用设置为可调试模式\nJeb附加调试进程 常用快捷键： F6 进入方法 F6 跳过方法 F7 从方法中跳出来 R 运行到光标处\n运行到断点 步进 得到参数值：5qKA5q61DAUM\nLog插桩 定义：Log 插桩是在反编译 APK 后的 Smali 代码中插入日志输出语句，通过Log.v()等方法将关键变量、函数调用过程打印到系统日志，适用于无法动态调试或需要追踪后台逻辑的场景。\n1 invoke-static {对应寄存器}, Lcom/mtools/LogUtils;-\u0026gt;v(Ljava/lang/Object;)V 在应用里随机输入字符串，然后查看日志 ","date":"2025-06-26T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250720124652.png","permalink":"https://fanshanng.cn/p/ar3/","title":"安卓逆向入门三"},{"content":"0x00 smali及其语法 smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。 Smali是Dalvik虚拟机和ART运行时的寄存器指令语言，相当于Android平台的汇编语言。当APK被反编译时，DEX文件会转换为Smali代码（.smali文件），它是逆向分析的核心载体。\n关键字\n名称 注释 .class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应\nsmali类型 java类型 注释 V void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx/xxx/xxx object 对象类型，返回对象 常用指令\n关键字 注释 const 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a=b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!=b)，ab内容不相同则跳 if-eqz 全称equal zero(a=0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!=0)，a不等于0则跳 if-ge 全称greater equal(a\u0026gt;=b)，a大于或等于则跳 if-le 全称little equal(a\u0026lt;=b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 “vip终结者” 定位方法：\n搜索弹窗关键字（用jd-gui搜索字符串）、抓取按钮id（本质与前一个方法一样）\n（字符串有时候是用unicode显示，搜关键文字搜不到的话可以试试搜对应的unicode）\n（此处演示的是抓取按钮id）\n修改方法：\n修改判断、强制跳转、修改寄存器的值 (这里与反调试中修改标志位或者修改跳转指令类似)\ndemo代码例子（注释为正己所写）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 //一个私有、静态、不可变的方法 方法名 .method private static final onCreate$lambda-2(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z //(这里面是方法的参数)这里是方法返回值类型，表示布尔值类型，返回假或真 .registers 7 //寄存器数量 .line 33 //代码所在的行数 iget p0, p0, Lkotlin/jvm/internal/Ref$IntRef;-\u0026gt;element:I //读取p0(第一个参数，参考寄存器知识)中element的值赋值给p0 const/4 p5, 0x1 //p5赋值1 const/16 v0, 0xa //v0赋值10，在16进制里a表示10 if-ge p0, v0, :cond_15 //判断p0的值是否大于或等于v0的值(即p0的值是否大于或等于10)，如果大于或等于则跳转到:cond_15 .line 34 //以下是常见的Toast弹窗代码 check-cast p1, Landroid/content/Context; //检查Context对象引用 const-string p0, \u0026#34;请先获取10个硬币哦\u0026#34; //弹窗文本信息，把\u0026#34;\u0026#34;里的字符串数据赋值给p0 check-cast p0, Ljava/lang/CharSequence; //检查CharSequence对象引用 invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; //将弹窗文本、显示时间等信息传给p1 move-result-object p0 //结果传递给p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V //当看到这个Toast;-\u0026gt;show你就应该反应过来这里是弹窗代码 goto :goto_31 //跳转到:goto_31 :cond_15 //跳转的一个地址 invoke-virtual {p1}, Lcom/zj/wuaipojie/ui/ChallengeSecond;-\u0026gt;isvip()Z //判断isvip方法的返回值是否为真(即结果是否为1) move-result p0 //结果赋值给p0 if-eqz p0, :cond_43 //如果结果为0则跳转cond_43地址 const p0, 0x7f0d0018 //在arsc中的id索引，这个值可以进行查询 .line 37 invoke-virtual {p2, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V //设置图片资源 const p0, 0x7f0d0008 .line 38 invoke-virtual {p3, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V const p0, 0x7f0d000a .line 39 invoke-virtual {p4, p0}, Landroid/widget/ImageView;-\u0026gt;setImageResource(I)V .line 40 sget-object p0, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/SPUtils; check-cast p1, Landroid/content/Context; const/4 p2, 0x2 //p2赋值2 const-string p3, \u0026#34;level\u0026#34; //sp的索引 invoke-virtual {p0, p1, p3, p2}, Lcom/zj/wuaipojie/util/SPUtils;-\u0026gt;saveInt(Landroid/content/Context;Ljava/lang/String;I)V //写入数据 goto :goto_50 //跳转地址 :cond_43 check-cast p1, Landroid/content/Context; const-string p0, \u0026#34;\\u8bf7\\u5148\\u5145\\u503c\\u5927\\u4f1a\\u5458\\u54e6\\uff01\u0026#34; //请先充值大会员哦！ check-cast p0, Ljava/lang/CharSequence; invoke-static {p1, p0, p5}, Landroid/widget/Toast;-\u0026gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p0 invoke-virtual {p0}, Landroid/widget/Toast;-\u0026gt;show()V :goto_50 return p5 //返回p5的值 .end method //方法结束 //判断是否是大会员的方法 .method public final isvip()Z .registers 2 const/4 v0, 0x0 //v0赋值0 return v0 //返回v0的值 .end method 寄存器机制 命名规则：v0-vN 本地寄存器，p0-pN 参数寄存器 关键特性： 非静态方法中 p0 固定表示this指针 静态方法中 p0 对应第一个参数 64位类型(long/double)占用两个连续寄存器（如v0-v1） 这里可以切换成Smali语言（但是java代码更好看一点）\n0x02 activity的切换 组件 描述 Activity(活动) 在应用中的一个Activity可以用来表示一个界面，意思可以理解为“活动”，即一个活动开始，代表 Activity组件启动，活动结束，代表一个Activity的生命周期结束。一个Android应用必须通过Activity来运行和启动，Activity的生命周期交给系统统一管理。 Service(服务) Service它可以在后台执行长时间运行操作而没有用户界面的应用组件，不依赖任何用户界面，例如后台播放音乐，后台下载文件等。 Broadcast Receiver(广播接收器) 一个用于接收广播信息，并做出对应处理的组件。比如我们常见的系统广播：通知时区改变、电量低、用户改变了语言选项等。 Content Provider(内容提供者) 作为应用程序之间唯一的共享数据的途径，Content Provider主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。Android内置的许多数据都是使用Content Provider形式，供开发者调用的（如视频，音频，图片，通讯录等） 广告拦截实战 启动广告流程： 启动Activity-\u0026gt;广告Activity-\u0026gt;主页Activity\n修改方法：\n1.修改加载时间\n此小节中用到了mt管理器的Activity管理器，可以用于记录广告用到的AdActivity类 然后通过类名搜索可以定位到代码位置\n转换成java 阅读java代码，然后可以知道有一个3000毫秒广告显示时间，退回到smali代码中修改为零即可。\n2.Acitivity切换定位，修改Intent的Activity类名（直接在AndroidManifest.xml文件中修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!---声明实现应用部分可视化界面的 Activity，必须使用 AndroidManifest 中的 \u0026lt;activity\u0026gt; 元素表示所有 Activity。系统不会识别和运行任何未进行声明的Activity。-----\u0026gt; \u0026lt;activity android:label=\u0026#34;@string/app_name\u0026#34; android:name=\u0026#34;com.zj.wuaipojie.ui.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!--当前Activity是否可以被另一个Application的组件启动：true允许被启动；false不允许被启动--\u0026gt; \u0026lt;!---指明这个activity可以以什么样的意图(intent)启动---\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;!--表示activity作为一个什么动作启动，android.intent.action.MAIN表示作为主activity启动---\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;!--这是action元素的额外类别信息，android.intent.category.LAUNCHER表示这个activity为当前应用程序优先级最高的Activity--\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFirst\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFifth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeFourth\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeThird\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.ChallengeSecond\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;com.zj.wuaipojie.ui.AdActivity\u0026#34; /\u0026gt; ​\n3.在classes.dex文件中查找并修改\n图一为之前的查找内容，图二是类的一个smali路径代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 switch (position) { case 0: Intent intent = new Intent(); intent.setClass(it.getContext(), ChallengeFirst.class); it.getContext().startActivity(intent); return; case 1: Intent intent2 = new Intent(); intent2.setClass(it.getContext(), ChallengeSecond.class); it.getContext().startActivity(intent2); return; case 2: Intent intent3 = new Intent(); //new一个Intent， intent3.setClass(it.getContext(), AdActivity.class); //传入要切换的Acitivity的类名 it.getContext().startActivity(intent3); //启动对应的Activity return; case 3: Intent intent4 = new Intent(); intent4.setClass(it.getContext(), ChallengeFourth.class); it.getContext().startActivity(intent4); return; default: return; } 0x03 Activity生命周期 函数名称 描述 onCreate() 一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。 onStart() 当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。 onResume() 这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。 onPause() 这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。 onStop() 这个方法是在Activity完全不可见的时候调用的。 onDestroy() 这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。 onRestart() 当Activity从停止stop状态恢进入start状态时调用状态。 0x04 弹窗定位\u0026amp;堆栈分析 修改方法： 1.修改xml中的versioncode 2.Hook弹窗(推荐算法助手开启弹窗定位) 这里demo中的广告返回键被劫持，只能跟着广告走，就需要hook\n3.修改dex弹窗代码 在算法助手里找到最新的日志，找到对应打方法名，然后搜索查找对应-\u0026gt;show()代码，删掉或者注释掉就行\n4.抓包修改响应体(也可以路由器拦截) 0x05 布局优化 1.开发者助手抓布局 2.MT管理器xml搜索定位 3.修改xml代码 用的软件：开发助手（可以识别到图片信息），通过搜索Veiw id（hex），可以查找到对应的xml文件，注意这里是xml文件不是之前的dex文件里搜索。 此处既可以修改图片显示的长宽，也可以通过加入下面这段代码隐藏（布局隐藏，文字图片都可以隐藏）。\n1 android:visibility=\u0026#34;gone\u0026#34; ","date":"2025-06-01T01:03:40+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/20250601010933131.png","permalink":"https://fanshanng.cn/p/ar2/","title":"安卓逆向入门二"},{"content":"热身题 re1 flag{1c98572d-7f7b-4fbf-8750-4a2986c695ce}\n注意到如下代码是关键：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 v29 = *(_WORD *)v16; v30 = sub_7FF7D5E81800(v4, 1i64); if ( !v30 ) sub_7FF7D5E9AFA0(1i64, v4); v31 = (_BYTE *)v30; for ( i = 0i64; i != v4; ++i ) { HIWORD(v33) = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1); LOWORD(v33) = v29; v29 = v33 \u0026gt;\u0026gt; 1; v34 = __ROL1__(v33, 4); v35 = (4 * (v34 \u0026amp; 0x33)) | (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33; v31[i] = *(_BYTE *)(v16 + i) ^ (i + ((2 * (v35 \u0026amp; 0x55)) | (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)); } if ( v4 == 42 \u0026amp;\u0026amp; !memcmp(v31, \u0026amp;unk_7FF7D5E9C458, 42ui64) ) { sub_7FF7D5E817E0(v31, 42i64, 1i64); v39 = \u0026amp;off_7FF7D5E9C4A0; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } else { sub_7FF7D5E817E0(v31, v4, 1i64); v39 = (void **)\u0026amp;off_7FF7D5E9C488; Src = (void *)1; v41 = 8i64; v42 = 0i64; sub_7FF7D5E85750(\u0026amp;v39); } 其实就是对输入做了xor，用的序列也是由输入的前两个字节+下标生成，那么z3就是一个很自然的想法。偷懒用AI写的代码。注意需要限制开头字符是flag才能解出唯一解，或者用cfbb的这个办法获取所有解。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from z3 import * def rol1_byte(value: int, shift: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Rotate left 1 byte (8 bits) with carry-over\u0026#34;\u0026#34;\u0026#34; shift %= 8 return ((value \u0026lt;\u0026lt; shift) | (value \u0026gt;\u0026gt; (8 - shift))) \u0026amp; 0xFF def transform_data(input_data: bytes) -\u0026gt; bytearray: \u0026#34;\u0026#34;\u0026#34; Replicates the transformation logic from the original code: - Processes each byte with a custom bit manipulation algorithm - Uses a rolling state (v29) that affects subsequent bytes - Applies XOR with transformed index values \u0026#34;\u0026#34;\u0026#34; n = len(input_data) output = bytearray(n) v29 = (input_data[1] \u0026lt;\u0026lt; 8) | input_data[0] for i in range(n): # HIWORD/LOWORD simulation (assuming v33 is 32-bit) hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = (hiword \u0026lt;\u0026lt; 16) | (loword \u0026amp; 0xFFFF) v29 = v33 \u0026gt;\u0026gt; 1 # Bit manipulation steps v34 = rol1_byte(v33 \u0026amp; 0xFF, 4) # __ROL1__(v33, 4) v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # Final XOR operation transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) output[i] = input_data[i] ^ (transformed_index \u0026amp; 0xFF) return output # 目标密文 Buf2 = bytes([ 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B ]) # 创建 Z3 求解器 solver = Solver() # 定义输入变量（每个字节是一个 8 位无符号整数） input_bytes = [BitVec(f\u0026#39;byte_{i}\u0026#39;, 8) for i in range(len(Buf2))] # 初始化状态变量 v29 (32-bit) #v29 = BitVecVal(0, 32) v29 = Concat(input_bytes[1], input_bytes[0]) for i in range(len(Buf2)): # HIWORD/LOWORD 计算 hiword = (v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1) loword = v29 v33 = Concat(Extract(15, 0, hiword), Extract(15, 0, loword)) # 更新 v29 v29 = v33 \u0026gt;\u0026gt; 1 # ROL1(v33, 4) - 取最低字节并循环左移4位 v34_lowbyte = Extract(7, 0, v33) v34 = RotateLeft(v34_lowbyte, 4) # v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33) # 修正后的计算方式： part1 = (v34 \u0026amp; 0x33) \u0026lt;\u0026lt; 2 part2 = (v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33 v35 = part1 | part2 # transformed_index = i + ((2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55)) part_a = (v35 \u0026amp; 0x55) \u0026lt;\u0026lt; 1 part_b = (v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55 transformed_index = i + (part_a | part_b) # 添加约束：input_byte ^ (transformed_index的低8位) == cipher_byte solver.add(input_bytes[i] ^ Extract(7, 0, transformed_index) == Buf2[i]) # 检查是否有解 solver.add(input_bytes[0] == ord(\u0026#39;f\u0026#39;)) solver.add(input_bytes[1] == ord(\u0026#39;l\u0026#39;)) solver.add(input_bytes[2] == ord(\u0026#39;a\u0026#39;)) solver.add(input_bytes[3] == ord(\u0026#39;g\u0026#39;)) def get_models(s, count = 1): result = [] while len(result) \u0026lt; count and s.check() == sat: m = s.model() sol = bytes([m[input_bytes[i]].as_long() for i in range(len(Buf2))]) result.append(sol) # Create a new constraint the blocks the current model block = [] for d in m: # d is a declaration if d.arity() \u0026gt; 0: raise Z3Exception(\u0026#34;uninterpreted functions are not supported\u0026#34;) # create a constant from declaration c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception(\u0026#34;arrays and uninterpreted sorts are not supported\u0026#34;) block.append(c != m[d]) s.add(Or(block)) return result m = get_models(solver, 1000) print(m) 补一个c语言脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int main() { unsigned char output[42] = { 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27, 0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68, 0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B }; unsigned char input[42] = { 0 }; input[0] = \u0026#39;f\u0026#39;; input[1] = \u0026#39;l\u0026#39;; uint16_t v29 = (input[1] \u0026lt;\u0026lt; 8) | input[0]; for (int i = 0; i \u0026lt; 42; ++i) { uint32_t v33= (((v29 \u0026gt;\u0026gt; 2) ^ (v29 \u0026gt;\u0026gt; 3) ^ (v29 \u0026gt;\u0026gt; 1)) \u0026lt;\u0026lt; 16) | v29; v29 = (v33 \u0026gt;\u0026gt; 1) \u0026amp; 0xFFFF; uint8_t v34 = ((v33 \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | ((v33 \u0026amp; 0xFF) \u0026gt;\u0026gt; 4); // 循环左移4位 uint8_t v35 = (4 * (v34 \u0026amp; 0x33)) | ((v34 \u0026gt;\u0026gt; 2) \u0026amp; 0x33); uint8_t combined = (2 * (v35 \u0026amp; 0x55)) | ((v35 \u0026gt;\u0026gt; 1) \u0026amp; 0x55); uint8_t index = (i + combined) \u0026amp; 0xFF; input[i] = output[i] ^ index; } for (int i = 0; i \u0026lt; 42; ++i) { printf(\u0026#34;%c\u0026#34;, input[i]); } return 0; } re2 flag{cdb0444318e24beb8f374e9181599072}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { uint8_t v8[16] = { 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 }; uint8_t v9[16] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10 }; const char* target = \u0026#34;cge87k?9\u0026lt;\u0026gt;?@=pss393=\u0026gt;;8@:Cp@DAuH\u0026#34;; uint8_t enc[32]; memcpy(enc, target, 32); uint8_t flag[33]; for (int i = 0; i \u0026lt; 32; i += 16) { // 先减去v9[j] for (int j = 0; j \u0026lt; 16; j++) { flag[i + j] = enc[i + j] - v9[j]; } // 反转块以实现逆置换 for (int j = 0; j \u0026lt; 8; j++) { int pos1 = i + j; int pos2 = i + 15 - j; uint8_t temp = flag[pos1]; flag[pos1] = flag[pos2]; flag[pos2] = temp; } } flag[32] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;flag{%s}\\n\u0026#34;, flag); return 0; } //flag{cdb0444318e24beb8f374e9181599072} 很简单的一道题，唯一就是涉及到一定的sse语句\n","date":"2025-05-30T23:34:46+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/a0457db2a018c2ee683618e3e5a3b90e_720.jpg","permalink":"https://fanshanng.cn/p/jqctf/","title":"京麒ctf 2025（复盘中）"},{"content":"hook随记 此文目前为摘录他人\nhook（钩子）是一种编程机制，在操作系统、编程里也会用到。\nhook的作用是让程序能够在特定事件发生时插入自定义代码，或者对系统行为进行拦截和修改。它是一种软件设计模式，借助预留接口，实现对系统或框架原有流程的扩展与增强。\nJava中有一种机制，叫做动态代理（Dynamic Proxy），它可以被视为一种特殊的运行时钩子（Runtime Hook），因为它允许你在不修改原有代码的情况下，拦截并增强对象方法的调用。\n在编程中，Hook（钩子）的本质是一种 “程序拦截机制”，它允许你在不修改原始代码的前提下，介入并改变程序的执行流程。这种机制通过注入自定义逻辑到现有系统的特定点来实现增强或修改功能的目的。\n以JavaScript为例， 源代码\n1 2 3 4 5 6 function add(a,b){ return a + b } res = add(1,3) console.log(\u0026#34;结果: \u0026#34; + res) 结果显而易见，是4.\n但是，我们想在不改变调用的情况下，在执行add方法时，在其前面打印”add方法执行“，结束时打印”add方法结束“，并让返回的结果+1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function add(a, b) { return a + b; } const hook = { originalAdd: add // 立即保存引用 }; // 重新定义add函数 add = function(a, b) { console.log(\u0026#34;add方法调用前\u0026#34;); let res = hook.originalAdd(a, b); console.log(\u0026#34;add方法调用后\u0026#34;); return res + 1; }; let res = add(1, 3); console.log(\u0026#34;结果: \u0026#34; + res); // 输出5 结果如图：\n调用的代码并未变化，但是结果发声改变了。 上述的案例就是一个hook的过程。 它先将原函数对象的引用（即内存地址）保存起来，然后在新函数中调用原add函数，最后令add指向一个新函数。\n","date":"2025-05-30T10:26:28+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/1.jpg","permalink":"https://fanshanng.cn/p/hk/","title":"Hook"},{"content":"安卓逆向入门一 0x01 前置 下载migisk\nMagisk（俗称面具），是一个ROOT工具。\n它提供了多种功能，包括但不限于： 1 2 3 4 MagiskSU: 提供应用程序的 root 访问权限。 Magisk 模块: 通过安装模块来修改只读分区。 MagiskBoot: 用于解包和重新打包 Android 启动镜像的最完整工具。 Zygisk: 在每个 Android 应用程序的进程中运行代码。 不要去Magisk中文网,这里用的是正己提供的安装包\n这里如果下载失败的话，可以去设置里修改下图选项\n0x02 apk的文件结构 Apk结构 apk 全称 Android Package，它相当于一个压缩文件，只要在电脑上将apk后缀改为zip即可解压。\n文件 注释 assets目录 存放APK的静态资源文件，比如视频，音频，图片等 lib 目录 armeabi-v7a基本通用所有android设备，arm64-v8a只适用于64位的android设备，x86常见用于android模拟器，其目录下的.so文件是c或c++编译的动态链接库文件 META-INF目录 保存应用的签名信息，签名信息可以验证APK文件的完整性，相当于APK的身份证(验证文件是否又被修改) res目录 res目录存放资源文件，包括图片，字符串等等，APK的脸蛋由他的layout文件设计 AndroidManifest.xml文件 APK的应用清单信息，它描述了应用的名字，版本，权限，引用的库文件等等信息 classes.dex文件 classes.dex是java源码编译后生成的java字节码文件，APK运行的主要逻辑 resources.arsc文件 resources.arsc是编译后的二进制资源文件，它是一个映射表，映射着资源和id，通过R文件中的id就可以找到对应的资源 demo实例中另外出现的kotlin代表这个apk文件大概是有kotlin语言编写，OkHttp 是一个流行的开源 HTTP 客户端库，用于发送和接收网络请求。 Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。\nKotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\n在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。\n0x03 双开及原理 指手机同时运行两个或多个相同的应用\n【VirtualAPP 双开系列08】如何实现多开 - UID\n通过在宿主容器上面新建一个进程供插件 APK 寄宿，然后通过 hook 一些系统接口欺骗应用—让虚拟化后应用以为自己是正常运行的独立 APP，欺骗系统—让系统认为此虚拟化应用是一个已正常安装在系统的应用。\n原理 解释 修改包名 让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 修改Framework 对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 通过虚拟化技术实现 虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 以插件机制运行 利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 0x04 汉化APK 1.Arsc汉化\n2.xml汉化\n3.Dex汉化 (教程里的汉化插件需要vip，我这里是手动改的，知道原理就行)\n教程中用到的主要就是在mt管理器或者np管理器中对文件进行字符串搜索（管理器中设置了自动签名），如果手动的话，可以反编译改源码等 apk安装包快速反编译，多种反编译及失败的解决方案\n这是汉化前⬇\n这是汉化（手改）后⬇\n0x05 初识AndroidManifest.xml AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。\n注：这里文件名不能修改\nAndroidManifest.xml 最全详解 AndroidManifest.xml文件主要包含以下几个元素：\n元素 功能描述 action 添加一个action到intent filter activity 声明 activity组件 activity-alias 声明activity别名 application 声明应用程序 category 添加一个category名称到intent filter compatible-screens 定义应用所兼容的每种屏幕配置 data 添加数据定义到intent filter grant-uri-permission 定义应用数据的子集以供父内容提供者有权限可以访问 instrumentation 声明Instrumentation工具类并是您可以监控应用程序的交互系统 intent-filter 定义activity、service或者是broadcast receiver可以响应的意图（intent）类型， manifest AndroidManifest.xml文件中的根元素 meta-data 一条额外添加的名称-值对，可以给父组件提供任意的数据。 path-permission 在content provider内定义所需路径和权限特定子集数据 permission 声明一个安全权限，可以用来限制访问特定应用的组件或功能 permission-group 声明一个相关权限的逻辑组名称 permission-tree 声明权限树的基础名称 provider 声明一个内容提供者(content provider)组件 receiver 声明一个广播接收器(broadcast receiver)组件 service 声明一个服务(service)组件 supports-gl-texture 声明一种应用单一支持的GL纹理(texture)压缩格式 supports-screens 声明应用所支持的屏幕尺寸大小以及在启用兼容模式下系统屏幕超出应用所支持的尺寸 uses-configuration 声明应用程序的软硬件需求 uses-feature 声明应用程序需要用到的软、硬件特性。 uses-library 指定应用程序必须引用的共享库 uses-permission 指定了让应用程序正常运行，用户必须授予的系统权限。 uses-permission-sdk-23 指定了应用程序在Android 6.0以上所需的特定权限 uses-sdk 通过API整数值来声明应用程序所兼容的Android平台版 MT管理器使用手册\nAndroid逆向0基础入门-APK全面解析,动调与脱壳\n","date":"2025-05-25T16:15:22+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/preview.jpg","permalink":"https://fanshanng.cn/p/ar1/","title":"安卓逆向学习一"},{"content":"并非是wp，而是做题过程中的一些记录\nluck_guy 主函数 ①.Case2 和 case3 只是一个打印函数。 ②.strcat 是连接字符串函数，所以 case4 是对 s 赋值并将 s 与 f2 进行拼接。 ③.case5 是对 f2 进行处理：j 为奇数，f2 减 2；j 为偶数，f2 减 1。 ④.Case1 是要得到 flag，首先memset函数先对 s 进行初始化，s 变成了一个空数组，所以之后的 strcat 函数相当于直接把 f1 复制到了 s 里，再之后的 strcat 函数将 s 与 f2 连接相当于 f1 与 f2 连接，最终打印出来的 flag 就是 f1 加上 f2。 s=0x7F666F6067756369LL，按r键将它转换为字符就是“\\x7Ffo`guci”，这里要注意是小端序存储！所以要把字符顺序反过来，就是“icug`of\\x7F” 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char f2[] = \u0026#34;icug`of\\x7F\u0026#34;; for (int j = 0; j \u0026lt; 8; ++j) { if ( j % 2 == 1 ) f2[j]-=2; else f2[j]--; } printf(\u0026#34;%s\u0026#34;,f2); return 0; } 刮开有奖 加密逻辑其实挺清晰的一道题，快速排序+base64编码，快速排序这里不懂的话可以去问ai，不过还是要自己判断，也可以把代码复制下来在vscode中运行一遍看看结果 但是第一次疑惑的地方是加密排序那个数组a1只初始化了两个数，但是它的结束索引却是十。这里学到的知识是：\n根据这段初始化，知道这段的地址是连续的。所以实际上是一个长度为11的数组，别问我为什么不动调，F9点开后调不了一点 然后就是\n对比判断的时候这里用的是地址处的值也就是说是排序后的值\n然后要提一嘴的是\n具体可以去看这里 WinMain函数 （winbase.h） WinMain 函数（Windows图形应用程序入口点）\n1 2 3 4 5 6 int __clrcall WinMain( [in] HINSTANCE hInstance, [in, optional] HINSTANCE hPrevInstance, [in] LPSTR lpCmdLine, [in] int nShowCmd ); 参数： hInstance：当前应用程序实例的句柄。 hPrevInstance：上一个实例的句柄（在现代Windows中始终为NULL）。 lpCmdLine：命令行参数，不包括程序名称。 nShowCmd：控制窗口显示方式的标志。 返回值：程序的退出状态码，通常返回 WM_QUIT 消息的 wParam 参数值。\neasyre 脱壳后的主函数 分析比较语句，大致猜到v5就是输入的函数，这里的意思是输入字符的ascii值+1后作为索引进行判断\npython中的find()函数是找到对应的下标值 1 2 3 4 5 6 7 8 9 10 11 12 U U9 U9X U9X_ U9X_1 U9X_1S U9X_1S_ U9X_1S_W U9X_1S_W6 U9X_1S_W6@ U9X_1S_W6@T U9X_1S_W6@T? [GUET-CTF2019]re 考z3处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from z3 import * solver = Solver() # 使用Int类型而非BitVec，并添加字符范围约束 a1 = [Int(f\u0026#39;a1_{i}\u0026#39;) for i in range(32)] # 添加所有等式约束 solver.add(1629056 * a1[0] == 166163712) solver.add(6771600 * a1[1] == 731332800) solver.add(3682944 * a1[2] == 357245568) solver.add(10431000 * a1[3] == 1074393000) solver.add(3977328 * a1[4] == 489211344) solver.add(5138336 * a1[5] == 518971936) solver.add(7532250 * a1[7] == 406741500) solver.add(5551632 * a1[8] == 294236496) solver.add(3409728 * a1[9] == 177305856) solver.add(13013670 * a1[10] == 650683500) solver.add(6088797 * a1[11] == 298351053) solver.add(7884663 * a1[12] == 386348487) solver.add(8944053 * a1[13] == 438258597) solver.add(5198490 * a1[14] == 249527520) solver.add(4544518 * a1[15] == 445362764) solver.add(3645600 * a1[17] == 174988800) solver.add(10115280 * a1[16] == 981182160) solver.add(9667504 * a1[18] == 493042704) solver.add(5364450 * a1[19] == 257493600) solver.add(13464540 * a1[20] == 767478780) solver.add(5488432 * a1[21] == 312840624) solver.add(14479500 * a1[22] == 1404511500) solver.add(6451830 * a1[23] == 316139670) solver.add(6252576 * a1[24] == 619005024) solver.add(7763364 * a1[25] == 372641472) solver.add(7327320 * a1[26] == 373693320) solver.add(8741520 * a1[27] == 498266640) solver.add(8871876 * a1[28] == 452465676) solver.add(4086720 * a1[29] == 208422720) solver.add(9374400 * a1[30] == 515592000) solver.add(5759124 * a1[31] == 719890500) # 确保每个字符在0-255范围内（ASCII） for c in a1: solver.add(c \u0026gt;= 0, c \u0026lt;= 255) if solver.check() == sat: model = solver.model() flag = \u0026#39;\u0026#39;.join([chr(model[c].as_long()) for c in a1]) # type: ignore print(\u0026#34;\u0026#34;, flag) else: print(\u0026#34;无解\u0026#34;) # flag{e65421110ba03099a1c039337} 但是疑惑的是少了一位，最后看别人题解都是爆破出来的（，a1[6]=\u0026lsquo;1\u0026rsquo;, 所以正确的应该是flag{e165421110ba03099a1c039337}\nCrackRTF 这道题的考点是rtf文件,主要的逻辑是先输入六个数字拼接@DBApp然后判断hash-sha1编码，这里爆破出的结果是123321，然后是长度为6的字符串，拼接在一起进行MD5编码，由于MD5编码不可逆，我尝试过爆破，生成所有 6 位组合，总数为 95^6 ≈ 735 亿次，遂放弃。\nRTF是Rich Text Format的缩写，意即多文本格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 char __cdecl sub_4014D0(LPCSTR Destination) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026#34;AAA\u0026#34;);// FindResourceA 函数用于查找程序资源中的一个资源。 // 第一个参数为 NULL，表示查找当前进程的资源。 // 第二个参数为资源标识符，这里是 0x65。 // 第三个参数为资源类型，这里是 \u0026#34;AAA\u0026#34;。 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo);// SizeofResource 函数用于获取资源的大小。 // 如果资源大小为 0，表示资源无效。 hResData = LoadResource(0, hResInfo); // LoadResource 函数用于加载资源。 if ( !hResData ) return 0; lpBuffer = LockResource(hResData); // LockResource 函数用于锁定资源，并返回资源的指针。 sub_401005(Destination, (int)lpBuffer, nNumberOfBytesToWrite);// 异或 hFile = CreateFileA(\u0026#34;dbapp.rtf\u0026#34;, GENERIC_ALL, 0, 0, CREATE_ALWAYS, FILE_READ_ATTRIBUTES, 0);// CreateFileA 函数用于创建或打开一个文件。 // 文件名为 \u0026#34;dbapp.rtf\u0026#34;。 // 打开模式为 CREATE_ALWAYS，表示如果文件不存在则创建，如果存在则覆盖。 // 文件访问权限为 GENERIC_ALL，表示完全访问权限。 if ( hFile == (HANDLE)-1 ) // 如果文件创建失败，返回 0。 return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); // 关闭文件句柄。 return 1; } 这里就是我们输入的东西拼接后与“AAA”文件中的读取的前几位异或\n从网上找到rtf的示例文件下下来对比发现前几位都是一样的\n把前几位截下来，然后进行异或处理就能得到前六位~!3a@0123321,很明显**~!3a@0**为所求。于是在ida中动调，生成rtf文件，打开后得到flag ","date":"2025-05-22T21:08:17+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/2.jpg","permalink":"https://fanshanng.cn/p/buuctf/","title":"Buuctf刷题记录"},{"content":"BigBanana 第一次做vm题，做了挺久就来好好记录一下 那CTF，那VMre，那些事（一） VM逆向，一篇就够了 这两篇文章让我收获很大，了解了基础的vm组成结构，和基础的解题方法。\n这道题虽说是vm题，但又不完全是，总体结构很简单，一个类似于 VM 的东西，有一个栈、一个指令序列和 4 个寄存器。 打开主函数能很明显的看到操作字节码与对应的handle函数，不过需要注意的是这里的是已经减一后的结果 再查看函数过程中遇到的问题是有点看不懂处理函数的作用，并且提取出来的opcode是byte类型不是dword（byte类型也能做，后面会讲） 提取出opcode后，能很明显看到，前面很长一段都是用来打印一段话的，没有什么用，主要是eip=2888后面的（即input后面的) 思路文档如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 F4, 01 ⽴即数加法 F4是R1加 ，01是R2加 F3 两个数异或 赋值给R1 F2 cmp 后⾯跟着应该的结果 FE 对cmp的结果进行check F0 把上⼀次结果保存 10 getchar并推上栈 F8 push 栈[0]字符 出R2 F7 push 栈[1]字符 出R1 这里f8(R2)指向694e694d，f7(R1)指向74632d4c 10 10 f8 f7 f4 694e694d 01 74632d4c f4 00 f3 f2 1d2d440f fe (R1+694e694d+00)^(R2+74632d4c)=1d2d440f,检查，保存 66 f0 10 f8 f4 16 01 21 f4 114514 f3 f2 74747250 fe 此时输入的值弹到R2里了 所以就是(input+21)^(74632d4c(R1即前一个字符)+16+114514) 66 f0 10 f8 f4 21 01 2c f4 228a28 f3 f2 228a4d fe 66 f0 10 f8 f4 2c 01 0b f4 33cf3c f3 f2 33cfaa fe 66 f0 10 f8 f4 0b 01 16 f4 451450 f3 f2 4514cb fe 66 f0 10 f8 f4 16 01 21 f4 565964 f3 f2 565966 fe 66 f0 10 f8 f4 21 01 2c f4 679e78 f3 f2 679fbc fe 66 f0 10 f8 f4 2c 01 0b f4 78e38c f3 f2 78e4cc fe 66 f0 10 f8 f4 0b 01 16 f4 8a28a0 f3 f2 8a2949 fe 66 f0 10 f8 f4 16 01 21 f4 9b6db4 f3 f2 9b6ec8 fe 66 f0 10 f8 f4 21 01 2c f4 acb2c8 f3 f2 acb3e0 fe 66 f0 10 f8 f4 2c 01 0b f4 bdf7dc f3 f2 bdf8f6 fe 66 f0 10 f8 f4 0b 01 16 f4 cf3cf0 f3 f2 cf3d22 fe 66 f0 10 f8 f4 16 01 21 f4 e08204 f3 f2 e082eb fe 66 f0 10 f8 f4 21 01 2c f4 f1c718 f3 f2 f1c745 fe 66 f0 10 f8 f4 2c 01 0b f4 1030c2c f3 f2 1030c9c fe 66 f0 10 f8 f4 0b 01 16 f4 1145140 f3 f2 114518e fe 66 f0 10 f8 f4 16 01 21 f4 1259654 f3 f2 1259634 fe 66 f0 10 f8 f4 21 01 2c f4 136db68 f3 f2 136dc9c fe 66 f0 10 f8 f4 2c 01 0b f4 148207c f3 f2 148217d fe 66 f0 10 f8 f4 0b 01 16 f4 1596590 f3 f2 15965ae fe 66 f0 10 f8 f4 16 01 21 f4 16aaaa4 f3 f2 16aabb8 fe 66 f0 10 f8 f4 21 01 2c f4 17befb8 f3 f2 17bf02f fe 66 f0 10 f8 f4 2c 01 0b f4 18d34cc f3 f2 18d352a fe 66 f0 10 f8 f4 0b 01 16 f4 19e79e0 f3 f2 19e7ae7 fe 66 f0 10 f8 f4 16 01 21 f4 1afbef4 f3 f2 1afbf19 fe 66 f0 10 f8 f4 21 01 2c f4 1c10408 f3 f2 1c1043c fe 66 f0 10 f8 f4 2c 01 0b f4 1d2491c f3 f2 1d249a4 fe 66 f0 10 f8 f4 0b 01 16 f4 1e38e30 f3 f2 1e38e3e fe 66 f0 10 f8 f4 16 01 21 f4 1f4d344 f3 f2 1f4d3b0 fe 66 f0 10 f8 f4 21 01 2c f4 2061858 f3 f2 2061853 fe 66 f0 10 f8 f4 2c 01 0b f4 2175d6c f3 f2 2175e76 fe 66 f0 10 f8 f4 0b 01 16 f4 228a280 f3 f2 228a241 fe 66 f0 10 f8 f4 16 01 21 f4 239e794 f3 f2 239e866 fe 66 f0 10 f8 f4 21 01 2c f4 24b2ca8 f3 f2 24b2d81 fe 66 f0 10 f8 f4 2c 01 0b f4 25c71bc f3 f2 25c72f0 fe 66 f0 10 f8 f4 0b 01 16 f4 26db6d0 f3 f2 26db738 fe 66 f0 10 f8 f4 16 01 21 f4 27efbe4 f3 f2 27efcfc fe 66 f0 10 f8 f4 21 01 2c f4 29040f8 f3 f2 29041f1 fe 66 f0 10 f8 f4 2c 01 0b f4 2a1860c f3 f2 2a186e7 fe 66 f0 10 f8 f4 0b 01 16 f4 2b2cb20 f3 f2 2b2cbe3 fe 66 f0 10 f8 f4 16 01 21 f4 2c41034 f3 f2 2c4105d fe 66 f0 10 f8 f4 21 01 2c f4 2d55548 f3 f2 2d55595 fe 66 f0 10 f8 f4 2c 01 0b f4 2e69a5c f3 f2 2e69a7b fe 起初我是提取出的byte类型的opcode，学着别的师傅做得爆破，这里附一份带注释的爆破代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #define _CRT_SECURE_NO_WARNINGS 0 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; // 定义指令列表，存储虚拟机的指令 //unsigned char intr_list[] = { 246, 0, 0, 0, 108, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, ... }; unsigned char intr_list[] = { 246, 0, 0, 0, 108, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 71, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 13, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 5, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 19, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 10, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 2, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 1, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 74, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 21, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 18, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 19, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 8, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 15, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 11, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 14, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 18, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 2, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 21, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 21, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 22, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 2, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 7, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 14, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 4, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 10, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 10, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 15, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 17, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 19, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 31, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 74, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 31, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 10, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 18, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 5, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 5, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 8, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 15, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 1, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 7, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 10, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 14, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 18, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 20, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 3, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 17, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 21, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 8, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 7, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 19, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 9, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 31, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 70, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 246, 0, 0, 0, 47, 0, 0, 0, 246, 0, 0, 0, 102, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 247, 0, 0, 0, 248, 0, 0, 0, 243, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 247, 0, 0, 0, 244, 0, 0, 0, 77, 105, 78, 105, 1, 0, 0, 0, 76, 45, 99, 116, 244, 0, 0, 0, 0, 0, 0, 0, 243, 0, 0, 0, 242, 0, 0, 0, 15, 68, 45, 29, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 20, 69, 17, 0, 243, 0, 0, 0, 242, 0, 0, 0, 80, 114, 116, 116, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 40, 138, 34, 0, 243, 0, 0, 0, 242, 0, 0, 0, 77, 138, 34, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 60, 207, 51, 0, 243, 0, 0, 0, 242, 0, 0, 0, 170, 207, 51, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 80, 20, 69, 0, 243, 0, 0, 0, 242, 0, 0, 0, 203, 20, 69, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 100, 89, 86, 0, 243, 0, 0, 0, 242, 0, 0, 0, 102, 89, 86, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 120, 158, 103, 0, 243, 0, 0, 0, 242, 0, 0, 0, 188, 159, 103, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 140, 227, 120, 0, 243, 0, 0, 0, 242, 0, 0, 0, 204, 228, 120, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 160, 40, 138, 0, 243, 0, 0, 0, 242, 0, 0, 0, 73, 41, 138, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 180, 109, 155, 0, 243, 0, 0, 0, 242, 0, 0, 0, 200, 110, 155, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 200, 178, 172, 0, 243, 0, 0, 0, 242, 0, 0, 0, 224, 179, 172, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 220, 247, 189, 0, 243, 0, 0, 0, 242, 0, 0, 0, 246, 248, 189, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 240, 60, 207, 0, 243, 0, 0, 0, 242, 0, 0, 0, 34, 61, 207, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 4, 130, 224, 0, 243, 0, 0, 0, 242, 0, 0, 0, 235, 130, 224, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 24, 199, 241, 0, 243, 0, 0, 0, 242, 0, 0, 0, 69, 199, 241, 0, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 44, 12, 3, 1, 243, 0, 0, 0, 242, 0, 0, 0, 156, 12, 3, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 64, 81, 20, 1, 243, 0, 0, 0, 242, 0, 0, 0, 142, 81, 20, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 84, 150, 37, 1, 243, 0, 0, 0, 242, 0, 0, 0, 52, 150, 37, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 104, 219, 54, 1, 243, 0, 0, 0, 242, 0, 0, 0, 156, 220, 54, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 124, 32, 72, 1, 243, 0, 0, 0, 242, 0, 0, 0, 125, 33, 72, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 144, 101, 89, 1, 243, 0, 0, 0, 242, 0, 0, 0, 174, 101, 89, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 164, 170, 106, 1, 243, 0, 0, 0, 242, 0, 0, 0, 184, 171, 106, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 184, 239, 123, 1, 243, 0, 0, 0, 242, 0, 0, 0, 47, 240, 123, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 204, 52, 141, 1, 243, 0, 0, 0, 242, 0, 0, 0, 42, 53, 141, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 224, 121, 158, 1, 243, 0, 0, 0, 242, 0, 0, 0, 231, 122, 158, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 244, 190, 175, 1, 243, 0, 0, 0, 242, 0, 0, 0, 25, 191, 175, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 8, 4, 193, 1, 243, 0, 0, 0, 242, 0, 0, 0, 60, 4, 193, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 28, 73, 210, 1, 243, 0, 0, 0, 242, 0, 0, 0, 164, 73, 210, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 48, 142, 227, 1, 243, 0, 0, 0, 242, 0, 0, 0, 62, 142, 227, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 68, 211, 244, 1, 243, 0, 0, 0, 242, 0, 0, 0, 176, 211, 244, 1, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 88, 24, 6, 2, 243, 0, 0, 0, 242, 0, 0, 0, 83, 24, 6, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 108, 93, 23, 2, 243, 0, 0, 0, 242, 0, 0, 0, 118, 94, 23, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 128, 162, 40, 2, 243, 0, 0, 0, 242, 0, 0, 0, 65, 162, 40, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 148, 231, 57, 2, 243, 0, 0, 0, 242, 0, 0, 0, 102, 232, 57, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 168, 44, 75, 2, 243, 0, 0, 0, 242, 0, 0, 0, 129, 45, 75, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 188, 113, 92, 2, 243, 0, 0, 0, 242, 0, 0, 0, 240, 114, 92, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 208, 182, 109, 2, 243, 0, 0, 0, 242, 0, 0, 0, 56, 183, 109, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 228, 251, 126, 2, 243, 0, 0, 0, 242, 0, 0, 0, 252, 252, 126, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 248, 64, 144, 2, 243, 0, 0, 0, 242, 0, 0, 0, 241, 65, 144, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 12, 134, 161, 2, 243, 0, 0, 0, 242, 0, 0, 0, 231, 134, 161, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 11, 0, 0, 0, 1, 0, 0, 0, 22, 0, 0, 0, 244, 0, 0, 0, 32, 203, 178, 2, 243, 0, 0, 0, 242, 0, 0, 0, 227, 203, 178, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 22, 0, 0, 0, 1, 0, 0, 0, 33, 0, 0, 0, 244, 0, 0, 0, 52, 16, 196, 2, 243, 0, 0, 0, 242, 0, 0, 0, 93, 16, 196, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 33, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 244, 0, 0, 0, 72, 85, 213, 2, 243, 0, 0, 0, 242, 0, 0, 0, 149, 85, 213, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, 0, 0, 0, 16, 0, 0, 0, 248, 0, 0, 0, 244, 0, 0, 0, 44, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 244, 0, 0, 0, 92, 154, 230, 2, 243, 0, 0, 0, 242, 0, 0, 0, 123, 154, 230, 2, 254, 0, 0, 0, 102, 0, 0, 0, 240, }; // 定义答案数组，存储可能的输入值 unsigned char ans[0x1000]; // 当前答案数组的索引 int ans_i; // 指令列表的起始索引，0xb40 / 4 是将地址 0xb40 转换为指令索引 int idx = 0xb40 / 4; // 定义一个栈，用于存储中间值 stack\u0026lt;int\u0026gt; s; // 检查当前答案数组是否满足虚拟机的指令逻辑 int check() { unsigned char tmp; // 当前指令索引 int now_idx = idx; // 当前答案数组的索引 int now_ans_i = 0; // 将指令列表转换为 int 类型的指针，方便访问 int* intr_list_i = (int*)intr_list; // 定义一些变量，用于存储中间值 int p1 = 0, p2 = 0, p3 = 0, p4 = 0; // 标志位，用于控制条件跳转 int flag = 0; // 清空栈 while (!s.empty()) s.pop(); // 遍历指令列表，直到遇到终止指令（值为 0） while (intr_list_i[now_idx] != 0) { // 根据指令类型执行不同的操作 switch (intr_list_i[now_idx]) { case 1: // 将 p2 的值加上指令中的值 p2 += intr_list_i[now_idx + 1]; // 跳过指令中的值 now_idx += 2; break; case 16: // 从答案数组中读取一个字符并压入栈 tmp = ans[now_ans_i++]; s.push(tmp); now_idx += 1; break; case 17: // 打印 p1 的值 printf(\u0026#34;%c\u0026#34;, p1); now_idx += 1; break; case 240: // 将 p2 的值赋给 p1 p1 = p2; now_idx += 1; break; case 241: // 将 p2 的值赋给 p4 p4 = p2; now_idx += 1; break; case 242: // 比较 p1 和指令中的值 if (p1 == intr_list_i[now_idx + 1]) { flag = 1; // 如果相等，设置标志位 if (now_ans_i == ans_i) // 如果答案数组已全部处理 return 1; // 返回 1，表示验证通过 } else { flag = 0; // 如果不相等，清除标志位 } now_idx += 2; break; case 243: // 将 p1 和 p2 进行异或操作 p1 ^= p2; now_idx += 1; break; case 244: // 将 p1 的值加上指令中的值 p1 += intr_list_i[now_idx + 1]; now_idx += 2; break; case 245: // 从指令中读取两个值，进行减法操作 intr_list_i[now_idx + 1] -= intr_list_i[now_idx + 2]; now_idx += 3; break; case 246: // 将指令中的值压入栈 s.push(intr_list_i[now_idx + 1]); now_idx += 2; break; case 247: // 从栈中弹出一个值赋给 p1 p1 = s.top(); s.pop(); now_idx += 1; break; case 248: // 从栈中弹出一个值赋给 p2 p2 = s.top(); s.pop(); now_idx += 1; break; case 249: // 从栈中弹出一个值赋给 p3 p3 = s.top(); s.pop(); now_idx += 1; break; case 250: // 从栈中弹出一个值赋给 p4 p4 = s.top(); s.pop(); now_idx += 1; break; case 254: // 如果标志位为 0，返回 0，表示验证失败 if (flag == 0) { return 0; } now_idx += 2; break; case 255: // 条件跳转，如果标志位为 1，则跳过指令中的值 if (flag) now_idx += intr_list_i[now_idx + 1]; now_idx += 2; break; default: break; } } return 1; // 如果所有指令都执行完毕，返回 1，表示验证通过 } // 深度优先搜索函数，用于穷举所有可能的输入值 int dfs() { ans_i++; // 增加答案数组的索引 for (unsigned char ch = 0; ch \u0026lt;= 0x7f; ch++) { // 遍历所有可能的字符值 ans[ans_i - 1] = ch; // 将当前字符值赋给答案数组 if (check()) { // 调用 check 函数验证当前答案数组是否满足条件 if (ans_i == 45 || dfs()) // 如果答案数组长度达到 45 或递归调用 dfs 返回 1 return 1; // 返回 1，表示找到解 } } ans_i--; // 回溯，减少答案数组的索引 return 0; // 返回 0，表示当前路径无法找到解 } // 深度优先搜索的初始化函数 void dfs_init() { ans_i = 2; // 初始化答案数组的索引为 2 for (unsigned char ch1 = 0; ch1 \u0026lt;= 0x7f; ch1++) { // 遍历 ans[0] 的所有可能值 for (unsigned char ch2 = 0; ch2 \u0026lt;= 0x7f; ch2++) { // 遍历 ans[1] 的所有可能值 ans[0] = ch1; // 将当前值赋给 ans[0] ans[1] = ch2; // 将当前值赋给 ans[1] if (check() \u0026amp;\u0026amp; dfs()) { // 调用 check 函数验证当前答案数组是否满足条件，并递归调用 dfs cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; // 如果找到解，打印答案数组 return; // 退出函数 } } } } // 主函数 int main() { setbuf(stdout, 0); // 禁用输出缓冲 dfs_init(); // 调用初始化函数启动深度优先搜索 return 0; } 这份代码用的dfs爆破的，有的师傅用的z3也是可以爆破出来的 然后就是一份了解了主要逻辑后，用的dword的opcode写的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 raw_data = [ 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x114514,0xf3,0xf2,0x74747250,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x228a28,0xf3,0xf2,0x228a4d,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x33cf3c,0xf3,0xf2,0x33cfaa,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x451450,0xf3,0xf2,0x4514cb,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x565964,0xf3,0xf2,0x565966,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x679e78,0xf3,0xf2,0x679fbc,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x78e38c,0xf3,0xf2,0x78e4cc,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x8a28a0,0xf3,0xf2,0x8a2949,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x9b6db4,0xf3,0xf2,0x9b6ec8,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0xacb2c8,0xf3,0xf2,0xacb3e0,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0xbdf7dc,0xf3,0xf2,0xbdf8f6,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0xcf3cf0,0xf3,0xf2,0xcf3d22,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0xe08204,0xf3,0xf2,0xe082eb,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0xf1c718,0xf3,0xf2,0xf1c745,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x1030c2c,0xf3,0xf2,0x1030c9c,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x1145140,0xf3,0xf2,0x114518e,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x1259654,0xf3,0xf2,0x1259634,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x136db68,0xf3,0xf2,0x136dc9c,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x148207c,0xf3,0xf2,0x148217d,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x1596590,0xf3,0xf2,0x15965ae,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x16aaaa4,0xf3,0xf2,0x16aabb8,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x17befb8,0xf3,0xf2,0x17bf02f,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x18d34cc,0xf3,0xf2,0x18d352a,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x19e79e0,0xf3,0xf2,0x19e7ae7,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x1afbef4,0xf3,0xf2,0x1afbf19,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x1c10408,0xf3,0xf2,0x1c1043c,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x1d2491c,0xf3,0xf2,0x1d249a4,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x1e38e30,0xf3,0xf2,0x1e38e3e,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x1f4d344,0xf3,0xf2,0x1f4d3b0,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x2061858,0xf3,0xf2,0x2061853,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x2175d6c,0xf3,0xf2,0x2175e76,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x228a280,0xf3,0xf2,0x228a241,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x239e794,0xf3,0xf2,0x239e866,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x24b2ca8,0xf3,0xf2,0x24b2d81,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x25c71bc,0xf3,0xf2,0x25c72f0,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x26db6d0,0xf3,0xf2,0x26db738,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x27efbe4,0xf3,0xf2,0x27efcfc,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x29040f8,0xf3,0xf2,0x29041f1,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x2a1860c,0xf3,0xf2,0x2a186e7,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x0b,0x01,0x16,0xf4,0x2b2cb20,0xf3,0xf2,0x2b2cbe3,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x16,0x01,0x21,0xf4,0x2c41034,0xf3,0xf2,0x2c4105d,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x21,0x01,0x2c,0xf4,0x2d55548,0xf3,0xf2,0x2d55595,0xfe, 0x66,0xf0,0x10,0xf8,0xf4,0x2c,0x01,0x0b,0xf4,0x2e69a5c,0xf3,0xf2,0x2e69a7b,0xfe ] list_f4 = [] list_01 = [] list_ans = [] for i in range(len(raw_data) - 1): # 避免索引越界 if raw_data[i] == 0xf4: list_f4.append(raw_data[i + 1]) if raw_data[i] == 0x01: list_01.append(raw_data[i + 1]) if raw_data[i] == 0xf2: list_ans.append(raw_data[i + 1]) #print([hex(x) for x in list_f4]) #print([hex(x) for x in list_01]) #rint(len(list_ans) - 1) #print(len(list_f4) - 1) #print(len(list_01) - 1) list =\u0026#34;\u0026#34; len = len(list_ans) - 1#42 #print(len) a=125 for i in range(len): a=(list_ans[len]^(a+list_01[len]))-list_f4[len*2]-list_f4[len*2+1]-list_f4[len*2] list+=chr(a) len-=1 flag=list[::-1] print(\u0026#34;mi\u0026#34;+flag+\u0026#34;}\u0026#34;,end=\u0026#34; \u0026#34;) #下面也是爆破，也是可以参考的一份思路 \u0026#39;\u0026#39;\u0026#39; flag = \u0026#34;mi\u0026#34; ll = 0x74632DB5 for i in range(43): succeed = False for c in range(0,256): aa = c temp_ll = ll + list_f4[i*2] + list_f4[i*2+1] aa += list_01[i] if aa ^ temp_ll == list_ans[i]: ll = aa flag += chr(c) print(i,flag) succeed = True break if not succeed: print(\u0026#34;err\u0026#34;,i) \u0026#39;\u0026#39;\u0026#39; s1gn1n 在字符串列表看到一个base64的字符串，交叉引用就能到主要加密函数，大概的逻辑就是输出字符串，然后将它链表化，中序遍历，然后将中序遍历的结果进行base64编码，然后有个异或，最后就是求和判断返回值是否为零，为零就正确\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 import base64 from typing import Optional, List, Dict def get_left_count(n: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;精确计算完全二叉树左子树节点数\u0026#34;\u0026#34;\u0026#34; if n \u0026lt;= 0: return 0 h = 1 while (2 ** (h) - 1) \u0026lt; n: # 修正高度计算逻辑 h += 1 h -= 1 # 实际高度 last_level = n - (2 ** h - 1) left_max = 2 ** (h - 1) if h \u0026gt;= 1 else 0 left_actual = min(last_level, left_max) total = (2 ** (h) - 1) // 2 + left_actual #print(f\u0026#34;get_left_count(n={n}) h={h}, last_level={last_level}, left_max={left_max}, left_actual={left_actual}, return {total}\u0026#34;) return total def build_level_map(in_order: str, start: int, end: int, level_pos: int, level_map: Dict[int, str], depth=0): if start \u0026gt; end: #print(f\u0026#34; {\u0026#39; \u0026#39;*depth}start={start} \u0026gt; end={end}, return\u0026#34;) return n = end - start + 1 left_size = get_left_count(n) root_pos = start + left_size # print(f\u0026#34;{\u0026#39; \u0026#39;*depth}build_level_map: start={start}, end={end}, n={n}, left_size={left_size}, root_pos={root_pos}, level_pos={level_pos}\u0026#34;) # 边界检查 if root_pos \u0026lt; start or root_pos \u0026gt; end: #print(f\u0026#34; {\u0026#39; \u0026#39;*depth}Invalid root_pos={root_pos}, start={start}, end={end}\u0026#34;) return level_map[level_pos] = in_order[root_pos] # print(f\u0026#34; {\u0026#39; \u0026#39;*depth}Mapped level_pos={level_pos} -\u0026gt; char \u0026#39;{in_order[root_pos]}\u0026#39;\u0026#34;) # 递归左子树 build_level_map(in_order, start, root_pos-1, 2*level_pos+1, level_map, depth+1) # 递归右子树 build_level_map(in_order, root_pos+1, end, 2*level_pos+2, level_map, depth+1) def in_order_to_level_order(in_order_str: str) -\u0026gt; str: level_map: Dict[int, str] = {} build_level_map(in_order_str, 0, len(in_order_str)-1, 0, level_map) #print(\u0026#34;\\n层序映射表:\u0026#34;, level_map) if not level_map: return \u0026#39;\u0026#39; max_index = max(level_map.keys()) level_order = [] for i in range(max_index + 1): level_order.append(level_map.get(i, \u0026#39;\u0026#39;)) # 删除末尾的空字符串 while level_order and level_order[-1] == \u0026#39;\u0026#39;: level_order.pop() return \u0026#39;\u0026#39;.join(level_order) class Node: def __init__(self, value: str): self.value = value self.left: Optional[Node] = None self.right: Optional[Node] = None def build_tree_from_level_order(level_order: List[str]) -\u0026gt; Optional[Node]: if not level_order: return None root = Node(level_order[0]) queue = [root] i = 1 while queue and i \u0026lt; len(level_order): current = queue.pop(0) # 处理左子节点 if i \u0026lt; len(level_order) and level_order[i]: current.left = Node(level_order[i]) queue.append(current.left) i += 1 # 处理右子节点 if i \u0026lt; len(level_order) and level_order[i]: current.right = Node(level_order[i]) queue.append(current.right) i += 1 return root def in_order_traversal(root: Optional[Node], result: List[str]): if root: in_order_traversal(root.left, result) result.append(root.value) in_order_traversal(root.right, result) XOR_DATA = [ 0x58, 0x69, 0x7B, 0x06, 0x1E, 0x38, 0x2C, 0x20, 0x04, 0x0F, 0x01, 0x07, 0x31, 0x6B, 0x08, 0x0E, 0x7A, 0x0A, 0x72, 0x72, 0x26, 0x37, 0x6F, 0x49, 0x21, 0x16, 0x11, 0x2F, 0x1A, 0x0D, 0x3C, 0x1F, 0x2B, 0x32, 0x1A, 0x34, 0x37, 0x7F, 0x03, 0x44, 0x16, 0x0E, 0x01, 0x28, 0x1E, 0x68, 0x64, 0x23, 0x17, 0x09, 0x3D, 0x64, 0x6A, 0x69, 0x63, 0x18, 0x18, 0x0A, 0x15, 0x70 ] char_list = [] char_list.append(chr(XOR_DATA[0])) for j in range(1, len(XOR_DATA)): XOR_DATA[j]=XOR_DATA[j] ^ XOR_DATA[j - 1] char_list.append(chr(XOR_DATA[j] )) result = \u0026#39;\u0026#39;.join(char_list) #X1JLRjFfbmlkZ197MG5GaV9pQGVycnRMfTNzM21ucmlDZ2VubkV2X1RJRXM= #print(result) dec = base64.b64decode(result) #print(dec) #b\u0026#39;_RKF1_nidg_{0nFi_i@errtL}3s3mnriCgennEv_TIEs\u0026#39; dec =\u0026#34;_RKF1_nidg_{0nFi_i@errtL}3s3mnriCgennEv_TIEs\u0026#34; a1 = in_order_to_level_order(dec) print(a1) #miniLCTF{esrevER_gnir33nignE_Is_K1nd_0F_@rt} ","date":"2025-05-22T21:08:17+08:00","image":"https://s.panlai.com/zb_users/upload/2025/05/20250517050947174742978738940.jpg-arthumbs","permalink":"https://fanshanng.cn/p/minil/","title":"MiniL"},{"content":"frida基础知识 基础命令 1.frida-ps -U 查看当前手机运行的进程 2.frida-ps --help 查看help指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 frida-ps --help 使用方式: frida-ps [选项] 选项: -h, --help 显示帮助信息并退出 -D ID, --device ID 连接到具有给定ID的设备 -U, --usb 连接到USB设备 -R, --remote 连接到远程frida-server -H HOST, --host HOST 连接到HOST上的远程frida-server --certificate CERTIFICATE 与HOST进行TLS通信，期望的CERTIFICATE --origin ORIGIN 连接到设置了\u0026#34;Origin\u0026#34;头为ORIGIN的远程服务器 --token TOKEN 使用TOKEN验证HOST --keepalive-interval INTERVAL 设置心跳包间隔(秒)，或设置为0以禁用(默认为-1，根据传输方式自动选择) --p2p 与目标建立点对点连接 --stun-server ADDRESS 设置与--p2p一起使用的STUN服务器地址 --relay address,username,password,turn-{udp,tcp,tls} 添加与--p2p一起使用的中继 -O FILE, --options-file FILE 包含额外命令行选项的文本文件 --version 显示程序版本号并退出 -a, --applications 只列出应用程序 -i, --installed 包括所有已安装的应用程序 -j, --json 以JSON格式输出结果 操作模式 CLI模式：通过命令行直接将JavaScript脚本注入进程中。 RPC模式：使用Python进行JavaScript脚本的注入，适合复杂数据处理。 4.注入模式与启动命令\nSpawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App\n当需要监控App从启动开始的所有行为时使用 frida -U -f 进程名 -l hook.js 进程名可以通过frida-ps -U来查看\nAttach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作\nfrida -U 进程名 -l hook.js 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用\n5.基础语法 Java.use(className)：获取指定的Java类并使其在JavaScript代码中可用。 Java.perform(callback)：确保回调函数在Java的主线程上执行。 Java.choose(className, callbacks)：枚举指定类的所有实例。 Java.cast(obj, cls)：将一个Java对象转换成另一个Java类的实例。\n6.日志输出 console.log()：直接在命令行输出日志。 send()：将日志发送到外部Python脚本进行处理。\n日志捕获 D：表示级别 \u0026ldquo;zj2595\u0026quot;这个是标签\nFrida常用API 1. Hook普通方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义一个名为hookTest1的函数 function hookTest1(){ //获取一个名为\u0026#34;类名\u0026#34;的Java类，并将其实例赋值给JavaScript变量utils var utils = Java.use(\u0026#34;类名\u0026#34;); //修改\u0026#34;类名\u0026#34;的\u0026#34;method\u0026#34;方法的实现。这个新的实现会接收两个参数（a和b） utils.method.implementation = function(a, b){ //将参数a和b的值改为123和456。 a = 123; b = 456; //调用修改过的\u0026#34;method\u0026#34;方法，并将返回值存储在`retval`变量中 var retval = this.method(a, b); //在控制台上打印参数a，b的值以及\u0026#34;method\u0026#34;方法的返回值 console.log(a, b, retval); //返回\u0026#34;method\u0026#34;方法的返回值 return retval; } } 2. Hook重载参数 1 2 3 4 5 6 7 8 9 10 11 12 // .overload() // .overload(\u0026#39;自定义参数\u0026#39;) // .overload(\u0026#39;int\u0026#39;) function hookTest2(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //overload定义重载函数，根据函数的参数类型填 utils.Inner.overload(\u0026#39;com.zj.wuaipojie.Demo$Animal\u0026#39;,\u0026#39;java.lang.String\u0026#39;).implementation = function(a，b){ b = \u0026#34;aaaaaaaaaa\u0026#34;; this.Inner(a,b); console.log(b); } } 3. Hook构造函数 1 2 3 4 5 6 7 8 9 function hookTest3(){ var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的构造函数的实现，$init表示构造函数 utils.$init.overload(\u0026#39;java.lang.String\u0026#39;).implementation = function(str){ console.log(str); str = \u0026#34;52\u0026#34;; this.$init(str); } } 4. Hook字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function hookTest5(){ Java.perform(function(){ //静态字段的修改 var utils = Java.use(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;); //修改类的静态字段\u0026#34;flag\u0026#34;的值 utils.staticField.value = \u0026#34;我是被修改的静态变量\u0026#34;; console.log(utils.staticField.value); //非静态字段的修改 //使用`Java.choose()`枚举类的所有实例 Java.choose(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, { onMatch: function(obj){ //修改实例的非静态字段\u0026#34;_privateInt\u0026#34;的值为\u0026#34;123456\u0026#34;，并修改非静态字段\u0026#34;privateInt\u0026#34;的值为9999。 obj._privateInt.value = \u0026#34;123456\u0026#34;; //字段名与函数名相同 前面加个下划线 obj.privateInt.value = 9999; }, onComplete: function(){ } }); }); } 5. 枚举所有类与方法 1 2 3 4 5 6 7 8 9 10 function hookTest7() { Java.perform(function () { Java.enumerateLoadedClasses({ onMatch: function (name) { console.log(name); }, onComplete: function () {} }); }); } ","date":"2025-05-19T00:15:39+08:00","image":"https://raw.githubusercontent.com/fanshanng/blog_picture/master/3.png","permalink":"https://fanshanng.cn/p/fr1da/","title":"Frida"}]